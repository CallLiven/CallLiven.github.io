<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AVPlayer边播放边缓存02</title>
    <link href="/2020/05/22/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9802/"/>
    <url>/2020/05/22/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9802/</url>
    
    <content type="html"><![CDATA[<h1 id="续集"><a href="#续集" class="headerlink" title="续集"></a>续集</h1><p><a href="https://callliven.github.io/2020/05/19/AVPlayer边播放边缓存01/" target="_blank" rel="noopener">上文</a>完成了一个简单的自定义下载数据播放器，在这之后我们可以拿到下载的数据，接下来就是专门保存下载数据，首先这样定义，第一完整的视频保存为mp4格式，第二部分的缓存文件保存为tmp格式文件</p><p>既然要保存，首先就是要确定保存在什么位置，关于<a href="https://www.jianshu.com/p/b841ea19a8de" target="_blank" rel="noopener">苹果的沙盒</a>机制这里就不细聊了。</p><p>出于对短视频用户操作习惯的分析，对同一个视频，在不同时间，比如数小时之后，是不会再多次播放，也就是说我们做的缓存更多为了优化是以下的操作：</p><p>第一：观看短视频，会重播，可以直接读取上次的数据，避免流量浪费</p><p>第二：提高观看当前视频的流畅度</p><p>第三：切换视频，能更快播放</p><p>简而言之，视频文件是没有长时间保存在手机这么一个需求的，特别是说视频文件相对于其他文件，是比较大的。</p><p>最终我们是将视频及缓存文件保存在临时文件<code>tmp目录</code>下</p><p>创建一个CacheFileManager类用于管理缓存文件，这个类我是这么定义的，一个视频只对应一个CacheFileManager对象，便于管理一个视频多个下载的情况。</p><p>到这一步，由于是在上文中的第二种方式的基础上添加，就有点困难的，混乱中……对于整体架构没什么概念…单一职责…..工厂模式…..观察者模式……</p><p>当思索了许久都没有idea，则可以参考其他人的实现方式，这里推荐<a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA" target="_blank" rel="noopener">VIMediaCache</a>这篇文章，模块职责分得比较细，嵌套的有点多，所以要多看几次，方能了解结构（VIMediaCache第三方库，貌似还有点问题，本地已缓存整个视频的数据了，但是如果我关闭了网络，视频会出现播放不了的问题，并且经测试，在播放视频的时候，绝大部分数据依然是从线上拉取的。可能是我没搞清楚而出现这些疑问）</p>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVPlayer边播放边缓存-01</title>
    <link href="/2020/05/19/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9801/"/>
    <url>/2020/05/19/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9801/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>随着抖音的兴起，短视频是乎是每个app的标配，虽然以往开发的项目都有视频播放的功能，但都是集成第三方库的控件，直接使用的，对于avplayer的边播边缓存是如何实现不了解，趁着疫情宅在家里有空，研究一下，目标是自己也能封装一个播放器</p><p>分4篇文章</p><p>01 - 视频播放</p><p>02 - 视频分片下载</p><p>03 - 视频缓存</p><p>04 - 播放器封装</p><h1 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a>二、基本原理</h1><p>AVPlayer 没有提供API获取播放器下载的数据，所以无法直接获取缓存，但是可以通过设置AVAssetResourceLoader代理的方式，自己使用NSURLSession下载数据，再传给播放器播放，同时缓存在本地，下次播放的时候可以使用。</p><p>AVAssetResourceLoader 只有在AVURLAsset加载不能识别的URL资源的时候，才会回调代理方法，所以在初始化AVURLAsset的时候把目标视频URL地址的scheme替换成系统不能识别的schemen。</p><p><img src="https://i.loli.net/2020/05/19/BJWvbsLajEKHDFr.png" srcset="/img/loading.gif" alt="引用zltunes中的图片"></p><h4 id="（1）AVAssetResourceLoaderDelegate-代理有两个必须要实现的方法"><a href="#（1）AVAssetResourceLoaderDelegate-代理有两个必须要实现的方法" class="headerlink" title="（1）AVAssetResourceLoaderDelegate 代理有两个必须要实现的方法"></a>（1）AVAssetResourceLoaderDelegate 代理有两个必须要实现的方法</h4><p>要求加载资源的代理方法</p><p>返回YES，表示该代理类现在可以处理该请求，需要在这里保存loadingReques并开启下载数据的任务</p><p>下载回调中拿到响应数据后再对loadingRequest进行填充</p><p>如果返回NO，则表示当前代理不能处理，视频数据需要AVPlayer自己处理(但是之前视频URL的scheme被设置自定义的，所以AVPlayer不能识别，最后导致 AVPlayerItemStatusFailed)</p><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</code></pre><p>AVAssetResourceLoader取消了本次请求</p><p>把loadingRequest移除下载任务回调列表(停止填充数据)</p><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</code></pre><p>代理方法中<code>AVAssetResourceLoadingRequest</code>类非常关键，以下是该类常用的属性和方法</p><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSURLRequest</span> *request;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">AVAssetResourceLoadingContentInformationRequest</span> *contentInformationRequest;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest;- (<span class="hljs-keyword">void</span>)finishLoading;- (<span class="hljs-keyword">void</span>)finishLoadingWithError:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSError</span> *)error;</code></pre><p><code>request</code> 代表原始的请求，获取资源请求地址</p><p><code>contentInformationRequest</code> 播放资源相关的信息，比如资源格式contentType、资源长度大小contentLength、是否支持分片下载byteRangeAccessSupported等</p><p><code>dataRequest</code> 表示请求资源数据的范围。由于AVPlayer会触发分片下载的策略，也就是说一个视频资源可能对应多个AVAssetResourceLoadingRequest，可以从这个属性获取每个AVAssetResourceLoadingRequest请求数据的范围</p><p><code>- (void)finishLoading</code> 如果AVAssetResourceLoadingRequest要求下载的数据都下载完毕则调用此方法完成下载</p><p><code>- (void)finishLoadingWithError:(nullable NSError *)error;</code> 如果AVAssetResourceLoadingRequest对应的下载发生失败，则调用此方法</p><h4 id="（2）流程原理"><a href="#（2）流程原理" class="headerlink" title="（2）流程原理"></a>（2）流程原理</h4><p><img src="https://i.loli.net/2020/05/21/MPngKXNyshlxWLi.png" srcset="/img/loading.gif" alt="image-20200521141931947"></p><p>AVPlayer是分片式下载策略，可能会发起多个LoadingRequest请求，但触发下载的时候，会先发起一个Range为0~2的数据请求，获取视频资源的描述信息，比如文件类型、文件大小，这需要我们填充到<code>AVAssetResourceLoadingRequest</code>类中的<code>contentInformationRequest</code>属性，而获取到的data填充至<code>AVAssetResourceLoadingRequest</code>的<code>dataRequest</code>，<code>dataRequest</code>属性中有个方法可以接收增量连续的data数据:<code>- (void)respondWithData:(NSData *)data</code>，当<code>AVAssetResourceLoadingRequest</code>要求下载的数据都下载完毕，则调用<code>- (void)finishLoading</code>完成请求，并且AVPlayer会在调用<code>finishLoading</code>时判断接下来要怎么处理，比如视频文件类型是否支持、是否要发起下一个LoadingRequest等</p><h4 id="（3）重试机制"><a href="#（3）重试机制" class="headerlink" title="（3）重试机制"></a>（3）重试机制</h4><p>AVAssetResourceLoader在执行加载的时候，会时不时触发取消下载方法<code>\- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoa</code>，然后重新发起加载请求策略，如果下载了部分，重新发起的下载请求会从还没下载的部分开始。</p><h1 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h1><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>完整代码：链接:<a href="https://pan.baidu.com/s/1BR9MkKHxrk_T-mH5vV7NIQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1BR9MkKHxrk_T-mH5vV7NIQ</a>  密码:st0g</p><p><img src="https://i.loli.net/2020/05/21/p1Y4sXlwrFnbHx8.png" srcset="/img/loading.gif" alt="image-20200521134545223"></p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"ViewController.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;CoreServices/CoreServices.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kScheme @<span class="hljs-meta-string">"scheme"</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">AVAssetResourceLoaderDelegate</span>,<span class="hljs-title">NSURLSessionDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayer</span> *player;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerLayer</span> *playerLayer;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVURLAsset</span> *urlAsset;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerItem</span> *playerItem;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span>&lt;<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *&gt; *requestsArray;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSOperationQueue</span> *downloadQueue;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableData</span> *downloadData;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">BOOL</span>  byteRangeAccessSupported;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span>  contentLength;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>  ) <span class="hljs-built_in">NSString</span>  *contentType;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;    [<span class="hljs-keyword">super</span> viewDidLoad];        <span class="hljs-keyword">self</span>.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> blackColor];        _requestsArray = [<span class="hljs-built_in">NSMutableArray</span> array];    _downloadData = [<span class="hljs-built_in">NSMutableData</span> data];    <span class="hljs-comment">// URL</span>    <span class="hljs-built_in">NSString</span> *url = <span class="hljs-string">@"http://vfx.mtime.cn/Video/2019/03/18/mp4/190318231014076505.mp4"</span>;    <span class="hljs-built_in">NSURL</span> *videoURL = [<span class="hljs-built_in">NSURL</span> URLWithString:[kScheme stringByAppendingString:url]];        <span class="hljs-comment">// AVURLAsset</span>    _urlAsset = [<span class="hljs-built_in">AVURLAsset</span> URLAssetWithURL:videoURL options:<span class="hljs-literal">nil</span>];    [_urlAsset.resourceLoader setDelegate:<span class="hljs-keyword">self</span> queue:dispatch_get_main_queue()];    <span class="hljs-comment">// PlayerItem</span>    _playerItem = [<span class="hljs-built_in">AVPlayerItem</span> playerItemWithAsset:<span class="hljs-keyword">self</span>.urlAsset];    [_playerItem addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@"status"</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];    <span class="hljs-comment">// Player</span>    _player = [[<span class="hljs-built_in">AVPlayer</span> alloc]initWithPlayerItem:<span class="hljs-keyword">self</span>.playerItem];        <span class="hljs-comment">// PlayerLayer</span>    _playerLayer = [<span class="hljs-built_in">AVPlayerLayer</span> playerLayerWithPlayer:<span class="hljs-keyword">self</span>.player];    _playerLayer.videoGravity = <span class="hljs-built_in">AVLayerVideoGravityResizeAspect</span>;    _playerLayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.height);    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_playerLayer];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - AVAssetResourceLoaderDelegate</span><span class="hljs-comment">/// 要求加载资源的代理方法</span><span class="hljs-comment">/// 返回YES，表示该代理类现在可以处理该请求，需要在这里保存loadingReques并开启下载数据的任务</span><span class="hljs-comment">/// 下载回调中拿到响应数据后再对loadingRequest进行填充</span><span class="hljs-comment">/// 如果返回NO，则表示当前代理不能处理，视频数据需要AVPlayer自己处理(但是之前视频URL的scheme被设置自定义的，所以AVPlayer不能识别，最后导致 AVPlayerItemStatusFailed)</span>- (<span class="hljs-built_in">BOOL</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-built_in">NSString</span> *requestURL = loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([requestURL containsString:kScheme] &amp;&amp; ![_requestsArray containsObject:loadingRequest]) &#123;        [_requestsArray addObject:loadingRequest];                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.task == <span class="hljs-literal">nil</span>) &#123;            <span class="hljs-built_in">NSString</span> *orginURL = [requestURL stringByReplacingOccurrencesOfString:kScheme withString:<span class="hljs-string">@""</span>];            <span class="hljs-built_in">NSMutableURLRequest</span> *request = [[<span class="hljs-built_in">NSMutableURLRequest</span> alloc]initWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:orginURL] cachePolicy:(<span class="hljs-built_in">NSURLRequestUseProtocolCachePolicy</span>) timeoutInterval:<span class="hljs-number">20</span>];            <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];            [<span class="hljs-keyword">self</span>.task resume];        &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;<span class="hljs-comment">/// AVAssetResourceLoader取消了本次请求</span><span class="hljs-comment">/// 把loadingRequest移除下载任务回调列表(停止填充数据)</span>- (<span class="hljs-keyword">void</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    [_requestsArray removeObject:loadingRequest];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        <span class="hljs-keyword">self</span>.byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">self</span>.contentLength = response.expectedContentLength;    <span class="hljs-keyword">self</span>.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    <span class="hljs-comment">// 缓存下载的data</span>    [<span class="hljs-keyword">self</span>.downloadData appendData:data];    <span class="hljs-comment">// 拼接下载的data</span>    [<span class="hljs-keyword">self</span> processRequestData];        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"已下载：%f ，正在下载：%f"</span>,<span class="hljs-keyword">self</span>.downloadData.length/<span class="hljs-number">1024.0</span>,data.length/<span class="hljs-number">1024.0</span>);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - ProcessRequestData</span>- (<span class="hljs-keyword">void</span>)processRequestData &#123;    <span class="hljs-built_in">NSMutableArray</span> *requestCompleted = [<span class="hljs-built_in">NSMutableArray</span> array];    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *loadingRequest <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.requestsArray) &#123;        loadingRequest.contentInformationRequest.contentLength = <span class="hljs-keyword">self</span>.contentLength;        loadingRequest.contentInformationRequest.contentType = <span class="hljs-keyword">self</span>.contentType;        loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="hljs-keyword">self</span>.byteRangeAccessSupported;                <span class="hljs-built_in">BOOL</span> didRespondCompletely = [<span class="hljs-keyword">self</span> respondWithDataForRequest:loadingRequest.dataRequest];        <span class="hljs-keyword">if</span> (didRespondCompletely) &#123;            [requestCompleted addObject:loadingRequest];            [loadingRequest finishLoading];        &#125;    &#125;    [<span class="hljs-keyword">self</span>.requestsArray removeObjectsInArray:requestCompleted];&#125;<span class="hljs-comment">/// 判断loadingRequest要求下载的数据是否全部下载完毕</span><span class="hljs-comment">/// 以及将下载的数据data拼接到dataRequest当中</span><span class="hljs-comment">/// @param dataRequest dataRequest</span>- (<span class="hljs-built_in">BOOL</span>)respondWithDataForRequest:(<span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *)dataRequest &#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> startOffset = dataRequest.requestedOffset;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        startOffset = dataRequest.currentOffset;    &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.downloadData.length &lt; startOffset) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;    &#125;        <span class="hljs-built_in">NSUInteger</span> unreadBytes = <span class="hljs-keyword">self</span>.downloadData.length - startOffset;    <span class="hljs-built_in">NSUInteger</span> numberOfBytesToRespondWith = MIN(dataRequest.requestedLength, unreadBytes);        [dataRequest respondWithData:[<span class="hljs-keyword">self</span>.downloadData subdataWithRange:<span class="hljs-built_in">NSMakeRange</span>(startOffset, numberOfBytesToRespondWith)]];        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = startOffset + dataRequest.requestedLength;    <span class="hljs-built_in">BOOL</span> didResponsdComplete = <span class="hljs-keyword">self</span>.downloadData.length &gt;= endOffset;        <span class="hljs-keyword">return</span> didResponsdComplete;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - KVO</span>- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-keyword">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-keyword">id</span>&gt; *)change context:(<span class="hljs-keyword">void</span> *)context &#123;    <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-string">@"status"</span>]) &#123;        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">self</span>.playerItem.status) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusUnknown</span>: &#123;                <span class="hljs-comment">// 未知状态，不能播放</span>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusUnknown"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusReadyToPlay</span>: &#123;                <span class="hljs-comment">// 准备完毕，可以播放</span>                <span class="hljs-comment">// 此方法可以在视频未播放的时候，获取视频的总时长(备注：一定要在AVPlayer预加载状态status是AVPlayerItemStatusReadyToPlay才能获取)</span>                <span class="hljs-comment">// NSLog(@"total %f",CMTimeGetSeconds(self.playerItem.asset.duration));</span>                [<span class="hljs-keyword">self</span>.player play];                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusReadyToPlay"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusFailed</span>: &#123;                <span class="hljs-comment">// 加载失败，网络或者服务器出现问题</span>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusFailed"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>（PS：关于初始化NSURLSession请求会话的时候，设置<code>delegateQueue</code>代理回调线程的值，一定要设置成<code>主线程</code>，如果设置成其他自定义的operationQueue，AVPlayer会播放失败，这可能是在拼接数据及完成finishLoading的时候，AVPlayer会在当前线程刷新UI，所以必须设置在主线程完成）</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>完整代码：链接:<a href="https://pan.baidu.com/s/1C5JH6onUsmqgie1Loi1OgQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1C5JH6onUsmqgie1Loi1OgQ</a>  密码:rerp</p><p>这种方式是基于原理假想出来的，但是实际运行视频播放不出来，在完成第一个Range为0~2的loadingRequest请求后，提示<strong>AVPlayerItemStatusFailed</strong>错误，尝试了很久，一直都未能解决，百思不得其解。如果有其他同行知道原因的，麻烦在评论区留意，感谢</p><p><img src="https://i.loli.net/2020/05/21/spL4GkAVWXM38fJ.png" srcset="/img/loading.gif" alt="image-20200521140754935"></p><p>以下是RequestDownder的代码</p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"RequestDownder.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;MobileCoreServices/MobileCoreServices.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RequestDownder</span>()&lt;<span class="hljs-title">NSURLSessionDataDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RequestDownder</span></span><span class="hljs-comment">/// 开始下载</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>+ (<span class="hljs-keyword">instancetype</span>)startDownLoadWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    RequestDownder *downer = [[RequestDownder alloc]initWithLoadingRequest:loadingRequest];    <span class="hljs-keyword">return</span> downer;&#125;- (<span class="hljs-keyword">instancetype</span>)initWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest = loadingRequest;        [<span class="hljs-keyword">self</span> setup];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;- (<span class="hljs-keyword">void</span>)cancle &#123;    [<span class="hljs-keyword">self</span>.session invalidateAndCancel];&#125;<span class="hljs-comment">/// 发起请求</span>- (<span class="hljs-keyword">void</span>)setup  &#123;    <span class="hljs-comment">// 获取请求范围</span>    <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest = <span class="hljs-keyword">self</span>.loadingRequest.dataRequest;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = dataRequest.requestedOffset;    <span class="hljs-built_in">NSInteger</span> length = dataRequest.requestedLength;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        offset = dataRequest.currentOffset;    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = offset + length - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 获取请求连接URL</span>    <span class="hljs-built_in">NSString</span> *urlStr = <span class="hljs-keyword">self</span>.loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([urlStr hasPrefix:<span class="hljs-string">@"scheme"</span>]) &#123;       urlStr = [urlStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"scheme"</span> withString:<span class="hljs-string">@""</span>];    &#125;        <span class="hljs-comment">// 发起请求</span>    <span class="hljs-built_in">NSMutableURLRequest</span> *request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:urlStr] cachePolicy:<span class="hljs-built_in">NSURLRequestReloadIgnoringCacheData</span> timeoutInterval:<span class="hljs-number">20.0</span>];    <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"bytes=%lld-%lld"</span>,offset,endOffset];    [request setValue:range forHTTPHeaderField:<span class="hljs-string">@"Range"</span>];        <span class="hljs-comment">// 开始下载</span>    <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];    [<span class="hljs-keyword">self</span>.task resume];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDataDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = response.expectedContentLength;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];    &#125;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = response.MIMEType;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:data];&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d -- %d"</span>,<span class="hljs-keyword">self</span>.loadingRequest.isCancelled,<span class="hljs-keyword">self</span>.loadingRequest.isFinished);    [<span class="hljs-keyword">self</span>.loadingRequest finishLoading];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(requestDowner:didComplete:)]) &#123;        [<span class="hljs-keyword">self</span>.delegate requestDowner:<span class="hljs-keyword">self</span> didComplete:error];    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>突然心情开朗，终于知道第二种方式问题的关键点(测试代码下载地址：链接:<a href="https://pan.baidu.com/s/16hFRJaDgFJzj2IQadaW87w" target="_blank" rel="noopener">https://pan.baidu.com/s/16hFRJaDgFJzj2IQadaW87w</a>  密码:z0cw）</p><p>前面说的resourceLoader触发下载，会先发起一个range为0~2的request，来获取视频资源的详情，比如文件长度，接着就是将获取的文件详情填充至<code>contentInformationRequest</code>，到这为止是没有错的，但是，<code>contentInformationRequest</code>是相对于整个视频资源文件的，这非常关键，也就是说设置的文件格式、文件长度都是指整个文件，而并不是指每一个发起的<code>AVAssetResourceLoadingRequest</code>的长度。</p><p>所以在第二种方式中，由于每一个<code>AVAssetResourceLoadingRequest</code>单独发起一个request请求，并且设置request请求数据范围range值，所以获取到的文件长度是对应于当前请求范围range，并不是指整个文件的长度。因此才会在发起第一个<code>AVAssetResourceLoadingRequest</code>请求range为0~2后，就没有继续发起第二个<code>AVAssetResourceLoadingRequest</code>了，因为resourceLoader会判断整个视频资源已经下载完成了。</p><p>激动<del>~</del>终于知道原因了，可以继续往前走，太不容易了，每一个小细节都可能导致失败</p><p><strong>好了，问题来了，那要怎么分片下载，并且获取整个视频文件的长度？</strong></p><p>貌似很矛盾的一个问题，其实是文件长度的取的字段有问题，通过答应服务器响应的<code>NSURLResponse</code>如下图，使用，代码改为如下就能解决问题了</p><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];        contentLength = [[[httpResponse.allHeaderFields[<span class="hljs-string">@"Content-Range"</span>] componentsSeparatedByString:<span class="hljs-string">@"/"</span>] lastObject] longLongValue];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentLength&gt;<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;</code></pre><p><img src="https://i.loli.net/2020/05/22/jSz4NmBFy3TR8LV.png" srcset="/img/loading.gif" alt="image-20200522120244479"></p><p><strong>修改后完整的代码</strong></p><p>下载地址：链接:<a href="https://pan.baidu.com/s/1voLndB23xy8Jcggrf_fYCQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1voLndB23xy8Jcggrf_fYCQ</a>  密码:2kc2</p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"RequestDownder.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;MobileCoreServices/MobileCoreServices.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RequestDownder</span>()&lt;<span class="hljs-title">NSURLSessionDataDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RequestDownder</span></span><span class="hljs-comment">/// 开始下载</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>+ (<span class="hljs-keyword">instancetype</span>)startDownLoadWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    RequestDownder *downer = [[RequestDownder alloc]initWithLoadingRequest:loadingRequest];    <span class="hljs-keyword">return</span> downer;&#125;- (<span class="hljs-keyword">instancetype</span>)initWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest = loadingRequest;        [<span class="hljs-keyword">self</span> setup];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;- (<span class="hljs-keyword">void</span>)cancle &#123;    [<span class="hljs-keyword">self</span>.session invalidateAndCancel];&#125;<span class="hljs-comment">/// 发起请求</span>- (<span class="hljs-keyword">void</span>)setup  &#123;    <span class="hljs-comment">// 获取请求范围</span>    <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest = <span class="hljs-keyword">self</span>.loadingRequest.dataRequest;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = dataRequest.requestedOffset;    <span class="hljs-built_in">NSInteger</span> length = dataRequest.requestedLength;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        offset = dataRequest.currentOffset;    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = offset + length - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 获取请求连接URL</span>    <span class="hljs-built_in">NSString</span> *urlStr = <span class="hljs-keyword">self</span>.loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([urlStr hasPrefix:<span class="hljs-string">@"scheme"</span>]) &#123;       urlStr = [urlStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"scheme"</span> withString:<span class="hljs-string">@""</span>];    &#125;        <span class="hljs-comment">// 发起请求</span>    <span class="hljs-built_in">NSMutableURLRequest</span> *request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:urlStr] cachePolicy:<span class="hljs-built_in">NSURLRequestReloadIgnoringCacheData</span> timeoutInterval:<span class="hljs-number">20.0</span>];    <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"bytes=%lld-%lld"</span>,offset,endOffset];    [request setValue:range forHTTPHeaderField:<span class="hljs-string">@"Range"</span>];        <span class="hljs-comment">// 开始下载</span>    <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];    [<span class="hljs-keyword">self</span>.task resume];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDataDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];        contentLength = [[[httpResponse.allHeaderFields[<span class="hljs-string">@"Content-Range"</span>] componentsSeparatedByString:<span class="hljs-string">@"/"</span>] lastObject] longLongValue];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentLength&gt;<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:data];&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    [<span class="hljs-keyword">self</span>.loadingRequest finishLoading];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(requestDowner:didComplete:)]) &#123;        [<span class="hljs-keyword">self</span>.delegate requestDowner:<span class="hljs-keyword">self</span> didComplete:error];    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>到这为止，已经能完成一个通过自己自定义的下载，再将下载数据填充给AVPlayer播放器播放的例子，距离封装一个自己的播放器的路很有很远，继续前行…为自己加油</p><h1 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h1><p>1、 <a href="https://juejin.im/post/5cb69acbf265da03b4460955" target="_blank" rel="noopener">AVPlayer详解系列（一）参数设置</a></p><p>2、 <a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA?#%23" target="_blank" rel="noopener">可能是目前最好的 AVPlayer 音视频缓存方案</a></p><p>3、 <a href="https://zltunes.github.io/2019/04/23/avplayer-best-practice/" target="_blank" rel="noopener">AVPlayer 边下边播与最佳实践</a></p><p>4、  <a href="http://chuquan.me/2019/12/03/ios-avplayer-support-cache/" target="_blank" rel="noopener">iOS AVPlayer 视频缓存的设计与实现</a></p><p>5、  <a href="http://xferris.cn/avplayer_cache/" target="_blank" rel="noopener">AVPlayer初体验之边下边播与视频缓存</a></p><p>6、  <a href="https://juejin.im/post/5a1e94b7f265da4326529995" target="_blank" rel="noopener">唱吧 iOS 音视频缓存处理框架</a></p><p>7、  <a href="https://chenzhengying.com/html/iOS/ZYPlayer/ZYPlayer.html" target="_blank" rel="noopener">基于AVPlayer封装的播放器细节</a></p><p>8、  <a href="https://msching.github.io/blog/2016/05/24/audio-in-ios-9/" target="_blank" rel="noopener">iOS音频播放 (九)：边播边缓存</a></p><p>9、<a href="https://www.jianshu.com/p/c157476474f1" target="_blank" rel="noopener">基于AVPlayer实现边缓存边播放</a></p><p>PPT下载地址</p><p>链接:<a href="https://pan.baidu.com/s/1Jx88y25EmNu7SMpkVyTr4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1Jx88y25EmNu7SMpkVyTr4Q</a>  密码:8rt3</p><center class="half"> <div>感谢你的“一分”支持</div>  <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基本使用和封装教程看我的就可以了</title>
    <link href="/2020/05/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>赶在2019年春节放假前一天，发一最后一波文章，虽然有点凌乱，但绝对使用<br>大力我上一家公司是做即时聊天应用的，聊天功能不是走第三方的平台,如环信、网易云等，毕竟是应用的核心功能，所以还是掌握在自己手上比较靠谱(结果各种坑)，当然还没到自定义协议那一高层次，我们使用的WebSocket，所以比如socket发消息的保证、socket重连、UI搭建等等都是需要自己从零开始做起，其中少不了重要的一环：聊天记录和用户数据的保存。<br>铺垫这么久了，是时候回归我们今天要讨论的话题：数据库</p><p>项目数据库管理是使用常用的第三方框架：FMDB，今天只讲一些常用的sql语法和功能，具体的代码说明已经在代码注释写了…请看代码</p><pre><code class="hljs objective-c">@interface ViewController ()@property (nonatomic, copy, readwrite) NSString *fileName;@property (nonatomic, strong, readwrite) FMDatabase *db;@property (nonatomic, strong, readwrite) FMDatabaseQueue *queue;@end@implementation ViewController- (void)viewDidLoad &#123;    [super viewDidLoad];        &#x2F;&#x2F; 数据库路径    NSString *doc &#x3D; [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];    NSString *fileName &#x3D; [doc stringByAppendingPathComponent:@&quot;student.db&quot;];    self.fileName &#x3D; fileName;    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;%@&quot;,fileName);&#125;#pragma mark - touch- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;&#x2F;&#x2F;    [self insert];&#x2F;&#x2F;    [self update];&#x2F;&#x2F;    [self delete];&#x2F;&#x2F;    [self query];    [self dataBaseQueueAction];&#125;@end</code></pre><h1 id="1、数据库基本使用：增删改查"><a href="#1、数据库基本使用：增删改查" class="headerlink" title="1、数据库基本使用：增删改查"></a>1、数据库基本使用：增删改查</h1><pre><code class="hljs objective-c">#pragma mark - FMDB 增删改查- (void)baseUseDemo &#123;    &#x2F;*     三大类     (1)FMDatabase     一个FMDatabase对象就代表一个单独的SQLite数据库     用来执行SQL语句     (2)FMResultSet     使用FMDatabase执行查询后的结果集     (3)FMDatabaseQueue     用于在多线程中执行多个查询或更新，它是线程安全的     *&#x2F;            &#x2F;&#x2F; 获得数据库    &#x2F;*     有三种情况     （1）具体文件路径     　　如果不存在会自动创建     （2）空字符串@&quot;&quot;     　　会在临时目录创建一个空的数据库     　　当FMDatabase连接关闭时，数据库文件也被删除     （3）nil     　　会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁     *&#x2F;    FMDatabase *db &#x3D; [FMDatabase databaseWithPath:self.fileName];        &#x2F;&#x2F; 打开数据库    if ([db open]) &#123;        NSString *sqlString &#x3D; @&quot;CREATE TABLE IF NOT EXISTS t_student(id integer PRIMARY KEY AUTOINCREMENT,name text NOT NULL , age integer NOT NULL);&quot;;        BOOL result &#x3D; [db executeUpdate:sqlString];        if (result) &#123;            NSLog(@&quot;创表成功&quot;);        &#125;        else&#123;            NSLog(@&quot;创表失败&quot;);        &#125;    &#125;        self.db &#x3D; db;&#125;#pragma mark - 数据库sql语句&#x2F;&#x2F; w3school sql 语句学习：http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;sql&#x2F;sql_distinct.asp&#x2F;** 插入数据 *&#x2F;- (void)insert &#123;    for (int i&#x3D;0; i&lt;10; i++) &#123;        NSString *name &#x3D; [NSString stringWithFormat:@&quot;liven-%d&quot;,arc4random_uniform(100)];        [self.db executeUpdate:@&quot;INSERT INTO t_student (name,age) VALUES (?,?)&quot;,name,@(arc4random_uniform(40))];    &#125;&#125;&#x2F;** 删除 *&#x2F;- (void)delete &#123;    &#x2F;&#x2F; 清空数据库表的数据(这只是删除所有行的数据，并不会对表的结构、属性和索性有影响)    &#x2F;&#x2F;（即使数据库没有这张表，删除也不会崩溃，只会报错）    [self.db executeUpdate:@&quot;DELETE FROM t_student&quot;];        &#x2F;&#x2F; 删除某一行：DELETE FROM 表名称 WHERE 列名称 &#x3D; 值&#125;&#x2F;** 更新 *&#x2F;- (void)update &#123;    &#x2F;&#x2F; 公式：UPDATE 表名称 SET 列名称 &#x3D; 新值 WHERE 列名称 &#x3D; 某值  [self.db executeUpdate:@&quot;UPDATE t_student SET age&#x3D;? WHERE name&#x3D;&#39;大力&#39;&quot;,@(18)];&#125;&#x2F;** 查询 *&#x2F;- (void)query &#123;    FMResultSet *resultSet &#x3D; [self.db executeQuery:@&quot;SELECT * FROM t_student&quot;];    while ([resultSet next]) &#123;        int ID &#x3D; [resultSet intForColumn:@&quot;id&quot;];        NSString *name &#x3D; [resultSet stringForColumn:@&quot;name&quot;];        int age &#x3D; [resultSet intForColumn:@&quot;age&quot;];        NSLog(@&quot;%d %@ %d&quot;,ID,name,age);    &#125;&#125;</code></pre><h1 id="2、批处理"><a href="#2、批处理" class="headerlink" title="2、批处理"></a>2、批处理</h1><pre><code class="hljs objective-c">#pragma mark - 批处理- (void)lotOperation &#123;    NSString *creatSqlString &#x3D; @&quot;CREATE TABLE IF NOT EXISTS t_person (id integer PRINARY KEY AUTOINCREMENT,name text NOT NULL, age integer NOT NULL, age integer NOT NULL);&quot;    @&quot;CREATE TABLE IF NOT EXISTS t_student (id integer PRINARY KEY AUTOINCREMENT,name text NOT NULL, age integer NOT NULL, age integer NOT NULL);&quot;;    [self.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        [db executeStatements:creatSqlString];    &#125;];&#125;</code></pre><h1 id="3、线程安全databaseQueue"><a href="#3、线程安全databaseQueue" class="headerlink" title="3、线程安全databaseQueue"></a>3、线程安全databaseQueue</h1><pre><code class="hljs objective-c">#pragma mark - dataBaseQueue线程安全- (void)dataBaseQueueAction &#123;        &#x2F;*      备注：        1、FMDatabaseQueue初始化时已将数据库打开和关闭封装好了，所以操作时不需要单独调用FMDatabase的open和close方法        2、FMDatabaseQueue是基于同步串行队列保证数据库访问的安全性，所以不能叠加使用，避免死锁     *&#x2F;        &#x2F;&#x2F; 获取数据库队列    FMDatabaseQueue *queue &#x3D; [FMDatabaseQueue databaseQueueWithPath:self.fileName];    [queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        BOOL resutl &#x3D; [db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_person (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL);&quot;];        if (resutl) &#123;            NSLog(@&quot;创表成功&quot;);        &#125;        else&#123;            NSLog(@&quot;创表失败&quot;);        &#125;    &#125;];    self.queue &#x3D; queue;        &#x2F;&#x2F; 插入数据    [self.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        [db executeUpdate:@&quot;INSERT INTO t_person (name,age) VALUES (?,?);&quot;,@&quot;wendingding&quot;,@(22)];    &#125;];        &#x2F;&#x2F; 查询    [self.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        FMResultSet *resultSet &#x3D; [db executeQuery:@&quot;SELECT * FROM t_person&quot;];        while ([resultSet next]) &#123;            int ID &#x3D; [resultSet intForColumn:@&quot;id&quot;];            NSString *name &#x3D; [resultSet stringForColumn:@&quot;name&quot;];            int age &#x3D; [resultSet intForColumn:@&quot;age&quot;];            NSLog(@&quot;%d %@ %d&quot;,ID,name,age);        &#125;    &#125;];        &#x2F;*     备注：     https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;15720272&#x2F;when-to-close-sqlite-database-using-fmdb     数据库不需频繁的切换open和close两种状态，否则会造成不小的性能损耗(如cpu使用率)，FMDB的作者也提到     只有在需要更改数据库模式的时候才需要切换状态，即使是退到后台线程也是不需要关闭的，维持数据打开的状态就可以     *&#x2F;    &#125;</code></pre><h1 id="4、事务"><a href="#4、事务" class="headerlink" title="4、事务"></a>4、事务</h1><pre><code class="hljs objective-c">&#x2F;&#x2F; 事务:所有任务执行完成后才再将结果一次性提交到数据库&#x2F;&#x2F; 特点:要么全部成功，要么全部失败(如果中途出现问题，则会回滚)&#x2F;&#x2F; 注意：开启事务比不开事务的耗时更少[self.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;    &#x2F;&#x2F; 开启事务    [db beginTransaction];    BOOL first &#x3D; [db executeUpdate:@&quot;INSERT INTO t_person (name,age) VALUES (?,?);&quot;,@&quot;lucky&quot;,@(22)];    BOOL second &#x3D; [db executeUpdate:@&quot;INSERT INTO t_person (name,age) VALUES (?,?);&quot;,@&quot;james&quot;,@(22)];    &#x2F;&#x2F; 如果其中一个失败，则结束，数据回滚    if (!first || !second) &#123;        [db rollback];        return ;    &#125;    &#x2F;&#x2F; 提交事务    [db commit];&#125;];&#x2F;&#x2F; 另外一种实现方式[self.queue inTransaction:^(FMDatabase * _Nonnull db, BOOL * _Nonnull rollback) &#123;    BOOL first &#x3D; [db executeUpdate:@&quot;INSERT INTO t_person (name,age) VALUES (?,?);&quot;,@&quot;wendi&quot;,@(22)];    BOOL second &#x3D; [db executeUpdate:@&quot;INSERT INTO t_person (name,age) VALUES (?,?);&quot;,@&quot;davi&quot;,@(22)];    if (!first || !second) &#123;        *rollback &#x3D; YES;        return ;    &#125;&#125;];</code></pre><h1 id="5、判断某张表是否存在"><a href="#5、判断某张表是否存在" class="headerlink" title="5、判断某张表是否存在"></a>5、判断某张表是否存在</h1><pre><code class="hljs objective-c">#pragma mark - 判断某张表是否存在- (void)chectDatabaseTableExists &#123;    &#x2F;*     备注：        sqlite中有一个内k建表sqlite_master,这个表中存储这个所有自建表的表名称等信息        可以通过：select * from sqlite_master 查看这个内建表的所有记录                  引申：判断指定的表是否存在，可以用如下语句        select count(*) from sqlite_master wheretype&#x3D;&#39;table&#39; and name&#x3D;&#39;要查询的表名&#39;        如果查询结果大于0，表示该表存在于数据库中，否则不存在             详情：        https:&#x2F;&#x2F;blog.csdn.net&#x2F;aflyeaglenku&#x2F;article&#x2F;details&#x2F;50884837     *&#x2F;&#125;</code></pre><h1 id="6、检测字段是否存在-并且添加字段"><a href="#6、检测字段是否存在-并且添加字段" class="headerlink" title="6、检测字段是否存在(并且添加字段)"></a>6、检测字段是否存在(并且添加字段)</h1><pre><code class="hljs objective-c">#pragma mark - 检测字段是否存在(并且添加字段)- (void)checkDatabaseColumn &#123;    &#x2F;*        sqlite中并没有直接删除列和重命名列名称的sql语句，但是可以使用下面的思路实现同样的效果        1、新建一个新表(新表的字段除了要删除的字段外，其余的都要)        2、将旧表的值copy到新表        3、删除旧表        4、重命名表表名             详情：        https:&#x2F;&#x2F;blog.csdn.net&#x2F;aflyeaglenku&#x2F;article&#x2F;details&#x2F;50884837     *&#x2F;        [self.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        if ([db columnExists:@&quot;phone&quot; inTableWithName:@&quot;t_person&quot;]) &#123;            &#x2F;&#x2F; 如果t_person表中存在phone这个字段，不需要操作        &#125;else&#123;            &#x2F;&#x2F; 如果t_person表中不存在phone这个字段，插入列            [db executeUpdate:@&quot;ALTER TABLE t_person ADD phone text&quot;];        &#125;    &#125;];&#125;</code></pre><h1 id="7、表迁移"><a href="#7、表迁移" class="headerlink" title="7、表迁移"></a>7、表迁移</h1><pre><code class="hljs objective-c">#pragma mark - 表迁移- (void)updateToNewTable &#123;    &#x2F;*     这功能主要是表设计结构变更的时候需要使用     思路：        重新创建一个表        将旧表数据导入到新的表中        删除旧表     *&#x2F;&#125;</code></pre><h1 id="8、多表联查-重点：此处先介绍左连、右连、内连的概念"><a href="#8、多表联查-重点：此处先介绍左连、右连、内连的概念" class="headerlink" title="8、多表联查(重点：此处先介绍左连、右连、内连的概念)"></a>8、多表联查(重点：此处先介绍左连、右连、内连的概念)</h1><pre><code class="hljs objective-c">#pragma mark - 多表连查 join- (void)mulTable &#123;    &#x2F;*     左连接：左边有的，右边没有的为null     右连接：左边没有的，右边有的为null     内连接：显示左边右边共有的          详情介绍：     https:&#x2F;&#x2F;blog.csdn.net&#x2F;wang0112233&#x2F;article&#x2F;details&#x2F;78418698     https:&#x2F;&#x2F;blog.csdn.net&#x2F;plg17&#x2F;article&#x2F;details&#x2F;78758593     *&#x2F;        &#x2F;&#x2F; 实例：比如有两个表A和B,联查条件A.a字段与B.b字段相同    NSLog(@&quot;select A.*,B.* from A left join B on(A.a &#x3D; B.b)&quot;);&#125;</code></pre><h1 id="9、创建索引"><a href="#9、创建索引" class="headerlink" title="9、创建索引"></a>9、创建索引</h1><pre><code class="hljs objective-c">#pragma mark - 创建索引(有索引后查找速度更快速)- (void)createIndex &#123;    &#x2F;*        备注：        1、在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。        2、更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。           因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引             公式：CREATE INDEX index_name ON table_name (column_name)        详情介绍：        http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;sql&#x2F;sql_create_index.asp     *&#x2F;        &#x2F;&#x2F; 实例：创建一个简单的索引，名为 &quot;PersonIndex&quot;，在 Person 表的 LastName 列：    NSLog(@&quot;CREATE INDEX PersonIndex ON Person(LastName)&quot;);&#125;</code></pre><h1 id="10、数据库的删除-清空"><a href="#10、数据库的删除-清空" class="headerlink" title="10、数据库的删除(清空)"></a>10、数据库的删除(清空)</h1><pre><code class="hljs objective-c">#pragma mark - 数据库的删除(清空)- (void)clearTable &#123;    &#x2F;*        1、删除表(表的结构、属性以及索引也会被删除)        DROP TABLE表名称             2、删除数据库        DROP DATABASE数据库名称             3、清空表内的数据，但并不删除表本身        TRUNCATE TABLE表名称          *&#x2F;&#125;</code></pre><h1 id="11、统计表的数据"><a href="#11、统计表的数据" class="headerlink" title="11、统计表的数据"></a>11、统计表的数据</h1><pre><code class="hljs objective-c">#pragma mark - 统计表的数据- (void)tableCount &#123;        &#x2F;&#x2F; 统计某表（如Person）的数据量    NSLog(@&quot;SELECT COUNT(*) FROM Person&quot;);        &#x2F;&#x2F; 统计某表某列的数据量（如：Person中name的数量，备注：NULL不计入）    NSLog(@&quot;SELECT COUNT(name) FROM Person&quot;);&#125;</code></pre><h1 id="12、分页读取数据"><a href="#12、分页读取数据" class="headerlink" title="12、分页读取数据"></a>12、分页读取数据</h1><pre><code class="hljs objective-c">#pragma mark - 分页读取数据- (void)pageData &#123;    &#x2F;&#x2F; 实例：分页获取表Person中数据，每页20条    &#x2F;&#x2F; 从第0行开始获取 一次获取20条    NSLog(@&quot;SELECT * FROM Person LIMIT 0,20&quot;);    &#x2F;&#x2F; 从第21行开始获取 一次获取20条    NSLog(@&quot;SELECT * FROM Person LIMIT 20,20&quot;);    &#125;</code></pre><h1 id="13、数据写入和读出处理-如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理"><a href="#13、数据写入和读出处理-如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理" class="headerlink" title="13、数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)"></a>13、数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)</h1><pre><code class="hljs objective-c">#pragma mark - 数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)- (NSString *)inDBReplaceStr:(NSString *)inStr &#123;    NSString *tempStr &#x3D; inStr;    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;&quot; withString:@&quot;&#x2F;&#x2F;&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#39;&quot; withString:@&quot;&#39;&#39;&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;[&quot; withString:@&quot;&#x2F;[&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;]&quot; withString:@&quot;&#x2F;]&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;%&quot; withString:@&quot;&#x2F;%&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&amp;&quot; withString:@&quot;&#x2F;&amp;&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;_&quot; withString:@&quot;&#x2F;_&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;(&quot; withString:@&quot;&#x2F;(&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;)&quot; withString:@&quot;&#x2F;)&quot;];    return tempStr;&#125;- (NSString *)outDBReplaceStr:(NSString *)outStr &#123;    NSString *tempStr &#x3D; outStr;    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;&#x2F;&quot; withString:@&quot;&#x2F;&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#39;&#39;&quot; withString:@&quot;&#39;&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;[&quot; withString:@&quot;[&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;]&quot; withString:@&quot;]&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;%&quot; withString:@&quot;%&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;&amp;&quot; withString:@&quot;&amp;&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;_&quot; withString:@&quot;_&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;(&quot; withString:@&quot;(&quot;];    tempStr &#x3D; [tempStr stringByReplacingOccurrencesOfString:@&quot;&#x2F;)&quot; withString:@&quot;)&quot;];    return tempStr;&#125;</code></pre><h1 id="数据库的封装"><a href="#数据库的封装" class="headerlink" title="数据库的封装"></a>数据库的封装</h1><p><img src="https://i.loli.net/2020/05/18/MyLpRig83CkEv97.png" srcset="/img/loading.gif" alt="image-20200518155431105"></p><p><a href="https://pan.baidu.com/s/1aXkiPCs3ze4bdsbl6Qn2VA" target="_blank" rel="noopener">完整DEMO</a></p>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS脚本打包一学就会</title>
    <link href="/2020/05/14/iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E4%B8%80%E5%AD%A6%E5%B0%B1%E4%BC%9A/"/>
    <url>/2020/05/14/iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E4%B8%80%E5%AD%A6%E5%B0%B1%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>上篇文章提到的Jenkins打包，因为需要配置参数比较多，并且坑也比较多，要运行起来确实比较不容易，本人虽然是很早就有接触到Jenkins，但由于一直配置不成功，而放弃了。所以在此之前另寻路径，学了其他比较简单的自动化打包方式，比如Python和接下来要讲的shell脚本。</p><p>条条道路通罗马，不管哪种方式，能提高效率和解放双手的都可以。自动打包确实会比手动打包的快，操作简单，一句代码就解决。</p><p>这种方式对于小项目，比如我现在的公司来说，是够用得了，只有一个iOS开发人员，项目配置也比较简单，所以够用了。</p><p><strong>备注</strong>：使用前提==Xcode证书配置使用<code>自动获取</code>（Automatically manager signing）的方式,并且项目运行正常</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h4 id="第一步：下载脚本文件夹"><a href="#第一步：下载脚本文件夹" class="headerlink" title="第一步：下载脚本文件夹"></a>第一步：下载脚本文件夹</h4><p>链接:<a href="https://pan.baidu.com/s/1Sj19uzzzKu7TJdXMJ6smZw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Sj19uzzzKu7TJdXMJ6smZw</a>  密码:9buq</p><p>下载完成后，将文件夹拉到项目根目录中</p><p><img src="https://i.loli.net/2020/05/18/VxHuq5r7ikIE3OF.png" srcset="/img/loading.gif" alt="image-20200518103113243"></p><h4 id="第二步：配置脚本文件"><a href="#第二步：配置脚本文件" class="headerlink" title="第二步：配置脚本文件"></a>第二步：配置脚本文件</h4><p>（1）修改<code>debug_config.plist</code>文件</p><p><img src="https://i.loli.net/2020/05/18/tkrRLco8DHdjOIK.png" srcset="/img/loading.gif" alt="image-20200518101737159"></p><p>（2）修改<code>test.sh</code>文件配置</p><p>只需要修改头部几个变量的值，备注已注明</p><p><img src="https://i.loli.net/2020/05/18/caUnCg9yLwtKufA.png" srcset="/img/loading.gif" alt="image-20200518101916357"></p><h4 id="第三步：运行脚本"><a href="#第三步：运行脚本" class="headerlink" title="第三步：运行脚本"></a>第三步：运行脚本</h4><p>cd 项目目录下的debug文件夹</p><p>终端输入</p><pre><code class="hljs plain">bash -l test.sh</code></pre><h4 id="第四步：安静的等待脚本执行完成即可"><a href="#第四步：安静的等待脚本执行完成即可" class="headerlink" title="第四步：安静的等待脚本执行完成即可"></a>第四步：安静的等待脚本执行完成即可</h4><p><img src="https://i.loli.net/2020/05/18/Z62PQYgifw5HkB7.png" srcset="/img/loading.gif" alt="image-20200518102152874"></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins自动打包--从零开始</title>
    <link href="/2020/05/14/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85-Jenkins/"/>
    <url>/2020/05/14/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85-Jenkins/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Jenkins是基于Java开发的一种持续集成工具，支持自动化、部署、构建。</p><p>简而言之，对于开发者可以避免做重复并且耗时的事情，专注于代码的开发(测试的小姐姐就不用每次跟我要安装包)</p><p>篇幅较长，请耐心看完，本人亲测有效。</p><p>写文不容易，翻阅了多篇博客，构建失败将近50次，总结的文章，除了文字描述，也附上图片说明，方便阅读。</p><p>如果喜欢本文的，请打赏一分支持</p><h1 id="二、Jenkins安装"><a href="#二、Jenkins安装" class="headerlink" title="二、Jenkins安装"></a>二、Jenkins安装</h1><h4 id="2-0-java-SDK-安装"><a href="#2-0-java-SDK-安装" class="headerlink" title="2.0 java SDK 安装"></a>2.0 java SDK 安装</h4><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">下载地址</a>,双击完成安装</p><h4 id="2-1-安装方式："><a href="#2-1-安装方式：" class="headerlink" title="2.1 安装方式："></a>2.1 安装方式：</h4><p>(1)<a href="https://www.jenkins.io/zh/download/" target="_blank" rel="noopener">官网</a>下载最新版的Jenkins安装包pkg（<a href="">其他版本下载地址</a>）</p><p>双击安装包，按指导完成安装</p><p>(2)Homebrew工具下载</p><pre><code class="hljs plain">brew install jenkins</code></pre><h4 id="2-2-安装结束后，终端输入命令："><a href="#2-2-安装结束后，终端输入命令：" class="headerlink" title="2.2 安装结束后，终端输入命令："></a>2.2 安装结束后，终端输入命令：</h4><pre><code class="hljs plain">jenkins</code></pre><p>启动服务完毕后，在浏览器中打开<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><h4 id="2-3-根据提示路径打开initialAdminPassword文件，复制密码登录"><a href="#2-3-根据提示路径打开initialAdminPassword文件，复制密码登录" class="headerlink" title="2.3 根据提示路径打开initialAdminPassword文件，复制密码登录"></a>2.3 根据提示路径打开initialAdminPassword文件，复制密码登录</h4><p><img src="https://i.loli.net/2020/05/14/epd8L24Eho5QTY6.png" srcset="/img/loading.gif" alt="image-20200514175313623"></p><p>（PS：如果因为权限问题打不开initialAdminPassword文件，请先跳转目录第三：修复jenkins文件权限后再操作）</p><h4 id="2-4-安装推荐插件"><a href="#2-4-安装推荐插件" class="headerlink" title="2.4 安装推荐插件"></a>2.4 安装推荐插件</h4><p>备注：插件安装不一定会一次性全都安装成功，如果失败了，可以点击重试，如果重试还是有没安装成功的，则选择跳过，继续执行下一步，完成Jenkins的安装，因为插件可以在后续继续完成</p><p>(备注：如果Jenkins插件多次在线安装失败，可以先下载<a href="https://updates.jenkins-ci.org/download/plugins/" target="_blank" rel="noopener">插件</a>,下载成功后，在插件管理界面选择【高级】上传的方式安装)</p><p><img src="https://i.loli.net/2020/05/14/pW5wqIvCajTPlgR.png" srcset="/img/loading.gif" alt="image-20200514175232751"></p><p><img src="https://i.loli.net/2020/05/14/vtQ2SFZsNeVx1Kj.png" srcset="/img/loading.gif" alt="image-20200514175258436"></p><h4 id="2-5-设置管理账号"><a href="#2-5-设置管理账号" class="headerlink" title="2.5 设置管理账号"></a>2.5 设置管理账号</h4><p><img src="https://i.loli.net/2020/05/14/Y7lsWZN8Ldvkbae.png" srcset="/img/loading.gif" alt="image-20200514184912707"></p><h4 id="2-6-输入管理账号登录"><a href="#2-6-输入管理账号登录" class="headerlink" title="2.6 输入管理账号登录"></a>2.6 输入管理账号登录</h4><p><img src="https://i.loli.net/2020/05/15/eAvEiq63pkdagXu.png" srcset="/img/loading.gif" alt="image-20200515094050171"></p><h1 id="三、修改Jenkins文件访问权限"><a href="#三、修改Jenkins文件访问权限" class="headerlink" title="三、修改Jenkins文件访问权限"></a>三、修改Jenkins文件访问权限</h1><p>这一步很关键，会影响接下来操作出现莫名的失败，比如证书的配置、代码的拉取等</p><p>首先，安装好Jenkins之后，会默认在Mac登录用户系统中添加一个“Jenkins”的登陆用户，而在Jenkins的主目录文件夹及其子文件夹的访问权限都是只有Mac Jenkins登录用户能读写</p><p><img src="https://i.loli.net/2020/05/15/9J6pEIYFazLysc5.png" srcset="/img/loading.gif" alt="image-20200515101951144"></p><p>（1）停止Jenkins</p><pre><code class="hljs plain">sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p>（2）打开Jenkins配置文件</p><pre><code class="hljs plain">sudo vim &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p><img src="https://i.loli.net/2020/05/15/AQOZ19vUD86zcxI.png" srcset="/img/loading.gif" alt="image-20200515162016570"></p><p><img src="https://i.loli.net/2020/05/15/Q7oHyfUvtWAgmuX.png" srcset="/img/loading.gif" alt="image-20200515162124239"></p><p>（3）运行以下命令，使配置修改生效</p><pre><code class="hljs plain">sudo chown -R yyk:daemon &#x2F;Users&#x2F;Shared&#x2F;Jenkins&#x2F;sudo chown -R yyk:daemon &#x2F;var&#x2F;log&#x2F;jenkins&#x2F;</code></pre><p>（4）启动Jenkins，完成权限修改</p><pre><code class="hljs plain">sudo launchctl load &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p><img src="https://i.loli.net/2020/05/15/uLb8qFNJ215wo4g.png" srcset="/img/loading.gif" alt="image-20200515163217384"></p><h1 id="四、插件安装及配置"><a href="#四、插件安装及配置" class="headerlink" title="四、插件安装及配置"></a>四、插件安装及配置</h1><h4 id="4-0-打开管理界面"><a href="#4-0-打开管理界面" class="headerlink" title="4.0 打开管理界面"></a>4.0 打开管理界面</h4><p><img src="https://i.loli.net/2020/05/15/ILy63UZTptOeD5i.png" srcset="/img/loading.gif" alt="image-20200515094540316"></p><h4 id="4-1-打开插件管理"><a href="#4-1-打开插件管理" class="headerlink" title="4.1 打开插件管理"></a>4.1 打开插件管理</h4><p><img src="https://i.loli.net/2020/05/15/ulNab1tfmWABZG4.png" srcset="/img/loading.gif" alt="image-20200515094621266"></p><h4 id="4-2-安装插件"><a href="#4-2-安装插件" class="headerlink" title="4.2 安装插件"></a>4.2 安装插件</h4><p>有三个插件是必须额外安装：</p><p>(1) 代码管理插件Git</p><p>​    本人用的是码云Gitee管理代码，所以需要安装一个gitee插件</p><p>(2) 代码打包使用：XCode 插件</p><p>(3) 钥匙串及证书管理工具： Keychain and Provisioning Profiles Management</p><p><img src="https://i.loli.net/2020/05/15/RpCiXuOqMPJDeTZ.png" srcset="/img/loading.gif" alt="image-20200515095036236"></p><p><img src="https://i.loli.net/2020/05/15/k3xP6uAYOyNDdVS.png" srcset="/img/loading.gif" alt="image-20200515100234175"></p><p><img src="https://i.loli.net/2020/05/15/M7OJhuKa4Rvjtfc.png" srcset="/img/loading.gif" alt="image-20200515103305563"></p><h4 id="4-3-插件配置"><a href="#4-3-插件配置" class="headerlink" title="4.3 插件配置"></a>4.3 插件配置</h4><p><img src="https://i.loli.net/2020/05/15/Rq6mtnB7YTkgiCp.png" srcset="/img/loading.gif" alt="image-20200515112009897"></p><p>(1) 上传keychains 文件</p><p>keychains文件存放路径：<code>~/Library/Keychains</code></p><p><img src="https://i.loli.net/2020/05/15/IJ3LPUnbX9wQv6d.png" srcset="/img/loading.gif" alt="image-20200515112322044"></p><p>（2）Provisioning Profiles Directory Path 路径</p><p><code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code></p><p>（3）上传配置文件：Provisioning Profile</p><p>如果没有了，则登录<a href="https://developer.apple.com" target="_blank" rel="noopener">苹果开发网址</a>重新生成，只需要开发证书和生产证书</p><p>（4）配置完成的界面</p><p>备注：需要校验上传的开发证书和测试证书对应的UUID，在<code>Provisioning Profiles Directory Path</code>文件夹中是否存在，如果不存在也是会出现本文提到的<code>问题二</code></p><p><img src="https://i.loli.net/2020/05/15/Tg1JiLMfS89hHRA.png" srcset="/img/loading.gif" alt="image-20200515113355974"></p><p><strong>PS：如果项目是有用CocoPods，则需要修改系统配置</strong></p><p>终端输入</p><pre><code class="hljs plain">echo $PATH</code></pre><p>复制输出内容</p><p><img src="https://i.loli.net/2020/05/15/T2Eh6g7aGuLlXdv.png" srcset="/img/loading.gif" alt="image-20200515135717113"></p><p><img src="https://i.loli.net/2020/05/15/U5Cg1dVPOonDjy4.png" srcset="/img/loading.gif" alt="image-20200515135849747"></p><h1 id="五、新建任务"><a href="#五、新建任务" class="headerlink" title="五、新建任务"></a>五、新建任务</h1><h4 id="5-0-创建自由风格工程"><a href="#5-0-创建自由风格工程" class="headerlink" title="5.0 创建自由风格工程"></a>5.0 创建自由风格工程</h4><p><img src="https://i.loli.net/2020/05/15/cDEXgAT4PhemkR9.png" srcset="/img/loading.gif" alt="image-20200515114306575"></p><p><img src="https://i.loli.net/2020/05/15/Dh5uYBUHFQG6stV.png" srcset="/img/loading.gif" alt="image-20200515114411371"></p><h4 id="5-1-General-项配置"><a href="#5-1-General-项配置" class="headerlink" title="5.1 General 项配置"></a>5.1 General 项配置</h4><p><img src="https://i.loli.net/2020/05/15/RlpH5QLohaMeDjV.png" srcset="/img/loading.gif" alt="image-20200515114722913"></p><h4 id="5-2-源码管理"><a href="#5-2-源码管理" class="headerlink" title="5.2 源码管理"></a>5.2 源码管理</h4><p><img src="https://i.loli.net/2020/05/15/ayDpQMf4BiqUCAe.png" srcset="/img/loading.gif" alt="image-20200515115320879"></p><p>PS: ssh密钥生成命令</p><pre><code class="hljs plain">$ cat ~&#x2F;.ssh&#x2F;id_rsa</code></pre><p>复制密钥时一定要将<code>-----BEGIN RSA PRIVATE KEY-----</code>和<code>-----END RSA PRIVATE KEY-----</code>一起复制</p><p><img src="https://i.loli.net/2020/05/15/xgoGJylOtUDTFdu.png" srcset="/img/loading.gif" alt="image-20200515120011740"></p><p><img src="https://i.loli.net/2020/05/15/U5WoP1DXARaxdv7.png" srcset="/img/loading.gif" alt="image-20200515120347621"></p><p><img src="https://i.loli.net/2020/05/15/QgiTUVtj3qGExvB.png" srcset="/img/loading.gif" alt="image-20200515115446447"></p><h4 id="5-3-构建配置"><a href="#5-3-构建配置" class="headerlink" title="5.3 构建配置"></a>5.3 构建配置</h4><p>（1）添加<code>Execute shell</code> 和<code>Xcode</code></p><p><img src="https://i.loli.net/2020/05/15/V18cEzLuJkiOx2N.png" srcset="/img/loading.gif" alt="image-20200515120627317"></p><p>（2）添加shell代码</p><pre><code class="hljs plain">export LANG&#x3D;en_US.UTF-8export LANGUAGE&#x3D;en_US.UTF-8export LC_ALL&#x3D;en_US.UTF-8pod install</code></pre><p><img src="https://i.loli.net/2020/05/15/GeUxkSYn5Z8NyaV.png" srcset="/img/loading.gif" alt="image-20200515121053406"></p><p>（3）Xcode 设置</p><p><img src="https://i.loli.net/2020/05/15/FIVhd28qNHkPivS.png" srcset="/img/loading.gif" alt="image-20200515121332662"></p><blockquote><p>teamid 可以在钥匙串中找到对应的证书，其双括号内的字符串就是teamId</p><p><img src="https://i.loli.net/2020/05/15/xPdnr3DSUIobvCZ.png" srcset="/img/loading.gif" alt="image-20200515121248304"></p></blockquote><p><img src="https://i.loli.net/2020/05/15/QuqzBp1A4UgPWro.png" srcset="/img/loading.gif" alt="image-20200515122523325"></p><p><img src="https://i.loli.net/2020/05/15/5C2NReYgkyFoLmA.png" srcset="/img/loading.gif" alt="image-20200515122300749"></p><h4 id="5-4-Code-signing-amp-OS-X-keychain-options-配置"><a href="#5-4-Code-signing-amp-OS-X-keychain-options-配置" class="headerlink" title="5.4 Code signing &amp; OS X keychain options 配置"></a>5.4 Code signing &amp; OS X keychain options 配置</h4><p><img src="https://i.loli.net/2020/05/15/9LlGQPmUWynzZhg.png" srcset="/img/loading.gif" alt="image-20200515122958510"></p><h4 id="5-5-Advanced-Xcode-build-options-配置"><a href="#5-5-Advanced-Xcode-build-options-配置" class="headerlink" title="5.5 Advanced Xcode build options 配置"></a>5.5 Advanced Xcode build options 配置</h4><p><img src="https://i.loli.net/2020/05/15/eT2gsG1YRPNfV5X.png" srcset="/img/loading.gif" alt="image-20200515133436256"></p><h1 id="六、可能会遇到的问题"><a href="#六、可能会遇到的问题" class="headerlink" title="六、可能会遇到的问题"></a>六、可能会遇到的问题</h1><blockquote><p>问题一：FATAL:Failed to copy ….mobileprovision文件</p><p><img src="https://i.loli.net/2020/05/14/SGyoWFXNt48hPa7.png" srcset="/img/loading.gif" alt="image-20200514140913355"></p><p>解决方法</p><p><img src="https://i.loli.net/2020/05/14/AwOIsMch4iPfjoT.png" srcset="/img/loading.gif" alt="image-20200514141426735"></p><p><img src="https://i.loli.net/2020/05/14/OQo4XysuDTCNqWY.png" srcset="/img/loading.gif" alt="image-20200514141708063"></p></blockquote><blockquote><p>问题二：Execute Shell 脚本代码中的 Pod install 执行错误</p><p><img src="https://i.loli.net/2020/05/14/uULrbqH21W9tPB7.png" srcset="/img/loading.gif" alt="image-20200514141832527"></p><p>解决方法：</p><p>终端输入 echo $PATH</p><p>将输入的PATH值复制，然后到Jenkins的系统管理设置</p><p><img src="https://i.loli.net/2020/05/14/xrASPOGgeLVo6w8.png" srcset="/img/loading.gif" alt="image-20200514143727060"></p></blockquote><h1 id="七、待续"><a href="#七、待续" class="headerlink" title="七、待续"></a>七、待续</h1><p>至此我们实现可持续开发的第一步，自动化打包，除此之外还需要配置多个scheme，打出不同环境的安装包</p><p>比如测试妹纸需要一个SIT包，产品经理需要一个SIM包等等，因为我们总不能修改一下代码，提交一下，打一个包，再修改代码再提交再打包，这样的操作依然需要开发人员的配合，增添了不少的成本。</p><p>对此下一篇则会侧重点解决这个问题</p><pre><code class="hljs plain">DEV Development 研发环境SIT System Integrate Test 系统集成测试环境（内测）UAT User Acceptance Test 用户验收测试环境PET Performance Evaluation Test 性能评估测试环境（压测）SIM Simulation 高仿真环境&#x2F;预发布PRD&#x2F;PROD Production 正式&#x2F;生产环境</code></pre><h1 id="八、参考文章"><a href="#八、参考文章" class="headerlink" title="八、参考文章"></a>八、参考文章</h1><p><a href="http://paocai.site/2020/04/27/iOS%20最新Jenkins自动化打包配置完整教程/#&gid=1&pid=13" target="_blank" rel="noopener">iOS 最新Jenkins自动化打包配置完整教程</a></p><p><a href="https://www.jianshu.com/p/70e4335b0bd6" target="_blank" rel="noopener">Jenins自动打包</a></p><p><a href="https://www.jianshu.com/p/04b5fe2e8598" target="_blank" rel="noopener">Mac修改jenkins进程默认账户解决权限问题</a></p><p><a href="https://www.jianshu.com/p/5be50ee32450" target="_blank" rel="noopener">CocoaPods管理的项目配置Jenkins遇到的坑</a></p><p><a href="https://www.jianshu.com/p/8b2fc2da0466" target="_blank" rel="noopener">使用 Jenkins 持续集成 iOS 项目时碰到的一些问题</a></p><p><a href="https://www.jianshu.com/p/13e34671788f" target="_blank" rel="noopener">iOS使用Jenkins+Xcode+fir 搭建持续集成环境</a></p><p><a href="https://www.jietusoft.com/faq/detail/262.html" target="_blank" rel="noopener">苹果证书的介绍和申请教程</a></p><center class="half"> <div>感谢你“一分”支持</div>   <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Github 搭建博客完整版</title>
    <link href="/2020/04/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/04/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Hexo搭建"><a href="#一、Hexo搭建" class="headerlink" title="一、Hexo搭建"></a>一、Hexo搭建</h2><h3 id="1-0-环境准备-具体的参考百度文章"><a href="#1-0-环境准备-具体的参考百度文章" class="headerlink" title="1.0 环境准备(具体的参考百度文章)"></a>1.0 环境准备(具体的参考百度文章)</h3><p>a&gt; npm安装</p><p>b&gt; Git 安装</p><p>c&gt; node.js 安装（建议安装10.0以上版本）</p><h3 id="2-0-Hexo安装"><a href="#2-0-Hexo安装" class="headerlink" title="2.0 Hexo安装"></a>2.0 Hexo安装</h3><pre><code class="hljs plain">$ npm install -g hexo-cli</code></pre><p>可以输入hexo -v ，检查hexo是否安装成功</p><h3 id="3-0-搭建网站"><a href="#3-0-搭建网站" class="headerlink" title="3.0 搭建网站"></a>3.0 搭建网站</h3><h5 id="3-1-创建一个文件夹存放网站文件，比如在桌面中添加一个-Blog-文件夹"><a href="#3-1-创建一个文件夹存放网站文件，比如在桌面中添加一个-Blog-文件夹" class="headerlink" title="3.1 创建一个文件夹存放网站文件，比如在桌面中添加一个 Blog 文件夹"></a>3.1 创建一个文件夹存放网站文件，比如在桌面中添加一个 Blog 文件夹</h5><h5 id="3-2-初始化Blog文件夹（上个厕所再回来…）"><a href="#3-2-初始化Blog文件夹（上个厕所再回来…）" class="headerlink" title="3.2 初始化Blog文件夹（上个厕所再回来…）"></a>3.2 初始化Blog文件夹（上个厕所再回来…）</h5><pre><code class="hljs plain">hexo init</code></pre><p><img src="https://i.loli.net/2020/05/09/ABecuswPyQEt6kT.png" srcset="/img/loading.gif" alt="image-20200509150624387"></p><h5 id="3-3-安装所需要安装的组件"><a href="#3-3-安装所需要安装的组件" class="headerlink" title="3.3 安装所需要安装的组件"></a>3.3 安装所需要安装的组件</h5><pre><code class="hljs plain">npm install</code></pre><h5 id="3-4-生成静态文件"><a href="#3-4-生成静态文件" class="headerlink" title="3.4 生成静态文件"></a>3.4 生成静态文件</h5><pre><code class="hljs plain">hexo g</code></pre><h5 id="3-5-开启服务器，访问本地网址，体验hexo"><a href="#3-5-开启服务器，访问本地网址，体验hexo" class="headerlink" title="3.5 开启服务器，访问本地网址，体验hexo"></a>3.5 开启服务器，访问<a href="http://localhost:4000" target="_blank" rel="noopener">本地网址</a>，体验hexo</h5><pre><code class="hljs plain">hexo s</code></pre><p>这是一个激动人心的时刻，请高举92年的可乐，一起土嗨！！！！</p><p><img src="https://i.loli.net/2020/05/09/81OLJZCFreMfQ7R.png" srcset="/img/loading.gif" alt="image-20200509151727917"></p><p><em>提示：</em>如果界面无法跳转，可能是端口号被占用了，终端输入<code>ctrl + c</code> 停止服务器，接着输入 <code>hexo server -p 端口号</code> 来修改端口号</p><p><em>扩展：</em>Mac查看端口号是否被占用及释放</p><pre><code class="hljs plain">&#x2F;&#x2F; 查看使用端口号进程lsof -i:端口号&#x2F;&#x2F; 释放端口号kill 进程的PID&#x2F;&#x2F; 再次执行，查看无进程占用lsof -i:端口号</code></pre><h5 id="3-6-关联Github"><a href="#3-6-关联Github" class="headerlink" title="3.6 关联Github"></a>3.6 关联Github</h5><p>登录Github,创建库，比如本人的CallLiven.github.io，并复制https地址</p><p>（注意点是github.io的前缀一定要跟github的名称一致，否则登录网址会提示404错误，找不到对应的文件）</p><p><img src="https://i.loli.net/2020/05/09/8ErvzakRN6dsw1l.png" srcset="/img/loading.gif" alt="image-20200509152540582"></p><p>打开之前创建的<code>Blog</code>文件夹，打开<code>_config.yml</code>文件，在文件最底部编写以下内容</p><pre><code class="hljs plain"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy:  type: git  repo:  &lt;仓库地址&gt;  branch: master</code></pre><p>安装插件Git bash 将文章推到仓库</p><pre><code class="hljs plain">npm install hexo-deloper-git --save</code></pre><p>部署到远端服务器Github</p><pre><code class="hljs plain">hexo g (生成静态文件)hexo d （将本地数据部署到远端服务器）</code></pre><p>恭喜，已经成功了</p><p>浏览器直接打开：<a href="https://callliven.github.io" target="_blank" rel="noopener">https://callliven.github.io</a></p><h3 id="4-0-创建博客"><a href="#4-0-创建博客" class="headerlink" title="4.0 创建博客"></a>4.0 创建博客</h3><pre><code class="hljs plain">hexo new 文件标题</code></pre><p><img src="https://i.loli.net/2020/05/09/1oapDuFHGPSfRgB.png" srcset="/img/loading.gif" alt="image-20200509155650478"></p><p>根据路径打开md文件，开始编辑文章，比如大海啊大海，海大啊海大</p><h2 id="二、编辑博客推荐工具：Typora-下载地址"><a href="#二、编辑博客推荐工具：Typora-下载地址" class="headerlink" title="二、编辑博客推荐工具：Typora 下载地址"></a>二、编辑博客推荐工具：Typora <a href="https://www.typora.io" target="_blank" rel="noopener">下载地址</a></h2><p>PS：一定要安装最新版本的，因为最新版本的支持图床设置，也就是将拖拽的图片自动上传到设置好的服务上</p><p>(1) 上传工具：PicGo 下载地址</p><p>(2) 图床选择：SM.MS （特点：永久存储免费，图片链接支持https，可以删除上传的图片，但图片上传有限制：每张图片最大5M，每次最多上传10张）</p><h3 id="1-SM-MS注册"><a href="#1-SM-MS注册" class="headerlink" title="1.SM.MS注册"></a>1.SM.MS注册</h3><p><a href="https://sm.ms/login" target="_blank" rel="noopener">https://sm.ms/login</a></p><h3 id="2-生成token"><a href="#2-生成token" class="headerlink" title="2.生成token"></a>2.生成token</h3><p><a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">https://sm.ms/home/apitoken</a></p><h3 id="3-配置PicGo的SM-MS图床服务"><a href="#3-配置PicGo的SM-MS图床服务" class="headerlink" title="3.配置PicGo的SM.MS图床服务"></a>3.配置PicGo的SM.MS图床服务</h3><p>文件路径：~/.picgo/config.json</p><pre><code class="hljs plain">&#123;  &quot;picBed&quot;: &#123;    &quot;uploader&quot;: &quot;smms&quot;, &#x2F;&#x2F; 代表当前的默认上传图床为 SM.MS,    &quot;smms&quot;: &#123;      &quot;token&quot;: &quot;&quot; &#x2F;&#x2F; 从https:&#x2F;&#x2F;sm.ms&#x2F;home&#x2F;apitoken获取的token    &#125;  &#125;,  &quot;picgoPlugins&quot;: &#123;&#125; &#x2F;&#x2F; 为插件预留&#125;</code></pre><h3 id="4-修改Typora配置"><a href="#4-修改Typora配置" class="headerlink" title="4.修改Typora配置"></a>4.修改Typora配置</h3><p>偏好设置–&gt;图像</p><p><img src="https://i.loli.net/2020/05/08/9nfTSi5F47jcVoE.png" srcset="/img/loading.gif" alt="image-20200508175202269"></p><h3 id="5-编辑文章"><a href="#5-编辑文章" class="headerlink" title="5.编辑文章"></a>5.编辑文章</h3><p>完成以上操作就可以开始编辑文章，方式跟简书等博客是一样的</p><h2 id="三、更换主题"><a href="#三、更换主题" class="headerlink" title="三、更换主题"></a>三、更换主题</h2><p>我当前使用的主题是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid</a>,安装方法请参考界面所介绍的。(<a href="https://hexo.io/themes/" target="_blank" rel="noopener">更多主题选择</a>)</p><p>Fluid主题预览（风格简易大气，并且支持文章搜索、标签、分类、评论等等）</p><ol><li><p>下载主题包</p></li><li><p>将主题解压，并重命名为“fluid”</p></li><li><p>将主题包拖动“Blog”文件夹中的“themes”</p></li></ol><p><img src="https://i.loli.net/2020/05/09/zEn3GPj4gxXVWRw.png" srcset="/img/loading.gif" alt="image-20200509161029217"></p><ol start="4"><li>最后一步，修改hexo主题配置</li></ol><p><img src="https://i.loli.net/2020/05/09/vY6ZAIPQiGqMag7.png" srcset="/img/loading.gif" alt="image-20200509161241944"></p><h2 id="四、个性化功能-非必须的"><a href="#四、个性化功能-非必须的" class="headerlink" title="四、个性化功能(非必须的)"></a>四、个性化功能(非必须的)</h2><p>该主题支持的个性化功能，具体的都在<code>_config.yml</code>文件中都有教程，操作非常简单，此处只介绍添加评论和音乐的方法</p><h3 id="1-添加评论"><a href="#1-添加评论" class="headerlink" title="1. 添加评论"></a>1. 添加评论</h3><p>Fluid主题支持多种评论插件，此处选择<code>Valine</code>，因为我刚好有<a href="https://leancloud.cn" target="_blank" rel="noopener">Leancloud</a>账号，并且Valine不需要提供多种资料，比较简单</p><p><img src="https://i.loli.net/2020/05/11/PsGnZXDcqeTL2Ni.png" srcset="/img/loading.gif" alt="image-20200511151845391"></p><p><img src="https://i.loli.net/2020/05/11/1Zoes23wUP9gupr.png" srcset="/img/loading.gif" alt="image-20200511151734203"></p><h3 id="2-播放音乐"><a href="#2-播放音乐" class="headerlink" title="2. 播放音乐"></a>2. 播放音乐</h3><p>安装音乐播放器插件: <a href="https://aplayer.js.org" target="_blank" rel="noopener">音乐播放插件APlayer</a></p><pre><code class="hljs plain">cd 博客文件夹npm install aplayer --save</code></pre><p>修改配置文件 <code>_config.yml</code> (需要将mp3文件拉到博客文件夹中)</p><p><img src="https://i.loli.net/2020/05/11/QVRrAqEi8FyOkJw.png" srcset="/img/loading.gif" alt="image-20200511151228772"></p><h3 id="3-统计百度统计"><a href="#3-统计百度统计" class="headerlink" title="3.统计百度统计"></a>3.统计百度统计</h3><p>注册百度统计账号:<a href="https://tongji.baidu.com/sc-web/10000203072/home/site/index?from=3" target="_blank" rel="noopener">网址</a></p><p><img src="https://i.loli.net/2020/05/11/dEcX2NUipmMIlJz.png" srcset="/img/loading.gif" alt="image-20200511200825592"></p><p><img src="https://i.loli.net/2020/05/11/noBJX8NObVx12GU.png" srcset="/img/loading.gif" alt="image-20200511200840983"></p><p><img src="https://i.loli.net/2020/05/11/dBKwlPy2Le36DY5.png" srcset="/img/loading.gif" alt="image-20200511201033923"></p><p><img src="https://i.loli.net/2020/05/11/WEZuYoTLrkmgMSn.png" srcset="/img/loading.gif" alt="image-20200511201111996"></p><p>编辑根目录Blog下的<code>_config.yml</code>文件</p><p><img src="https://i.loli.net/2020/05/11/6kvT37Ne1ayjDSQ.png" srcset="/img/loading.gif" alt="image-20200511201330541"></p><p>重新生成静态文件及部署到github上，就可以了（每次修改内容，都需要重新生成静态文件，再部署git上）</p><pre><code class="hljs plain">hexo ghexo d</code></pre><p><img src="https://i.loli.net/2020/05/11/9fjyTMAwRBiuUZ6.png" srcset="/img/loading.gif" alt="image-20200511201511851"></p><h2 id="五、Typora-常用快捷键"><a href="#五、Typora-常用快捷键" class="headerlink" title="五、Typora 常用快捷键"></a>五、Typora 常用快捷键</h2><pre><code class="hljs plain">无序列表：输入-之后输入空格有序列表：输入数字+“.”之后输入空格任务列表：-[空格]空格 文字标题：ctrl+数字表格：ctrl+t生成目录：[TOC]按回车选中一整行：ctrl+l选中单词：ctrl+d选中相同格式的文字：ctrl+e跳转到文章开头：ctrl+home跳转到文章结尾：ctrl+end搜索：ctrl+f替换：ctrl+h引用：输入&gt;之后输入空格代码块：ctrl+alt+f加粗：ctrl+b倾斜：ctrl+i下划线：ctrl+u删除线：alt+shift+5插入图片：直接拖动到指定位置即可或者ctrl+shift+i插入链接：ctrl+k</code></pre><h2 id="六、参考文章："><a href="#六、参考文章：" class="headerlink" title="六、参考文章："></a>六、参考文章：</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><p><a href="https://doc.sm.ms/" target="_blank" rel="noopener">SM.MS API 文档</a></p><p><a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#默认配置文件" target="_blank" rel="noopener">PinGo-Core官方文档</a></p><p><a href="https://www.jianshu.com/p/7b8faf77d1af" target="_blank" rel="noopener">Hexo常用指令</a></p><p><a href="https://aplayer.js.org" target="_blank" rel="noopener">音乐播放插件APlayer</a></p><p><a href="https://leancloud.cn" target="_blank" rel="noopener">Leancloud第三方服务器</a></p><center class="half"> <div>感谢你“一分”支持</div>   <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
