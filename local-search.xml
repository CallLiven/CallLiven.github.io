<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MVVM探讨</title>
    <link href="/2020/08/04/MVVM%E6%8E%A2%E8%AE%A8/"/>
    <url>/2020/08/04/MVVM%E6%8E%A2%E8%AE%A8/</url>
    
    <content type="html"><![CDATA[<p>MVVM 是为了解决MassiveViewController而从MVC变形出来的，更直白点就是将MVC中C处理的部分抽一些出来交给VM处理。</p><p>Casa<a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="noopener">文章</a></p><p>Model才进行数据处理，ViewModel不做数据处理。数据处理涉及的范围是数据的增删改查，这些都应该是Model去做。</p><p>例如Model做的事情是：从网络获得数据，从数据库获得数据，从设备传感器获得数据，从文件获得数据。包括将这些数据转化成View层（也可以更笼统地说它就是业务层）可以理解的方式：JSON、对象、UIView、字典等</p><p>VM只做数据转化这种级别的处理，这种处理极为有限。至于数据的增删改查，还是M去做。要区分VM和M，关键就在于区分数据转化和数据的增删改查</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collect,架构及设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构与设计模式随笔</title>
    <link href="/2020/07/30/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9A%8F%E7%AC%94/"/>
    <url>/2020/07/30/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="重要结论"><a href="#重要结论" class="headerlink" title="重要结论"></a>重要结论</h1><h3 id="【继承】"><a href="#【继承】" class="headerlink" title="【继承】"></a>【继承】</h3><p><strong>Case</strong><a href="https://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="noopener">跳出面向对象思想(一) 继承</a>文中提到继承是代码复用的一种方案，但是继承同时也是紧耦合的一种模式，体现在其一发动全身，尽量避免使用继承，可以使用组合设计模式代替，除非继承成为一种需求，那么就可以使用继承。</p><p><strong>使用继承的三大要点：</strong></p><ul><li>父类只给子类提供服务，并不涉及子类的业务逻辑</li><li>层级关系明显，功能划分清晰，父类和子类各做各的</li><li>父类的所有变化，都需要在子类中体现，也就是说此时耦合已成为需求</li></ul><h1 id="六大基本设计原则"><a href="#六大基本设计原则" class="headerlink" title="六大基本设计原则"></a>六大基本设计原则</h1><h3 id="（1）单一职责（Single-Responsibility-Principle）–-SRP"><a href="#（1）单一职责（Single-Responsibility-Principle）–-SRP" class="headerlink" title="（1）单一职责（Single Responsibility Principle）– SRP"></a>（1）单一职责（Single Responsibility Principle）– SRP</h3><blockquote><p>就一个类而言，应该仅有一个引起它变化的原因。</p><p>也就是一个类值负责一个职责的工作</p></blockquote><p><strong>A：</strong>一个类（或者大到模块，小到方法）承担的<code>职责越多</code>，它<code>被复用的可能性越小</code>，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运行；</p><p><strong>B：</strong>类的职责主要包括两个方面：<code>数据职责</code>和<code>行为职责</code>，数据职责通过其属性来提现，而行为职责通过其方法来体现；</p><p><strong>C：</strong>单一职责原则是实现<code>高内聚</code>、<code>低耦合</code>的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验；</p><p><strong>解决问题类型：</strong></p><p>类A负责两个职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类A时，有可能会导致原本运行正常的职责P2功能发生故障。</p><p><strong>解决方案：</strong></p><p>遵循SRP，分别建立两个类A1、A2，使A1完成职责P1，A2完成职责P2。这样，当修改类A1时，不会影响职责A2；同理，当修改A2时，也不会影响到职责P1</p><p><strong>e.g.</strong></p><p><strong>（1）</strong>最好的反例：MassiveViewController。比如写一个简单的应用程序，一般都会生成一个viewcontroller类，于是我们将各种各样的代码，算法、网络、数据库访问等等都放在这个类里面，这就意味着，无论任何需求变化，都需要修改ViewController这个类，这个其实是很糟糕的，维护麻烦，复用不可能、缺乏灵活性等。网上有很多解决的方法：<a href="https://toutiao.io/posts/xxr604/preview" target="_blank" rel="noopener"> 八种模式帮你告别 Massive View Controller</a>，但无论什么方法，都是在提倡优化职责划分，也是SRP的思想。</p><p><strong>（2）</strong>在使用tableView列表时，我们都很自然的将Model传给Cell，然后让Cell解析Model去渲染视图，并且感觉没有什么不妥的，美其曰：Cell的封装。代码如下</p><pre><code class="hljs objc">TestCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="hljs-string">@"TestCell"</span>];<span class="hljs-keyword">if</span> (!cell) &#123;    cell = (TestCell *)[[[<span class="hljs-built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="hljs-string">@"TestCell"</span> owner:<span class="hljs-keyword">self</span> options:<span class="hljs-literal">nil</span>] lastObject];&#125;TestModel *model = <span class="hljs-keyword">self</span>.dataList[indexPath.row];[cell configWithModel:model];</code></pre><p>殊不知这已经违背SRP，<code>Cell的职责是描述与渲染自身，解析Model这个职责不属于Cell</code>，并且Cell中引入Model会增加不必要的依赖，Cell需要根据Model的改变而做出相应的修改，不利于Cell的复用。做过Android开发的同学都知道，其实如何让Model的数据呈现在Cell上是<a href="http://blog.csdn.net/fznpcy/article/details/8658155/" target="_blank" rel="noopener">Adapter</a>需要做的事情。</p><p>关于TableView与适配器如何使用======》》》》》》 请查看本文的<strong>适配器设计模式</strong></p><h3 id="（2）里氏替换原则（Liskov-Substitution-Principle）–-LSP"><a href="#（2）里氏替换原则（Liskov-Substitution-Principle）–-LSP" class="headerlink" title="（2）里氏替换原则（Liskov Substitution Principle）– LSP"></a>（2）里氏替换原则（Liskov Substitution Principle）– LSP</h3><blockquote><p>所有引用父类的地方都必须能够透明地使用其子类对象。</p><p>通俗说法：子类可以扩展父类的功能，但不能改变父类原有的功能，包括以下两点</p><p>a、子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</p><p>b、子类可以增加自己的特有方法</p></blockquote><p>面向对象编程中<code>继承</code>和<code>多态</code>，要遵守里氏替换原则.</p><p>继承在程序设计中带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来入侵，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类继承，则当这个类需要修改时，必须考虑到所有子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障</p><h3 id="（3）迪米特法则（Least-Knowledge-Principle）–LKP"><a href="#（3）迪米特法则（Least-Knowledge-Principle）–LKP" class="headerlink" title="（3）迪米特法则（Least Knowledge Principle）–LKP"></a>（3）迪米特法则（Least Knowledge Principle）–LKP</h3><blockquote><p>最少知识原则：如果两个类不必彼此直接通信，那么这个两个类就不应当发生直接的相互作用；如果其中一个类需要调用另外一个类的某个方法的话，可以通过第三者转发这个调用。</p></blockquote><p>Only talk to your immediate friends（<code>只和离你最近的朋友进行交互</code>）</p><p>什么是最近的朋友？</p><p>每个对象都会与其他对象之间有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。</p><p>耦合的方式有很多，如依赖、关联、组合、聚合等，其中，我们称出现在成员变量、方法参数、方法返回值中的类为最近的朋友，而出现在局部变量中的类则不是最近的朋友。</p><h3 id="（4）依赖倒置（Dependence-Inversion-Principle）–-DIP"><a href="#（4）依赖倒置（Dependence-Inversion-Principle）–-DIP" class="headerlink" title="（4）依赖倒置（Dependence Inversion Principle）– DIP"></a>（4）依赖倒置（Dependence Inversion Principle）– DIP</h3><blockquote><p>高层模块不应该依赖底层模块，二者都应该依赖于抽象 ；</p><p>抽象不应该依赖细节，细节应该依赖抽象；</p></blockquote><p><code>高层是指业务，底层的是指机制</code>；</p><p>比如：文件系统就是一层抽象，上层的文件操作逻辑不依赖具体的文件类型，而只负责数据读写，文件系统负责处理具体不同文件类型的操作；上层的业务细节依赖文件系统的抽象层。</p><p>依赖倒置的核心思想就是<code>面向接口编程</code>。平时说的“针对接口编程”，不要针对实现编程就是依赖倒置的最好提现，接口就是一种抽象，只要不修改接口声明，就可以大单调用，至少接口的内部实现无需关心，可以随便重构。</p><p>这里，<code>接口就是抽象</code>，而<code>接口的是实现就是细节</code>。</p><p><strong>解决问题类型：</strong></p><p>类A直接依赖类B，假如要将类B改为类C，则必须通过修改类A的代码来达成。类A一般是高层模块，负责复杂的业务逻辑。类B和类C是底层模块，负责基本的原子操作。修改类A，会给程序带来不必要的风险。</p><p><strong>解决方案：</strong></p><p>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p><p><strong>解释：</strong></p><p>所谓<code>细节</code>就是较为<code>具体</code>的东西，比如具体的类，就如上面的类B与类C，有具体的实现。</p><p>所有<code>抽象</code>就是具有<code>契约性、共同性、规范性</code>的表达，比如上面的接口I。它表达了一种契约：你需要是实现funcA和funcB才能被当成I来对待。</p><p><code>相对于细节的多变性，抽象的东西要稳定的多</code>。</p><p>以上的类ABC作为例子，B，C类都属于细节，如果A直接依赖B或者C，那么B或者C的改动有可能就会影响到A的稳定性。同样的，A对B或C的操作也有可能影响到B或C的稳定性。这些互相影响，其实来源于直接的依赖，导致B或者C的细节暴露过多，而面对抽象的接口I，A只能操作funcA 和 funcB，从而<code>避免了不必要的暴露和风险</code></p><p><strong><code>以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多</code></strong>。稳定性表现在规范性、契约性、易修改性、扩展性、可维护性等</p><p>注意点：</p><ul><li><p><strong>分清细节与抽象</strong></p><p>虽然依赖倒置原则有很大的好处，但也不是所有的类都需要有抽象一个接口去对应，要视情况而定</p></li><li><p><strong>变量的声明类型尽量是抽象类或接口</strong></p><p>注意是尽量，而不是全部</p></li><li><p><strong>尽量不要覆写基类的方法</strong></p><p>如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响</p></li><li><p><strong>继承要遵循里氏替换原则</strong></p></li></ul><h3 id="（5）接口隔离（Interface-Segregation-Principle）–-ISP"><a href="#（5）接口隔离（Interface-Segregation-Principle）–-ISP" class="headerlink" title="（5）接口隔离（Interface Segregation Principle）– ISP"></a>（5）接口隔离（Interface Segregation Principle）– ISP</h3><blockquote><p>客户端不应该依赖它不需要的接口；</p><p>一个类对另一个类的依赖应该建立在最小的接口上。</p></blockquote><p>接口隔离原则有点像单一职责原则，但是也有区别，在单一职责中，一个接口可能有多个方法，提供给多种不同的调用者所调用，但是它们始终完成同一种功能，因此它们符号单一职责原则，却不符合接口隔离原则，因为这个接口存在着多种角色，因此可以拆分成更多的子接口，以供不同的调用者所调用。</p><p>比如：项目中我们通常有一个web服务管理的类，接口定义中，我们可能会将所有模块的数据调用方法都在接口中进行定义，因为它们都完成的是同一种功能吗：和服务器进行数据交互；但是对于具体的业务功能模块来说，其他模块的数据调用方法从来不会使用，因此不符合接口隔离原则。</p><p><strong>作用：</strong></p><p>设计一个<code>短而小</code>的接口和类，符合高内聚低耦合的设计思想，从而使得类具有良好的可读性、可扩展性和可维护性</p><p><strong>解决问题类型：</strong></p><p>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去是实现他们不需要的方法。</p><p><strong>解决方案：</strong></p><p>将臃肿的接口I拆为独立的几个接口，类A和类C分别于他们需要的接口建立依赖关系。</p><img src="https://i.loli.net/2020/08/03/wX8JPQlDL1jI2zx.png" srcset="/img/loading.gif" alt="image-20200803100228689" style="zoom:50%;" /><p><strong>优点：</strong></p><p>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有依赖它的类去调用。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口要灵活。接口是设计时对外部设定的契约，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><ul><li><p><strong>接口隔离ISP 跟 之前的单一职责原则类似？</strong></p><p>其实不然。单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。<br>其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中实现的细节。而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建</p></li><li><p><strong>是否可用协议的可选实现（@optional）来解决接口隔离的问题？</strong></p><p>其实不然。@optional关注的是可有可无，但这种可有可无不是完全没有作用的。而ISP关注的是完全不需要实现的方法，对于实现类来说完全没有作用的。</p></li></ul><p><strong>注意点：</strong></p><p><code>接口尽量小，但是要有限度</code>。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所有一定要适度。<br>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。<br><code>只专注地为一个模块提供定制服务</code>，才能建立最小的依赖关系。提高内聚，减少对外交互。使接口用最小的方法去完成最多的事情。运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确的实践这一原则</p><h3 id="（6）开闭原则-Open-Closed-Principle-–-OCP"><a href="#（6）开闭原则-Open-Closed-Principle-–-OCP" class="headerlink" title="（6）开闭原则(Open-Closed Principle) – OCP"></a>（6）开闭原则(Open-Closed Principle) – OCP</h3><blockquote><p>Software entities should be open for extension,but closed for modification</p><p>对扩展开发，对修改关闭</p><p>(也就是说对模块的设计，应该满足将来在不可修改源代码的情况下对模块的职能扩展，或者改变模块的行为)</p></blockquote><p>开发-封闭原则的思想就是设计的时候，尽量让设计的类做好后就不再修改，如果有新的需求，通过新加类的方式来满足，而不去修改现有的类（代码）。</p><p>那么在实际的项目开发中，是否能做到绝对的对修改关闭呢？答案一般都是否定的，既然这样，那么就要求我们再开发前，去找出变化点，然后针对变化点构造抽象，隔离出这些变化。由此可见，<code>实现开闭原则关键是抽象</code></p><p><strong>e.g.</strong></p><img src="https://i.loli.net/2020/08/05/ob7gLO2FAc8SiN3.png" srcset="/img/loading.gif" alt="image-20200805155514425" style="zoom:50%;" /><p>MusicPlayer根据不同的音乐类型来进行播放，MusicPlayer的实现</p><pre><code class="hljs objc"><span class="hljs-keyword">class</span> func playMusic(musicType:MusicType) -&gt; () &#123;             <span class="hljs-keyword">switch</span> musicType &#123;        <span class="hljs-keyword">case</span> .Classical:            ClassicalMusic.init().playMusic()        <span class="hljs-keyword">case</span> .Popular:            PopularMusic.init().playMusic()        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>        &#125;    &#125;</code></pre><p>如果后期扩展需要支援摇滚音乐的播放的话，就需要修改MusicPlayer的内部实现。为了满足开闭原则，我们需要进行<code>抽象化设计</code>，可以新增音乐抽象类，具体的音乐作为其子类。播放器这对抽象音乐进行编程，播放哪种类型由客户端来决定。</p><img src="https://i.loli.net/2020/08/05/OoWfLeNmSYdgb6w.png" srcset="/img/loading.gif" alt="image-20200805155837041" style="zoom:50%;" /><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="（1）适配器设计模式"><a href="#（1）适配器设计模式" class="headerlink" title="（1）适配器设计模式"></a>（1）适配器设计模式</h3><blockquote><p>将一个类的接口适配成用户所期待的，一个适配允许通常因为接口不兼容而不能一起工作的类在一起，做法是将类自己的接口包裹在一个已存在的类中。</p></blockquote><p><strong>e.g.</strong></p><p>推荐此<a href="https://www.jianshu.com/p/21595eba795b" target="_blank" rel="noopener">文章实例</a></p><p>文章实例是将原来的AVPlayer播放器替换成ijkPlayer，通过适配器PlayerAdapter实现旧AVPayer对象的接口，并将传入新ijkPlayer对象，对旧接口实现。</p><h3 id="（2）策略设计模式"><a href="#（2）策略设计模式" class="headerlink" title="（2）策略设计模式"></a>（2）策略设计模式</h3><blockquote><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p></blockquote><p>策略模式的使用可以粗暴的分为3个角色</p><ul><li>策略类，或者定义为策略接口、策略协议，它为所有支持或相关的算法声明了一个共同的接口。</li><li>策略对象：它会实现策略协议，策略对象通常存在多个，分别封装实现具体的算法。</li><li>场景(context)类对象：配置有一个具体策略对象的示例，场景对象使用策略接口调用由具体策略类定义的算法。</li></ul><img src="https://i.loli.net/2020/08/05/CjEKeWT5sH8uzqS.png" srcset="/img/loading.gif" alt="image-20200805170338386" style="zoom:50%;" /><p><strong>使用场景：</strong></p><p>在以下情形，考虑使用策略模式</p><ul><li>一个类在其操作中使用多个条件语句来定义许多行为，我们可以把相关的条件分支移动到它们自己的策略类中。</li><li>需要算法的各种变体。</li><li>需要避免把复杂的、与算法相关的数据结构暴露给客户端。</li></ul><h3 id="（3）装饰设计模式"><a href="#（3）装饰设计模式" class="headerlink" title="（3）装饰设计模式"></a>（3）装饰设计模式</h3><blockquote><p>装饰者模式可以动态的给指定的类添加一些行为和职责，而不用对原代码进行任何修改。就扩展功能来说，装饰设计模式相比于生成子类更为灵活。常见的实现方式：Category（类别）和 Delegation（委派）</p></blockquote><img src="https://i.loli.net/2020/08/06/7Fx62n4zSBWp9Ee.png" srcset="/img/loading.gif" alt="image-20200806100610345" style="zoom:50%;" /><p><strong>e.g.</strong></p><p><a href="https://www.jianshu.com/p/f3408f3b548f" target="_blank" rel="noopener">原文</a> 有一个封面，后台返回的字段<code>&quot;pic&quot;: &quot;/image/20160826/d51285bb636281dce6974313eaf6f15d.png&quot;</code>只是一个路径，前面的域名<code>https://xxxxxx-aliyun.firstleap.cn</code>需要我们这边统一拼接，同事我们使用的阿里云存储服务，有对图片处理（包括图片压缩、减少图片分辨率），且iPhone和iPad的处理还不一样。</p><p>我们对String添加一个扩展（OC中为category），File/New/File…，选择Swift File，命名为<code>String + Aliyun</code>，添加以下代码：</p><pre><code class="hljs swift"><span class="hljs-comment">// 判断型号</span><span class="hljs-keyword">let</span> isPad = ( <span class="hljs-type">UI_USER_INTERFACE_IDIOM</span>() == .pad)<span class="hljs-keyword">let</span> fileHost = <span class="hljs-string">"https://xxxxxx-aliyun.firstleap.cn"</span><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">String</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aliyunThumb</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span> &#123;    <span class="hljs-keyword">if</span> isPad &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"\(fileHost)\(self)"</span> + <span class="hljs-string">"!iPadThumb"</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"\(fileHost)\(self)"</span> + <span class="hljs-string">"!thumb"</span>    &#125;  &#125;&#125;</code></pre><p>使用Delegation委托的方式（苹果UIKit中有很多都是代理委托模式，比如UITableView、UIcollectionView、UITextView等等）</p><pre><code class="hljs objc"><span class="hljs-comment">//Mydelegate.h</span><span class="hljs-comment">//可以单独放在一个.h文件,也可以直接放入A.h中</span><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">Mydelegate</span>//协议的声明 中</span>-(<span class="hljs-keyword">void</span>)Fun;<span class="hljs-keyword">@end</span><span class="hljs-comment">//A.h</span><span class="hljs-meta">#import <span class="hljs-meta-string">"Mydelegate.h"</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">A</span>:<span class="hljs-title">NSObject</span> </span>&#123;   <span class="hljs-keyword">id</span>&lt;Mydelegate&gt; delegate;<span class="hljs-comment">//声明一个委托对象，我们要把事情委托给实现Mydelegate协议的类</span>&#125;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">assign</span>,<span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span>&lt;Mydelegate&gt; delegate;<span class="hljs-keyword">@end</span><span class="hljs-comment">//A.m</span><span class="hljs-meta">#import <span class="hljs-meta-string">"A.h"</span></span><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span>-(<span class="hljs-keyword">void</span>)FunToOther &#123;    [delegate Fun];<span class="hljs-comment">//将消息发送给委托去处理</span>&#125;<span class="hljs-keyword">@end</span><span class="hljs-comment">//B.h</span><span class="hljs-meta">#import<span class="hljs-meta-string">"A.h"</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">B</span>:<span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">MyDelegate</span>&gt;</span><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">strong</span>,<span class="hljs-keyword">nonatomic</span>) A *a;<span class="hljs-keyword">@end</span><span class="hljs-comment">//B.m</span><span class="hljs-meta">#import <span class="hljs-meta-string">"B.h"</span></span><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span>-(<span class="hljs-keyword">void</span>)init &#123;  _a = [[A alloc] init];  _a.delegate = <span class="hljs-keyword">self</span>;&#125;<span class="hljs-meta">#prage mark - MyDelegate</span>-(<span class="hljs-keyword">void</span>)fun &#123;    <span class="hljs-comment">//实现Mydelegate中制定的方法</span>&#125;<span class="hljs-keyword">@end</span></code></pre><h3 id="（4）外观模式"><a href="#（4）外观模式" class="headerlink" title="（4）外观模式"></a>（4）外观模式</h3><blockquote><p>外观设计模式为复杂的子系统提供单一的接口，只公开一个简单统一的API，而不是将一组类及其API暴露给用户。</p></blockquote><img src="https://i.loli.net/2020/08/06/65Qu1f9lkGYev4O.png" srcset="/img/loading.gif" alt="image-20200806104229560" style="zoom:50%;" /><p>API的用户完全不知道下面的复杂性。这种模式在使用大量类时非常理想，特别是当它们复杂使用或难以理解时。</p><h3 id="面向接口编程-Interface-Oriented-Programming-–-IOP"><a href="#面向接口编程-Interface-Oriented-Programming-–-IOP" class="headerlink" title="面向接口编程(Interface Oriented Programming) – IOP"></a>面向接口编程(Interface Oriented Programming) – IOP</h3><h3 id="面向切片编程（Aspect-Oriented-Programming）AOP"><a href="#面向切片编程（Aspect-Oriented-Programming）AOP" class="headerlink" title="面向切片编程（Aspect Oriented Programming）AOP"></a>面向切片编程（Aspect Oriented Programming）AOP</h3><blockquote><p>程序要完成一件事情，一定会有一些步骤，1，2，3，4这样。这里分解出来的每一个步骤我们可以认为是一个切片。</p><p>面对切片编程就是针对每一个切片的间隙，塞一些代码进去，在程序正常运行1，2，3，4步的间隙可以跑到你塞进去的代码，那么你写的代码就是面向切片编程</p></blockquote><p>AOP一般都是需要有一个<code>拦截器</code>，然后在每一个切片运行之前和运行之后（或者任何你希望的地方），通过调用拦截器的方法来把这个jointpoint扔到外面，在外面获取这个jointpoint的时候，执行相应的代码。</p><p>可以使用</p><ul><li><p><strong>Method Swizzling</strong>（如第三方的<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a>）</p></li><li><p><strong>protocol</strong></p></li></ul><h3 id="依赖注入-Dependency-Injection-–-DI"><a href="#依赖注入-Dependency-Injection-–-DI" class="headerlink" title="依赖注入(Dependency Injection) – DI"></a>依赖注入(Dependency Injection) – DI</h3><p>参考文献：</p><p><a href="https://toutiao.io/posts/342302/app_preview" target="_blank" rel="noopener">谈谈依赖注入与面向接口编程思想</a></p><p><a href="https://www.jianshu.com/p/1f56168fe5b5" target="_blank" rel="noopener">iOS设计模式的六大设计原则</a></p><p><a href="https://catchzeng.com/2017/02/19/聊聊设计模式原则-一-单一职责原则/" target="_blank" rel="noopener">聊聊设计模式原则-一-单一职责原则</a></p><p><a href="https://catchzeng.com/2018/06/01/聊聊设计模式原则-三-依赖倒置原则/" target="_blank" rel="noopener">聊聊设计模式原则-三-依赖倒置原则</a></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collect,架构及设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter_模块_网络请求封装</title>
    <link href="/2020/07/27/Flutter-%E6%A8%A1%E5%9D%97-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/"/>
    <url>/2020/07/27/Flutter-%E6%A8%A1%E5%9D%97-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter学习资料</title>
    <link href="/2020/07/27/Flutter%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <url>/2020/07/27/Flutter%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h2 id="Dart基础"><a href="#Dart基础" class="headerlink" title="Dart基础"></a>Dart基础</h2><h4 id="Flutter之搞定Dart-一"><a href="#Flutter之搞定Dart-一" class="headerlink" title="Flutter之搞定Dart(一)"></a><a href="https://mp.weixin.qq.com/s/Ygs-sOtrohNf4vGpZcrnYw" target="_blank" rel="noopener">Flutter之搞定Dart(一)</a></h4><h4 id="Flutter之搞定Dart-二"><a href="#Flutter之搞定Dart-二" class="headerlink" title="Flutter之搞定Dart(二)"></a><a href="https://mp.weixin.qq.com/s/xdSYvqSYOXTOCeb89C1uvg" target="_blank" rel="noopener">Flutter之搞定Dart(二)</a></h4><h4 id="彻底搞定Dart的异步"><a href="#彻底搞定Dart的异步" class="headerlink" title="彻底搞定Dart的异步"></a><a href="https://mp.weixin.qq.com/s/Ygs-sOtrohNf4vGpZcrnYw" target="_blank" rel="noopener">彻底搞定Dart的异步</a></h4><h2 id="Flutter-基础"><a href="#Flutter-基础" class="headerlink" title="Flutter 基础"></a>Flutter 基础</h2><h4 id="Flutter-一-之Flutter开发初体验"><a href="#Flutter-一-之Flutter开发初体验" class="headerlink" title="Flutter(一) 之Flutter开发初体验"></a><a href="https://mp.weixin.qq.com/s/UU2WO_YSoobthTTbniBm5Q" target="_blank" rel="noopener">Flutter(一) 之Flutter开发初体验</a></h4><h4 id="Flutter-二-之有状态的StatefulWidget"><a href="#Flutter-二-之有状态的StatefulWidget" class="headerlink" title="Flutter(二) 之有状态的StatefulWidget"></a><a href="https://mp.weixin.qq.com/s/UU2WO_YSoobthTTbniBm5Q" target="_blank" rel="noopener">Flutter(二) 之有状态的StatefulWidget</a></h4><h4 id="Flutter-三-之Flutter的基础Widget"><a href="#Flutter-三-之Flutter的基础Widget" class="headerlink" title="Flutter(三) 之Flutter的基础Widget"></a><a href="https://mp.weixin.qq.com/s/xuECuEW3MLJpXBIwkREgCA" target="_blank" rel="noopener">Flutter(三) 之Flutter的基础Widget</a></h4><h4 id="Flutter-四-之Flutter的布局Widget"><a href="#Flutter-四-之Flutter的布局Widget" class="headerlink" title="Flutter(四) 之Flutter的布局Widget"></a><a href="https://mp.weixin.qq.com/s/w33dctz-TmaYBZ9hXr4oig" target="_blank" rel="noopener">Flutter(四) 之Flutter的布局Widget</a></h4><h4 id="Flutter-五-之Flutter滚动Widget"><a href="#Flutter-五-之Flutter滚动Widget" class="headerlink" title="Flutter(五) 之Flutter滚动Widget"></a><a href="https://mp.weixin.qq.com/s/rdmfeUECLtnZz6GeQKzOqA" target="_blank" rel="noopener">Flutter(五) 之Flutter滚动Widget</a></h4><h4 id="Flutter-六-之豆瓣电影列表"><a href="#Flutter-六-之豆瓣电影列表" class="headerlink" title="Flutter(六) 之豆瓣电影列表"></a><a href="https://mp.weixin.qq.com/s/-aJ2EPEj6yzCgQBOy60zXw" target="_blank" rel="noopener">Flutter(六) 之豆瓣电影列表</a></h4><h2 id="Flutter进阶"><a href="#Flutter进阶" class="headerlink" title="Flutter进阶"></a>Flutter进阶</h2><h4 id="Flutter网络请求"><a href="#Flutter网络请求" class="headerlink" title="Flutter网络请求"></a><a href="https://mp.weixin.qq.com/s/EYluKpa7NxTKiTTrXFbhLQ" target="_blank" rel="noopener">Flutter网络请求</a></h4><h4 id="Flutter如何JSON转Model"><a href="#Flutter如何JSON转Model" class="headerlink" title="Flutter如何JSON转Model"></a><a href="https://mp.weixin.qq.com/s/4x8ZCXuw6BlQ0pYV3svmMQ" target="_blank" rel="noopener">Flutter如何JSON转Model</a></h4><h4 id="Flutter中Dart的回收机制"><a href="#Flutter中Dart的回收机制" class="headerlink" title="Flutter中Dart的回收机制"></a><a href="https://mp.weixin.qq.com/s/J4XoXJHJSmn8VaMoz3BZJQ" target="_blank" rel="noopener">Flutter中Dart的回收机制</a></h4><h4 id="Flutter的Widget-Element-RenderObject"><a href="#Flutter的Widget-Element-RenderObject" class="headerlink" title="Flutter的Widget-Element-RenderObject"></a><a href="https://mp.weixin.qq.com/s/ljzG9c-fQIJ21s7nZ2pjBg" target="_blank" rel="noopener">Flutter的Widget-Element-RenderObject</a></h4><h4 id="Flutter状态State管理"><a href="#Flutter状态State管理" class="headerlink" title="Flutter状态State管理"></a><a href="https://mp.weixin.qq.com/s/ywGQnaYpioPxlYvYTSpR4w" target="_blank" rel="noopener">Flutter状态State管理</a></h4><h4 id="Flutter事件监听"><a href="#Flutter事件监听" class="headerlink" title="Flutter事件监听"></a><a href="https://mp.weixin.qq.com/s/Z-2NL6Fe5z0AkSG0yoOJzw" target="_blank" rel="noopener">Flutter事件监听</a></h4><h4 id="Flutter路由导航"><a href="#Flutter路由导航" class="headerlink" title="Flutter路由导航"></a><a href="https://mp.weixin.qq.com/s/K1yOOTIYEzB2N7tIJv5jtQ" target="_blank" rel="noopener">Flutter路由导航</a></h4><h4 id="Flutter实现动画"><a href="#Flutter实现动画" class="headerlink" title="Flutter实现动画"></a><a href="https://mp.weixin.qq.com/s/xNRTjDApabIXasUGiW160Q" target="_blank" rel="noopener">Flutter实现动画</a></h4><h4 id="Flutter主题风格"><a href="#Flutter主题风格" class="headerlink" title="Flutter主题风格"></a><a href="https://mp.weixin.qq.com/s/CsBh8RKbuGghrXnqHxg2Vw" target="_blank" rel="noopener">Flutter主题风格</a></h4><h4 id="Flutter屏幕适配"><a href="#Flutter屏幕适配" class="headerlink" title="Flutter屏幕适配"></a><a href="https://mp.weixin.qq.com/s/z21YZ4FhSswpDWn4KpK6jw" target="_blank" rel="noopener">Flutter屏幕适配</a></h4><h4 id="Flutter应用信息"><a href="#Flutter应用信息" class="headerlink" title="Flutter应用信息"></a><a href="https://mp.weixin.qq.com/s/TsXw0e6A0792gt_M9fHhog" target="_blank" rel="noopener">Flutter应用信息</a></h4><h4 id="Flutter实现国际化"><a href="#Flutter实现国际化" class="headerlink" title="Flutter实现国际化"></a><a href="https://mp.weixin.qq.com/s/yWA95mMLNk5J5m-XOfWXRQ" target="_blank" rel="noopener">Flutter实现国际化</a></h4><h4 id="Flutter测试"><a href="#Flutter测试" class="headerlink" title="Flutter测试"></a><a href="https://mp.weixin.qq.com/s/z0KeWWOVSRD9CJiMi8npYA" target="_blank" rel="noopener">Flutter测试</a></h4><h4 id="Flutter打包发布"><a href="#Flutter打包发布" class="headerlink" title="Flutter打包发布"></a><a href="https://mp.weixin.qq.com/s/PIxn7ZZ2WAR6PVMBU9F69Q" target="_blank" rel="noopener">Flutter打包发布</a></h4><h4 id="Flutter混合开发"><a href="#Flutter混合开发" class="headerlink" title="Flutter混合开发"></a><a href="https://mp.weixin.qq.com/s/dzt--_XWbYRBYq8vYI9Npw" target="_blank" rel="noopener">Flutter混合开发</a></h4>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter resource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零代码实现导航栏切换完美过渡</title>
    <link href="/2020/07/15/%E9%9A%BE%E6%90%9E%E7%9A%84navigationBar/"/>
    <url>/2020/07/15/%E9%9A%BE%E6%90%9E%E7%9A%84navigationBar/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>UINavigationBar是每个项目不可避免要使用的控件，如果没有特殊的要求，直接定义系统的导航栏就很简单容易，也没什么问题，但如果出现导航栏颜色不同的跳转或者有导航栏和无导航栏之间的跳转 ，就会变成成一个棘手的问题，在跳转或者滑动返回的过渡很不友好，但又是必须优化的一部分。</p><p>UINavigationBar让人感觉棘手是由于navigaitonController.navigationBar是一个公用的控件，并且有且只有一个，只要一处修改了，那么全局的ViewController都会受影响，而在跳转和滑动返回的时候我们期待看到是两个不同的navigationBar，互不影响。</p><p>也就是说问题的关键是<code>让每个ViewController的navigationBar都独立，互不影响</code>。</p><h1 id="NavigationBar基础"><a href="#NavigationBar基础" class="headerlink" title="NavigationBar基础"></a>NavigationBar基础</h1><p>以下是navigationBar控件的基本结构</p><p><img src="https://i.loli.net/2020/07/15/PdcjVaUQt4TfkIM.png" srcset="/img/loading.gif" alt="image-20200715104934861"></p><pre><code class="hljs objc">navigationBar常用的属性和方法<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">assign</span>,<span class="hljs-keyword">getter</span>=isTranslucent) <span class="hljs-built_in">BOOL</span> translucent;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">readonly</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UINavigationItem</span> *topItem;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">readonly</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UINavigationItem</span> *backItem;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>,<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">UINavigationItem</span> *&gt; *items;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">null_resettable</span>, <span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIColor</span> *tintColor;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIColor</span> *barTintColor;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIImage</span> *shadowImage;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>,<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSAttributedStringKey</span>, <span class="hljs-keyword">id</span>&gt; *titleTextAttributes;<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSAttributedStringKey</span>, <span class="hljs-keyword">id</span>&gt; *largeTitleTextAttributes;- (<span class="hljs-keyword">void</span>)setBackgroundImage:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIImage</span> *)backgroundImage forBarMetrics:(<span class="hljs-built_in">UIBarMetrics</span>)barMetrics;- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIImage</span> *)backgroundImageForBarMetrics:(<span class="hljs-built_in">UIBarMetrics</span>)barMetrics;</code></pre><p>苹果官方文档中对于如何使用导航栏控制器的导航栏，描述如下</p><pre><code class="hljs objc">To control a navigation bar when using a navigation controller, the following steps are required:Create a navigation controller <span class="hljs-keyword">in</span> Interface Builder or <span class="hljs-keyword">in</span> the code.Configure the appearance of the navigation bar using the navigationBar property on the <span class="hljs-built_in">UINavigationController</span> object.Control the content of the navigation bar by setting the title and navigationItem properties on each <span class="hljs-built_in">UIViewController</span> you push onto the navigation controller’s stack.</code></pre><p>翻译过来就是：</p><p>（1）使用<code>UINavigationController</code>对象中的<code>navigationBar</code>属性配置<code>导航栏的外观</code></p><p>（2）通过设置每个<code>UIViewController</code>上的title和<code>navigationItem</code>属性来控制<code>导航栏的内容</code></p><blockquote><p>通过以上的描述，可以知道每个ViewController显示的导航栏navigationBar的内容是可以单独设置的，互不干扰，但是每个ViewController中导航栏的外观样式，都是需要通过self.navigationController.navigationBar设置，而每个viewController都共用一个navigationBar，只要一个修改了，那么其他的ViewController中导航栏navigationBar的样式也会修改。</p></blockquote><h1 id="方案解析："><a href="#方案解析：" class="headerlink" title="方案解析："></a>方案解析：</h1><p><a href="https://github.com/CallLiven/RWNavigationBarTransition" target="_blank" rel="noopener">Demo</a>代码及注释都是以<strong>界面A</strong> PUSH==&gt; <strong>界面B</strong>   和 <strong>界面B</strong> Pop==&gt;<strong>界面A</strong>为例，此处只做重要的代码解析，更为详情讲解的请查看代码注释。</p><p>这套方案是借鉴<strong>美团技术团队</strong><a href="https://mp.weixin.qq.com/s/CQ-uUJuX-nlPrM_tHBdbNQ" target="_blank" rel="noopener">iOS系统中导航栏的转场解决方案与最佳实践 </a>文章，在这里十分感谢。</p><p>整套方案核心的点是：</p><ul><li><p>“隐藏”<code>navigationController.navigationBar</code>，在A界面和B界面添加过渡的导航栏<code>rw_transitionNavigationBar</code>；</p></li><li><p><code>navigationController.navigationBar</code>的’’隐藏’’方式关键是将_UIBarBackground的透明度设置为0，这样设置的原因是：既能隐藏导航栏样式，又能不影响ViewController的布局</p></li><li><p>导航栏样式的设置最好是在<code>viewDidload</code> 或者 <code>viewWillAppeard</code>方法中设置，这是因为创建过渡导航栏<code>rw_transitionNavigationBar</code>样式是在<code>viewWillLayoutSubviews</code>中执行的，也就说在这个方法中获取navigationController.navigationBar的样式来设置<code>rw_transitionNavigationBar</code></p></li><li><p>一定一定一定🙅‍♂️不要手动设置navigationBar.translucent的值，即使是设置为默认的YES，也不要，具体为什么请看Demo代码</p></li></ul><img src="https://i.loli.net/2020/08/12/qDLMaQezjVSmcn4.png" srcset="/img/loading.gif" alt="image-20200812100443886" style="zoom:50%;" /><h1 id="使用注意事项："><a href="#使用注意事项：" class="headerlink" title="使用注意事项："></a><strong>使用注意事项：</strong></h1><ul><li>非常不建议修改默认的navigationBar.translucent，具体原因请看Demo代码，都有详情备注</li><li>导航栏背景颜色必须使用这个方法：[self.navigationController.navigationBar setBackgroundImage:[UIImage imageWithColor:UIColor.yellowColor] forBarMetrics:UIBarMetricsDefault];</li><li>上面的方法能满足大部分场景的使用，是没问题的。不过有时会发现在viewcontroller中设置navigationbar的样式不起作用了。为什么会这样？</li></ul><p>当AViewController嵌套若干个BViewController，并且将嵌套的BVewController添加到AViewController的ChildViewController，这时页面导航栏显示的样式最终由BViewController中设置的导航栏样式决定。</p><p>比如：类型今日头条中分段控制器中嵌套多个ViewController，而要实现嵌套的ViewController的View生命周期也起作用，那么就要将嵌套的ViewController添加到外层的ViewController的ChildViewController中    </p><h1 id="待解决问题："><a href="#待解决问题：" class="headerlink" title="待解决问题："></a>待解决问题：</h1><p>如果是状态栏隐藏的情况，会导致状态栏上移，及viewController.view上移，查阅了许多文章，比较好的解决方案是获取状态栏statusBar并将其透明度alpha设置为1，这样即可隐藏状态栏也不会影响布局，但是在iOS13系统以后已经是不能通过以下的代码获取状态栏，因为状态栏已经转为由<code>windowScene.statusBarManager</code>管理，虽然statusBarManager这个类并没有提供属性或者接口获取到状态栏，但是通过Swizzle方法能打印其内部私有的属性和方法，详情如下：</p><pre><code class="hljs objc"><span class="hljs-comment">/// iOS13之前</span>[[[<span class="hljs-built_in">UIApplication</span> sharedApplication] valueForKey:<span class="hljs-string">@"statusBarWindow"</span>] valueForKey:<span class="hljs-string">@"statusBar"</span>];</code></pre><blockquote><p>statusBarManager 所有属性</p></blockquote><img src="https://i.loli.net/2020/08/11/JPDAUFtuMyCejGV.png" srcset="/img/loading.gif" alt="image-20200811163523396" style="zoom:50%;" /><blockquote><p>statusBarManager 所有方法</p></blockquote><img src="https://i.loli.net/2020/08/11/IdPaSTr8MfN2bZ4.png" srcset="/img/loading.gif" alt="image-20200811163426308" style="zoom:50%;" /><pre><code class="hljs objc"><span class="hljs-comment">/// iOS 13之后获取状态栏</span><span class="hljs-built_in">UIView</span> *_statusBar = <span class="hljs-literal">nil</span>; <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">13.0</span>,*)) &#123;     <span class="hljs-built_in">UIStatusBarManager</span> *statusBarManager = [<span class="hljs-built_in">UIApplication</span> sharedApplication].keyWindow.windowScene.statusBarManager;     <span class="hljs-keyword">if</span> ([statusBarManager respondsToSelector:<span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"createLocalStatusBar"</span>)]) &#123;            <span class="hljs-built_in">UIView</span> *_localStatusBar = [statusBarManager performSelector:<span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"createLocalStatusBar"</span>)];            <span class="hljs-keyword">if</span> ([_localStatusBar respondsToSelector:<span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"statusBar"</span>)]) &#123;                _statusBar = [_localStatusBar performSelector:<span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"statusBar"</span>)];            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span>&#123;     _statusBar = [[[<span class="hljs-built_in">UIApplication</span> sharedApplication] valueForKey:<span class="hljs-string">@"statusBarWindow"</span>] valueForKey:<span class="hljs-string">@"statusBar"</span>]; &#125;</code></pre><p>但是获取到的statusBar直接设置器alpha，是不起作用的，估计内部还有其他逻辑更新其透明度，这部分还没搞清楚，接下来会接续研究，如有更好的解决方式，欢迎留言，感谢</p><h1 id="待解决问题解决方法："><a href="#待解决问题解决方法：" class="headerlink" title="待解决问题解决方法："></a>待解决问题解决方法：</h1><p>解决的思路还是跟上面描述的方式一样，不是直接设置隐藏hidden的方式去除状态栏，而是通过设置状态栏的透明度。iOS13根据上面的方式获取到状态栏再设置其透明度是行不通的，这就很纳闷了。不行那怎么办，网上也没有找到对应的方法解决，那么有时就只能靠猜了(其实苹果官方设置属性和方法名字，都是比较通俗易懂的，知其名知其意)，根据我们上面打印StatusBarManager的属性和方法，知道有几个属性和方法都涉及到alpha的值，最终通过以下的方法解决，暂时未出现BUG。</p><blockquote><p>留意到StatusBarManager有一个statusBarAlpha属性，那么心里会想是不是可以直接设置这个属性来改变状态栏的透明度？测试后，结果是不行的。</p><p>但同时也注意到方法列表中有一个<code>_updateAlpha</code>，为什么注意到它了，除了字面的意思外，还有一个就是它的typeCoding是<code>B16@0:8</code>，表示它会返回一个BOOL类型的值，并且除了消息发送的基本参数<code>self</code>、<code>_cmd</code>外没有带其他的参数了，这对于我们要Swizzle是非常友好的。结合起来可能内部的逻辑就是：状态栏的透明是否更新是通过这个方法返回的为准。事实证明确实可行</p></blockquote><pre><code class="hljs objc"><span class="hljs-comment">/// 创建一个UIStatusBar的分类，Swizzle“_updateAlpha”方法</span><span class="hljs-meta">#import <span class="hljs-meta-string">"UIStatusBarManager+RWStatusBarAlpha.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">"RWSwizzle.h"</span></span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIStatusBarManager</span> (<span class="hljs-title">RWStatusBarAlpha</span>)</span>+ (<span class="hljs-keyword">void</span>)load &#123;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;        RWSwizzleMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"_updateAlpha"</span>), [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"rw_updateAlpha"</span>));    &#125;);&#125;<span class="hljs-comment">/// 适配iOS13以后的状态栏透明度修改</span>- (<span class="hljs-built_in">BOOL</span>)rw_updateAlpha &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;&#125;<span class="hljs-keyword">@end</span></code></pre><p><strong>状态栏的隐藏通过以下方式修改，而不通过prefersStatusBarHidden设置</strong></p><pre><code class="hljs objc"><span class="hljs-comment">/// 创建一个ViewController的分类，扩展一个"rw_statusBarAlpha"属性，直接可以设置状态栏的透明度</span><span class="hljs-comment">/// 这里选择通过ViewController添加分类的方式扩展此功能，是因为修改状态栏透明度之后还需要调用viewController的setNeedsStatusBarAppearanceUpdate方法</span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UIViewController</span> (<span class="hljs-title">RWStatusBarAlpha</span>)</span><span class="hljs-comment">/// 状态栏透明度（默认值：1）</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">CGFloat</span>  rw_statusBarAlpha;<span class="hljs-keyword">@end</span>    <span class="hljs-meta">#import <span class="hljs-meta-string">"UIViewController+RWStatusBarAlpha.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">"RWSwizzle.h"</span></span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIViewController</span> (<span class="hljs-title">RWStatusBarAlpha</span>)</span>+ (<span class="hljs-keyword">void</span>)load &#123;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;        RWSwizzleMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>],                        <span class="hljs-keyword">@selector</span>(init),                        [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>],                        <span class="hljs-keyword">@selector</span>(rw_init));    &#125;);&#125;- (<span class="hljs-keyword">instancetype</span>)rw_init &#123;  <span class="hljs-comment">/// 设置其初始值为1</span>    <span class="hljs-keyword">self</span>.rw_statusBarAlpha = <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> rw_init];&#125;- (<span class="hljs-built_in">CGFloat</span>)rw_statusBarAlpha &#123;    <span class="hljs-keyword">return</span> [objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(rw_statusBarAlpha)) floatValue];&#125;- (<span class="hljs-keyword">void</span>)setRw_statusBarAlpha:(<span class="hljs-built_in">CGFloat</span>)rw_statusBarAlpha &#123;    objc_setAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(rw_statusBarAlpha), @(rw_statusBarAlpha), OBJC_ASSOCIATION_RETAIN_NONATOMIC);    <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">13.0</span>,*)) &#123;        <span class="hljs-built_in">UIStatusBarManager</span> *statusBarManager = [<span class="hljs-built_in">UIApplication</span> sharedApplication].keyWindow.windowScene.statusBarManager;        [statusBarManager setValue:@(rw_statusBarAlpha) forKey:<span class="hljs-string">@"statusBarAlpha"</span>];    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">UIView</span> *statusBar = [[[<span class="hljs-built_in">UIApplication</span> sharedApplication] valueForKey:<span class="hljs-string">@"statusBarWindow"</span>] valueForKey:<span class="hljs-string">@"statusBar"</span>];        statusBar.alpha = rw_statusBarAlpha;    &#125;    [<span class="hljs-keyword">self</span> setNeedsStatusBarAppearanceUpdate];&#125;<span class="hljs-keyword">@end</span></code></pre><h1 id="疑惑解密："><a href="#疑惑解密：" class="headerlink" title="疑惑解密："></a>疑惑解密：</h1><p><strong>正确的设置导航栏控制中导航栏的背景颜色</strong></p><p>请查阅<a href="https://www.jianshu.com/p/6a5552ec5099" target="_blank" rel="noopener">iOS NavigationBar 导航栏背景颜色设置 + iOS11 适配</a>一文中，关于设置navigationBar.tinkColor、navigationBar.backgroundColor、navigationBar.BarTinkColor的区别</p><p>推荐写法（视觉上是看不出有任何差别的）</p><pre><code class="hljs objc">[<span class="hljs-keyword">self</span>.navigationController.navigationBar setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageWithColor:<span class="hljs-built_in">UIColor</span>.yellowColor] forBarMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];</code></pre><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><blockquote><p>NavigationController 设置 RootViewController时，rootViewController创建时避免设置view相关的属性，如果设置了view相关的属性，那么就会提前调用viewController的viewDidLoad方法，导致viewController还没入栈navigation Stack，在viewDidLoad设置导航栏时，获取导航栏控制器为空</p></blockquote><p><img src="https://i.loli.net/2020/07/15/B68dLgIHOrm7XZl.png" srcset="/img/loading.gif" alt="image-20200715143403667"></p><p><img src="https://i.loli.net/2020/07/15/jeFmacJNpuIv3UE.png" srcset="/img/loading.gif" alt="image-20200715143504939"></p><h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><p><strong>美团技术团队</strong>–<a href="https://mp.weixin.qq.com/s/CQ-uUJuX-nlPrM_tHBdbNQ" target="_blank" rel="noopener">iOS系统中导航栏的转场解决方案与最佳实践 </a>  <a href="https://github.com/MoZhouqi/KMNavigationBarTransition" target="_blank" rel="noopener">github代码</a></p>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目必备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好文细品</title>
    <link href="/2020/07/06/%E5%A5%BD%E6%96%87%E7%BB%86%E5%93%81/"/>
    <url>/2020/07/06/%E5%A5%BD%E6%96%87%E7%BB%86%E5%93%81/</url>
    
    <content type="html"><![CDATA[<p>最快的成长莫过于借鉴他人的方法，再用自己的双手实践。以下文章都是本人会多次阅读的好文章，每一次都会有不同的收获，特此在这里分享</p><h1 id="必备第三方库"><a href="#必备第三方库" class="headerlink" title="必备第三方库"></a>必备第三方库</h1><p>NavigationBar转场过渡 <a href="https://github.com/MoZhouqi/KMNavigationBarTransition" target="_blank" rel="noopener">KMNavigationBarTransition</a></p><h1 id="UI布局"><a href="#UI布局" class="headerlink" title="UI布局"></a>UI布局</h1><p>美团技术团队–<a href="https://mp.weixin.qq.com/s/CQ-uUJuX-nlPrM_tHBdbNQ" target="_blank" rel="noopener">iOS系统中导航栏的转场解决方案与最佳实践 </a>  <a href="https://github.com/MoZhouqi/KMNavigationBarTransition" target="_blank" rel="noopener">github代码</a></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Casa神架构五部曲</p><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="noopener">iOS应用架构谈 开篇</a> </p><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="noopener">iOS应用架构谈 view层的组织和调用方案</a> </p><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="noopener">iOS应用架构谈 网络层设计方案</a> </p><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html" target="_blank" rel="noopener">iOS应用架构谈 本地持久化方案及动态部署</a> </p><p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Animation</title>
    <link href="/2020/07/02/instrument_CoreAnimation/"/>
    <url>/2020/07/02/instrument_CoreAnimation/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文转载于suiling的<a href="http://www.cocoachina.com/articles/15238" target="_blank" rel="noopener">UIKit性能优化实战讲解</a></p><p>新版Xcode的instrument CoreAnimation 功能调整会有所不一样，对于下文所提到的coreAnimation面板中的调试选项，被移动到Xcode菜单中，如下图</p><p><img src="https://i.loli.net/2020/07/02/IZaR2hON95duHXY.png" srcset="/img/loading.gif" alt="image-20200702103604902"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在使用UIKit的过程中，性能优化是永恒的话题。很多人都看过分析优化滑动性能的文章，但其中不少文章只介绍了优化方法却对背后的原理避而不谈，或者是晦涩难懂而且读者缺乏实践体验的机会。不妨思考一下下面的问题自己是否有一个清晰的认识：</p><ol><li>为什么要把控件尽量设置成不透明的，如果是透明的会有什么影响，如何检测这种影响？</li><li>为什么cell中的图片，尽可能要使用正确的大小、格式，如果错误会有什么影响，如何检测这种影响？</li><li>为什么设置阴影和圆角有可能影响滑动时流畅度？</li><li>shouldRasterize和离屏渲染的关系是什么，何时应该使用？</li></ol><p>本文会结合Instrument分析影响性能的因素，提出优化方案并解释背后的原理，项目初始demo的下载地址在<a href="https://github.com/bestswifter/MySampleCode/tree/master/GraphicsPerformance-Starter" target="_blank" rel="noopener">我的Github</a>，强烈建议每一位读者下载下来随着我一步一步调试、优化。如果觉得对自己有帮助，可以给一个Star表示支持。后面的图片较多，流量党慎入。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p>打开项目后，只要CustomTableCell.swift文件即可，它实现了自定义的UITableViewCell以及内部的UI布局，因为重点在于性能优化，代码实现的就比较随意。</p><p>首先按下Command + I打开Instrument，本文主要用到的是Core Animation工具：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574569394272.png" srcset="/img/loading.gif" alt="1171077-ae80c7d848fc7b74.png"></p><p>打开Core Animation调试</p><p>注意这个调试必须使用真机，点击左上角的红色圆圈就会开始录制。新手可能不太熟悉，这里简单介绍一下调试界面：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574647232279.png" srcset="/img/loading.gif" alt="QQ截图20160204163031.png"></p><p>调试界面</p><p>我们需要了解两个两个区域：</p><ol><li>这里记录了实时的fps数值，有些地方是0是因为屏幕没有滑动</li><li>这是重中之重，接下来我会带大家逐个理解、体验这些调试选项</li></ol><p>有过游戏经验的人也许对fps这个概念比较熟悉。我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为一帧(frame)，fps表示frames per second，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。</p><h2 id="调试、优化"><a href="#调试、优化" class="headerlink" title="调试、优化"></a><strong>调试、优化</strong></h2><h3 id="（1）图层混合-Color-Blended-Layers"><a href="#（1）图层混合-Color-Blended-Layers" class="headerlink" title="（1）图层混合 Color Blended Layers"></a><strong>（1）图层混合</strong> Color Blended Layers</h3><p>首先我们要明白像素的概念，屏幕上每一个点都是一个像素，像素有R、G、B三种颜色构成(有时候还带有alpha值)。如果某一块区域上覆盖了多个layer,最后的显示效果受到这些layer的共同影响。举个例子，上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blending)需要消耗一定的GPU资源，因为实际上可能不止只有两层。如果只想显示最上层的蓝色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。</p><p>第一个调试选项<code>&quot;Color Blended Layers&quot;</code>正是用于检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。一旦发现应该想法设法消除它。开始调试后勾选这个选项，我们在手机上可以看到如下的场景：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574700385497.png" srcset="/img/loading.gif" alt="1171077-6fb5ba7033c1f825.png"></p><p>Color Blended Layers</p><p>很多文章里说把控件设置为opaque = true，其原理就是希望避免图层混合，然而这种调优一般情况下用处不大。因为UIView的opaque属性默认值就是true，也就是说只要不是人为设置成透明，都不会出现图层混合。比如demo中就没有任何透明的控件。</p><p>对于UIImageView来说，不仅它自身需要是不透明的，它的图片也不能含有alpha通道，这就是为什么图中第三个图片是绿色，而前两个图片是红色的原因。由于本人对PS和图像几乎一窍不通，恕我不能演示如何消除这些图片的红色。我从网上找了一个美女的头像来说明，图像自身的性质可能会对结果有影响，因此如果你确定自己的代码没有问题，而且出现了图层混合，请联系美工或后台解决。</p><p>个人认为比opaque属性更重要的是backgroundColor属性，如果不设置这个属性，控件依然被认为是透明的，所以我们做的第一个优化是在CustomTableCell类的init方法中添加一行代码：</p><pre><code class="hljs plain">label.backgroundColor &#x3D; UIColor.whiteColor()复制代码</code></pre><p>虽然在白色背景下，这行代码无法肉眼看到效果，但重新调试后我们可以发现label的红色消失了。也正是因为对背景颜色的不重视，它成了影响滑动性能的第一个杀手。</p><p>PS：如果label文字有中文，依然会出现图层混合，这是因为此时label多了一个sublayer，如果有好的解决办法欢迎告诉我。</p><h3 id="（2）-光栅化-Color-Hits-Green-and-Misses-Red"><a href="#（2）-光栅化-Color-Hits-Green-and-Misses-Red" class="headerlink" title="（2）*光栅化 *Color Hits Green and Misses Red"></a>（2）*<em>光栅化 *</em>Color Hits Green and Misses Red</h3><p>光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化：</p><pre><code class="hljs plain">label.layer.shouldRasterize &#x3D; true复制代码</code></pre><p>Instrument中，第二个调试选项是<code>“Color Hits Green and Misses Red”</code>，它表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好。勾选这个选项后我们看到如下的场景：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574749327396.png" srcset="/img/loading.gif" alt="1171077-7d6dcd41fe0d6a72.png"></p><p>Color Hits Green and Misses Red</p><p>光栅化的核心在于缓存的思想。我们自己动手把玩一下，可以发现以下几个有意思的现象：</p><ul><li>上下微小幅度滑动时，一直是绿色</li><li>上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色</li><li>如果静止一秒钟，刚开始滑动时会变红。</li></ul><p>这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。</p><p>光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化，所以我们做的第二个优化是注释掉下面这行代码：</p><pre><code class="hljs plain">&#x2F;&#x2F;    label.layer.shouldRasterize &#x3D; true复制代码</code></pre><p>光栅化会导致离屏渲染，这一点待会儿会讲。</p><h3 id="（3）颜色格式-Color-Copied-Images"><a href="#（3）颜色格式-Color-Copied-Images" class="headerlink" title="（3）颜色格式 Color Copied Images"></a>（3）<strong>颜色格式</strong> Color Copied Images</h3><p>像素在内存中的布局和它在磁盘中的存储方式并不相同。考虑一种简单的情况：每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。但是一张同样分辨率的PNG格式或JPEG格式的图片一般情况下不会有这么大。这是因为JPEG将像素数据进行了一种非常复杂且可逆的转化。</p><p>当我们打开JPEG格式的图片时，CPU会进行一系列运算，将JPEG图片解压成像素数据。显然这个工作会消耗不少时间，所以不应该在滑动时进行，我们应该预先处理好图片。借用WWDC上的一页PPT来说明：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574786533951.png" srcset="/img/loading.gif" alt="QQ截图20160204163259.png"></p><p>显示流程</p><p>Commit Transaction和Decode在同一帧内进行，如果这两个操作的耗时超过16.67s，Draw Calls就会延迟到下一帧，从而导致fps值的降低。下面是Commit Transaction的详细流程：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574813145443.png" srcset="/img/loading.gif" alt="23.png"></p><p>解码与转换</p><p>在第三步的Prepare中，CPU主要处理两件事：</p><ol><li>把图片从PNG或JPEG等格式中解压出来，得到像素数据。</li><li>如果GPU不支持这种颜色各式，CPU需要进行格式转换。</li></ol><p>比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。第三个选项<code>“Color Copied Images”</code>就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。</p><p>遗憾的是由于我对图片格式不太了解，也不会使用相关工具，并没有能模拟出触发这个选项的场景。我们要记住的是，如果调试时发现有图片被标记为蓝色，说明图片格式出现了一些问题。</p><h3 id="（4）-图片大小-Color-Misaligned-Images"><a href="#（4）-图片大小-Color-Misaligned-Images" class="headerlink" title="（4）*图片大小 *Color Misaligned Images"></a>（4）*<em>图片大小 *</em>Color Misaligned Images</h3><p>第四个选项的使用场景不多，我们直接看一下第五个选项<code>“Color Misaligned Images”</code>。它表示如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。勾选上这个选项并进行调试，可以看到如下场景：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574848200805.png" srcset="/img/loading.gif" alt="1171077-c6226861bea907a9.png"></p><p>图片缩放</p><p>在demo中，每个UIImageView的大小都是180x180，而只有第二张图片的像素大小是360x360。因此除了第二张图片，其他的图片都需要被缩放。图片的缩放需要占用时间，因此我们要尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致。</p><p>第三个优化是调整所有图片的像素大小以避免不必要的缩放。</p><h3 id="（5）离屏渲染-Color-Offscreen-Rendered-Yellow"><a href="#（5）离屏渲染-Color-Offscreen-Rendered-Yellow" class="headerlink" title="（5）离屏渲染 Color Offscreen-Rendered Yellow"></a>（5）<strong>离屏渲染</strong> Color Offscreen-Rendered Yellow</h3><p>离屏渲染表示渲染发生在屏幕之外，你可能认为这是一句废话。为了真正解释清楚什么是离屏渲染，我们先来看一下正常的渲染通道(Render-Pass)：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574886988597.png" srcset="/img/loading.gif" alt="24.png"></p><p>正常渲染通道</p><p>首先，OpenGL提交一个命令到Command Buffer，随后GPU开始渲染，渲染结果放到Render Buffer中，这是正常的渲染流程。但是有一些复杂的效果无法直接渲染出结果，它需要分步渲染最后再组合起来，比如添加一个蒙版(mask)：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574896688356.png" srcset="/img/loading.gif" alt="26.png"></p><p>离屏渲染</p><p>在前两个渲染通道中，GPU分别得到了纹理(texture，也就是那个相机图标)和layer(蓝色的蒙版)的渲染结果。但这两个渲染结果没有直接放入Render Buffer中，也就表示这是离屏渲染。直到第三个渲染通道，才把两者组合起来放入Render Buffer中。离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。</p><p>第六个选项<code>“Color Offscreen-Rendered Yellow”</code>会把需要离屏渲染的地方标记为黄色，大部分情况下我们需要尽可能避免黄色的出现。离屏渲染可能会自动触发，也可以手动触发。以下情况可能会导致触发离屏渲染：</p><ol><li>重写drawRect方法</li><li>有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask</li><li>layer.shouldRasterize = true</li></ol><p>前两者会自动触发离屏渲染，第三种方法是手动开启离屏渲染。</p><p>开始调试并勾选“Color Offscreen-Rendered Yellow”，会看到这样的场景：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574930475932.png" srcset="/img/loading.gif" alt="27.png"></p><p>离屏渲染</p><p>如果没有进行第二步优化，你会发现label也是黄色。可以看到tabbar和statusBar也是黄色，这是因为它们使用了模糊效果。图片也是黄色，这说明它也进行了离屏渲染，观察源码后发现主要原因是它使用了阴影，接下来我们进行第四个优化，在设置阴影效果的四行代码下面添加一行：</p><pre><code class="hljs plain">imgView.layer.shadowPath &#x3D; UIBezierPath(rect: imgView.bounds).CGPath复制代码</code></pre><p>这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。</p><p>设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：</p><pre><code class="hljs plain">&#x2F;&#x2F; 设置圆角label.layer.masksToBounds &#x3D; truelabel.layer.cornerRadius &#x3D; 8label.layer.shouldRasterize &#x3D; truelabel.layer.rasterizationScale &#x3D; layer.contentsScale复制代码</code></pre><h3 id="（6）快速路径-Color-Compositing-Fast-Path-Blue"><a href="#（6）快速路径-Color-Compositing-Fast-Path-Blue" class="headerlink" title="（6）快速路径 Color Compositing Fast-Path Blue"></a>（6）<strong>快速路径</strong> Color Compositing Fast-Path Blue</h3><p>还记得之前将离屏渲染和渲染路径时的示意图么，离屏渲染的最后一步是把此前的多个路径组合起来。如果这个组合过程能由CPU完成，就会大量减少GPU的工作。这种技术在绘制地图中可能用到。</p><p>第七个选项<code>“Color Compositing Fast-Path Blue”</code>用于标记由硬件绘制的路径，蓝色越多越好。</p><h3 id="（7）变化区域-Flash-updated-Regions"><a href="#（7）变化区域-Flash-updated-Regions" class="headerlink" title="（7）变化区域 Flash updated Regions"></a>（7）变化区域 Flash updated Regions</h3><p>刷新视图时，我们应该把需要重绘的区域尽可能缩小。对于未发生变化的内容则不应该重绘，第八个选项<code>“Flash updated Regions”</code>用于标记发生重绘的区域。一个典型的例子是系统的时钟应用，绝大多数时候只有显示秒针的区域需要重绘：</p><p><img src="http://api.cocoachina.com/uploads/20160204/1454574987766890.png" srcset="/img/loading.gif" alt="28.png"></p><p>重绘区域</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>如果你一步一步做到了这里，我想一定会有不少收益。不过，学而不思则罔，思而不学则殆。动手实践后还是应该总结提炼，优化滑动性能主要涉及三个方面：</p><p><strong>避免图层混合</strong></p><ul><li>确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明。</li><li>如无特殊需要，不要设置低于1的alpha值。</li><li>确保UIImage没有alpha通道。</li></ul><p><strong>避免临时转换</strong></p><ul><li>确保图片大小和frame一致，不要在滑动时缩放图片。</li><li>确保图片颜色格式被GPU支持，避免劳烦CPU转换。</li></ul><p><strong>慎用离屏渲染</strong></p><ul><li>绝大多数时候离屏渲染会影响性能。</li><li>重写drawRect方法，设置圆角、阴影、模糊效果，光栅化都会导致离屏渲染。</li><li>设置阴影效果是加上阴影路径。</li><li>滑动时若需要圆角效果，开启光栅化。</li></ul><p><strong>实战</strong></p><p>本文的demo可以在<a href="https://github.com/bestswifter/MySampleCode/tree/master/GraphicsPerformance-Starter" target="_blank" rel="noopener">我的Github</a>上下载，然后一步一步自己体验优化过程。但demo毕竟是刻意搭建的一个环境，我会在我自己的仿写的简书app上不断进行实战优化，欢迎共同学习交流。</p><p><strong>参考资料：</strong></p><ul><li><a href="http://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕上</a>，原文：<a href="https://www.objc.io/issues/3-views/" target="_blank" rel="noopener">Getting Pixels onto the Screen</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2014-419/" target="_blank" rel="noopener">Advanced Graphics and Animations for iOS Apps</a>：这是2014年WWDC Session 419，强烈建议看一遍。</li><li><a href="http://oncenote.com/2015/12/08/How-to-build-UI/" target="_blank" rel="noopener">如何正确地写好一个界面</a></li><li><a href="https://yalantis.com/blog/mastering-uikit-performance/" target="_blank" rel="noopener">Mastering UIKit Performance</a></li></ul><p>还有一些高质量的问答：</p><ul><li><a href="http://stackoverflow.com/questions/6302029/what-triggers-color-copied-images-and-color-hits-green-and-misses-red-in-ins" target="_blank" rel="noopener">What triggers “Color Copied Images” and “Color Hits Green and Misses Red” in Instruments?</a></li><li><a href="http://stackoverflow.com/questions/34895641/uilabel-is-marked-as-red-when-color-blended-layers-is-selected" target="_blank" rel="noopener">UILabel is marked as red when Color Blended Layers is selected</a></li><li><a href="http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios" target="_blank" rel="noopener">What triggers offscreen rendering, blending and layoutSubviews in iOS?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化,instrument</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化笔记-内存优化</title>
    <link href="/2020/06/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <url>/2020/06/22/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内存问题主要包括两部分</p><ul><li>iOS常见的循环引用导致的内存泄漏</li><li>大量数据加载及使用导致的内存警告</li></ul><p><strong>补充：</strong></p><p><strong>内存泄漏</strong>：是指当一个对象或变量在使用完成后没有被释放掉，一直占用着这部分内存，直到应用停止。</p><p><strong>内存溢出</strong>：是指程序在申请内存时，没有足够的内存空间供其使用，出现内存溢出；比如申请一个interger，但是给它存了long才能存下的数，那就是内存溢出</p><h1 id="一、循环引用"><a href="#一、循环引用" class="headerlink" title="一、循环引用"></a>一、循环引用</h1><p>循环引用是iOS开发中经常遇到的问题，尤其是对于新手来说是个头疼的问题。循环引用对App有潜在的危害，会使内存消耗过高，性能变差和Crash等，iOS常见的主要以下三种情况：</p><h4 id="（1）Delegate"><a href="#（1）Delegate" class="headerlink" title="（1）Delegate"></a>（1）Delegate</h4><p>代理协议是一个典型的场景，需要你使用弱引用来避免循环应用。ARC时代，需要将代理声明为<code>weak</code>是一个即好又安全的做法</p><pre><code class="hljs objc"><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">weak</span>) <span class="hljs-keyword">id</span>&lt;testDelegate&gt; delegate;</code></pre><h4 id="（2）NSTimer"><a href="#（2）NSTimer" class="headerlink" title="（2）NSTimer"></a>（2）NSTimer</h4><p>NSTimer 是我们开发很常用的定时器，比如下面的代码：</p><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;    [<span class="hljs-keyword">super</span> viewDidLoad];        <span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(doSomeThing) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];    &#125;- (<span class="hljs-keyword">void</span>)doSomeThing &#123;    &#125;- (<span class="hljs-keyword">void</span>)dealloc &#123;    [<span class="hljs-keyword">self</span>.timer invalidate];    <span class="hljs-keyword">self</span>.timer = <span class="hljs-literal">nil</span>;&#125;</code></pre><p>这是典型的循环引用，因为timer会强引用self，而self又持有了timer，所以就造成了循环引用。可能有人会说，使用一个weak指针，比如</p><pre><code class="hljs objc">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) wself = <span class="hljs-keyword">self</span>;<span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span> target:wself selector:<span class="hljs-keyword">@selector</span>(doSomeThing) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];</code></pre><p>但是其实并没有作用，因为不管是wself还是strongSelf，最终在NSTimer内部都会重新生成一个新的指针指向self，这是一个强引用的指针，结果就会导致循环引用。</p><p>解决方法主要以下儿种方式：</p><ul><li>使用<code>类方法</code> （请参考文章底部的写法）</li><li>使用<code>GCD timer</code></li></ul><h4 id="（3）Block"><a href="#（3）Block" class="headerlink" title="（3）Block"></a>（3）Block</h4><p>Block 的循环引用，主要是发生在ViewController中持有了block，比如：</p><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) LECallbackBlock callbackBlock;</code></pre><p>同时在对callbackBlock进行赋值的时候又调用了viewController的方法，比如：</p><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.callbackBlock = ^&#123;[<span class="hljs-keyword">self</span> doSomeThing];&#125;;</code></pre><p>就会发生循环引用，因为：viewController—&gt;强引用了callbackBlock—&gt;强引用了ViewController,解决的方法很简单：</p><pre><code class="hljs objc">_<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) wself = <span class="hljs-keyword">self</span>;<span class="hljs-keyword">self</span>.callbackBlock = ^&#123;[wself doSomeThing];&#125;;</code></pre><p><code>循环引用的解决方法</code>：</p><p><strong>ARC</strong>环境下：</p><ul><li><code>__weak</code>、<code>__unsafe_unretained</code>解决（首选__weak，因为指向的对象被销毁的时候，会自动让指针置nil）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1923392-055b3a0078ec1fb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" srcset="/img/loading.gif" alt="img"></p><ul><li>用<code>__block</code>解决（缺点：必须要调用过block，才会解决循环引用）</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1923392-8f0d93b74599e78c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" srcset="/img/loading.gif" alt="img"></p><p><strong>MRC</strong>环境下：</p><ul><li>用__unsafe_unretained 解决</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1923392-60ad7b5283f14530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/832" srcset="/img/loading.gif" alt="img"></p><ul><li>用__block 解决</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1923392-22b5afb5654e46f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/610" srcset="/img/loading.gif" alt="img"></p><h4 id="（4）其他"><a href="#（4）其他" class="headerlink" title="（4）其他"></a><strong>（4）其他</strong></h4><p>1、比如NSNotification addObserver之后，没有remove</p><p>2、动画的repeat count无限大，而且不主动停止动画，基本就等于无限循环（解决方法：在视图控制器即将消失的时候，移除动画）</p><h1 id="二、大量数据加载及使用导致内存警告"><a href="#二、大量数据加载及使用导致内存警告" class="headerlink" title="二、大量数据加载及使用导致内存警告"></a>二、大量数据加载及使用导致内存警告</h1><p>一般在占用系统内存超过20%的时候会有内存警告，而超过50%的时候，就很容易Crash了，所以内容使用率还是尽量要少，对于数据量比较大的应用，可以采用<code>分布式加载数据</code>的方式，或者采用<code>文件内存映射(mmap)</code>方式。</p><p>mmap是使用逻辑内存对磁盘文件进行映射，中间只是进行映射没有任何拷贝操作，避免了写文件饿数据拷贝。操作内存就相当于操作文件，避免了内核空间和用户空间的频繁切换</p><h1 id="三、工具"><a href="#三、工具" class="headerlink" title="三、工具"></a>三、工具</h1><ul><li>通过<code>Instruments</code>来查看leaks（推荐此教程，很详细<a href="https://www.cnblogs.com/lxlx1798/p/6933485.html" target="_blank" rel="noopener">教程</a>）</li><li>集成Facebook开源的<a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="noopener">FBRetainCycleDetector</a></li><li>集成<a href="https://github.com/Tencent/MLeaksFinder" target="_blank" rel="noopener">MLeaksFinder</a></li></ul><h1 id="四、心得"><a href="#四、心得" class="headerlink" title="四、心得"></a>四、心得</h1><p>使用Instruments查看leaks，具体使用教程请看此<a href="https://www.cnblogs.com/lxlx1798/p/6933485.html" target="_blank" rel="noopener">教程</a>，此处主要是本人在使用过程中的一点点心得</p><h4 id="（1）Call-Tree-中-显示的是十六进制的代码，不是具体的类名称"><a href="#（1）Call-Tree-中-显示的是十六进制的代码，不是具体的类名称" class="headerlink" title="（1）Call Tree 中 显示的是十六进制的代码，不是具体的类名称"></a><strong>（1）Call Tree 中 显示的是十六进制的代码，不是具体的类名称</strong></h4><p><img src="https://i.loli.net/2020/06/23/bmN5O2YlZDt7EeQ.png" srcset="/img/loading.gif" alt="image-20200623140954367"></p><p>解决方法</p><p><img src="https://i.loli.net/2020/06/23/y4L5bEmv6dKZIt8.png" srcset="/img/loading.gif" alt="image-20200623140549667"></p><h4 id="（2）单独查看某个引发红点内存泄漏的代码"><a href="#（2）单独查看某个引发红点内存泄漏的代码" class="headerlink" title="（2）单独查看某个引发红点内存泄漏的代码"></a><strong>（2）单独查看某个引发红点内存泄漏的代码</strong></h4><p><img src="https://i.loli.net/2020/06/23/jTUlgYLM569kOEZ.png" srcset="/img/loading.gif" alt="image-20200623141217807"></p><p>Call Tree 列表中默认是显示所有红点的内存泄漏地方，如果要只查看某个红点的内存泄漏的代码，可以如下操作</p><p><img src="https://i.loli.net/2020/06/23/XkUl153b8xQRe4j.png" srcset="/img/loading.gif" alt="image-20200623141649446"></p><h4 id="（3）内存泄漏分析"><a href="#（3）内存泄漏分析" class="headerlink" title="（3）内存泄漏分析"></a><strong>（3）内存泄漏分析</strong></h4><p><img src="https://i.loli.net/2020/06/23/vEIjoylJLrwNiSb.png" srcset="/img/loading.gif" alt="image-20200623142224243"></p><h4 id="（4）如何设置只有在DEBUG模式下才添加FBRetainCycleDetector或者MLeaksFinder"><a href="#（4）如何设置只有在DEBUG模式下才添加FBRetainCycleDetector或者MLeaksFinder" class="headerlink" title="（4）如何设置只有在DEBUG模式下才添加FBRetainCycleDetector或者MLeaksFinder"></a><strong>（4）如何设置只有在DEBUG模式下才添加<a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="noopener">FBRetainCycleDetector</a>或者<a href="https://github.com/Tencent/MLeaksFinder" target="_blank" rel="noopener">MLeaksFinder</a></strong></h4><pre><code class="hljs objc">pod <span class="hljs-string">'FBRetainCycleDetector'</span>, :configuration =&gt; [<span class="hljs-string">'Debug'</span>]pod <span class="hljs-string">'MLeaksFinder'</span> , :configuration =&gt; [<span class="hljs-string">'Debug'</span>]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化,instrument</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>viewController frame的详解</title>
    <link href="/2020/06/18/viewController%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E8%AE%B2%E8%A7%A3/"/>
    <url>/2020/06/18/viewController%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你是否还在疑惑为什么ViewController中的布局有时会被导航栏遮罩住，有时又不会了？</p><p>你是否还在疑惑两个ViewController，一个有滚动视图，一个没有滚动视图，他们的布局起点不一致的问题？</p><p>你是否还在疑惑导航栏透明的时候，要怎么把视图布局都从屏幕的最左上角开始？</p><p>你是否还在疑惑关于布局的属性设置还有那么多种，要怎么区分和使用？</p><p>本文将详细的讲解，相信你读后能解开上面的疑问</p><p>开始之前请下载<a href="">Demo</a>代码</p><p>链接:<a href="https://pan.baidu.com/s/18gNFhuQO29KDJ3PxTI7A3w" target="_blank" rel="noopener">https://pan.baidu.com/s/18gNFhuQO29KDJ3PxTI7A3w</a>  密码:myec</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先全文讨论的场景都是在有导航栏情况下的ViewController（如果是没有导航栏，那么毫无疑问坐标的起点都是屏幕的最左上角，也没有必要设置布局的属性）</p><p>并且对于下面参数的设置，请记得一定要对比其设置的值对于坐标起点(0,0)的影响，这是本文的<strong>重点</strong>、<strong>重点</strong>、<strong>重点</strong></p><p>对于影响坐标系起点的属性，常用的有如下三个</p><ul><li><code>extendedLayoutIncludesOpaqueBars</code> 默认值：NO</li><li><code>edgesForExtendedLayout</code> 默认值：UIRectEdgeAll</li><li><code>translucent</code> 默认值：YES (navigationBar 和 tabBar)</li></ul><h3 id="第一节：滚动视图与非滚动视图的区别"><a href="#第一节：滚动视图与非滚动视图的区别" class="headerlink" title="第一节：滚动视图与非滚动视图的区别"></a><strong>第一节：滚动视图与非滚动视图的区别</strong></h3><p>这里需要先对比<code>滚动视图</code>(比如tableView)和<code>非滚动视图</code>(比如UIView)，在没有设置如何布局相关属性的情况下，设置的frame坐标是(0,0)，效果如下</p><img src="https://i.loli.net/2020/06/18/xUZM8h4WCsegyIc.png" srcset="/img/loading.gif" alt="image-20200618112606669" style="zoom:25%;" /><img src="https://i.loli.net/2020/06/18/pxiTdz6LsKSHQ91.png" srcset="/img/loading.gif" alt="image-20200618112733491" style="zoom:25%;" /><p>备注：以下都以tableView作为滚动视图的描述，blueView作为非滚动视图的描述</p><p>从上面的两张效果图可以看出，blueView会被导航栏遮盖，而tableView不会。</p><p>这里就不做过多的探讨，直接说出结论：</p><p>一个ViewContrller只有一个坐标系，也就是说坐标(0,0)是指向同一个点；</p><p>blueView和tableView的frame坐标都是(0,0)，而tableView不被遮盖，不是改变了其frame的坐标，主要是因为滚动视图都有一个<code>contentInset</code>的属性，通过改变contentInset的值，实现不被遮盖的原理。</p><p><code>重点：以下属性设置的作用是 滚动视图 会不会自动调整contentInset的值，实现不被导航栏遮挡</code>，跟我们上面要讲的三个改变坐标系起点的属性是完全无关的，这要区分开来，因为很多人都会搞混</p><pre><code class="hljs objc"><span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">11</span>,*)) &#123;        <span class="hljs-comment">// iOS11 引入的“安全区域”的概念，废弃了iOS7之后出现的 topLayoutGuide/bottomLayoutGuide</span>        <span class="hljs-comment">// iOS11是2017年9月20日发布，第一部全屏手机iPhoneX是2017年11月3日上市的，所以安全区域是为了更好的适配全屏手机</span>        <span class="hljs-comment">// 常用的两个值</span>        <span class="hljs-comment">// UIScrollViewContentInsetAdjustmentAutomatic (默认值，设置ScrollView的显示区域范围在safeArea的范围内，不被stateBar、TabBar、NavigationBar遮盖)</span>        <span class="hljs-comment">// UIScrollViewContentInsetAdjustmentNever （contentInset is not adjusted）</span>        <span class="hljs-comment">// 其原理与iOS11的不一样，scrollView.contentInset的值不会变，而是设置了安全区域的值ajustedContentInset</span>        <span class="hljs-comment">// scrollView.ajustedContentInset的值（提供给用户的是只读属性）</span>        <span class="hljs-keyword">self</span>.tableView.contentInsetAdjustmentBehavior = <span class="hljs-built_in">UIScrollViewContentInsetAdjustmentNever</span>;        <span class="hljs-comment">// 另外用户还可以增加“安全区域”的范围</span>        <span class="hljs-comment">// 备注：设置的值是在原来得基础上设置的，不能减少</span>        <span class="hljs-comment">// self.additionalSafeAreaInsets = UIEdgeInsetsMake(200, 0, 0, 0);</span>        <span class="hljs-comment">// 备注：contentInsett和additionalSafeAreaInsets 两个同时设置，作用不会重叠，是以设置最大的为准</span>        <span class="hljs-comment">// self.tableView.contentInset = UIEdgeInsetsMake(50, 0, 0, 0);</span>    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">// 在iOS11.0系统之后，被弃用了</span>        <span class="hljs-comment">// 其原理是设置scrollView.contentInset，可以在viewDidAppear方法打印其值</span>        <span class="hljs-keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="hljs-literal">YES</span>;    &#125;</code></pre><h3 id="第二节：修改viewController的坐标系"><a href="#第二节：修改viewController的坐标系" class="headerlink" title="第二节：修改viewController的坐标系"></a><strong>第二节：修改viewController的坐标系</strong></h3><p><code>extendedLayoutIncludesOpaqueBars</code>、<code>edgesForExtendedLayout</code>、<code>translucent</code> 这三个属性值是会互相影响的。</p><blockquote><p>这三个值的优先次序：<code>edgesForExtendedLayout</code> &gt; <code>extendedLayoutIncludesOpaqueBars</code> &gt; <code>translucent</code></p></blockquote><p>首先了解一下它们各自的定义</p><p><code>edgesForExtendedLayout</code> 是设置viewController的view是否向四周延伸，默认值是<code>UIRectEdgeAll</code>向四周延伸，<code>UIRectEdgeNone</code>是不延伸，view只会从navigationBar的底部到tabBar上边结束</p><p><code>extendedLayoutIncludesOpaqueBars</code>设置view是否延伸<code>不透明</code>的bars，默认值是YES。</p><p>YES 表示bars如果是不透明的话，那么也是会延伸的；</p><p>NO 表示bars在不透明的情况下是不延伸，只有半透明的时候才会延伸</p><p><code>translucent</code> 设置bars是否半透明（包括navigationBar 和 tabBar），默认是YES（半透明状态）</p><p>通过对上面属性定义的解释后，你是不是有点开始豁然开朗。以下是完整的逻辑图</p><img src="https://i.loli.net/2020/06/18/gKOoatvxbCWp62m.png" srcset="/img/loading.gif" alt="image-20200618143814120" style="zoom:50%;" /><h3 id="第三节：实际应用"><a href="#第三节：实际应用" class="headerlink" title="第三节：实际应用"></a><strong>第三节：实际应用</strong></h3><p>从上面的逻辑图，可以看出view.frame要实现全屏，或者在bars之间，都有两种方式</p><p><strong>全屏</strong></p><p>（1）同时设置以下参数</p><pre><code class="hljs objc">viewController.edgesForExtendedLaout =  <span class="hljs-built_in">UIRectEdageAll</span>；viewController.extendedLayoutIncludesOpaqueBars = <span class="hljs-literal">YES</span>;</code></pre><p>（2）同时设置以下参数</p><pre><code class="hljs objc">viewController.edgesForExtendedLaout =  <span class="hljs-built_in">UIRectEdageAll</span>；viewController.extendedLayoutIncludesOpaqueBars = <span class="hljs-literal">NO</span>;bars.translucent = <span class="hljs-literal">YES</span>;</code></pre><p><strong>bars之间</strong></p><p>（1）设置viewController.edgesForExtendedLaout = UIRectEdageNone;（PS：不建议这种做法）</p><p>（2）同时设置以下三个参数</p><pre><code class="hljs objc">viewController.edgesForExtendedLaout =  <span class="hljs-built_in">UIRectEdageAll</span>；viewController.extendedLayoutIncludesOpaqueBars = <span class="hljs-literal">NO</span>;bars.translucent = <span class="hljs-literal">NO</span>;</code></pre><p><strong>项目中的使用，建议使用以下的参数配置</strong>，理由：<br>（1）导航栏可能需要设置背景色，所以要将translucent的半透明关闭，否则会有一个白色的蒙层，并且navigationBar是全局公用一个，所以不见修改translucent的值，避免对其他的控制器造成莫名其妙的布局影响</p><p>（2）导航栏可能需要动态的变动，比如是隐藏或显示的切换，更多需求的是导航栏透明多的变化</p><pre><code class="hljs objc">viewController.edgesForExtendedLaout =  <span class="hljs-built_in">UIRectEdageAll</span>；（修改这个值来达到布局的效果）viewController.extendedLayoutIncludesOpaqueBars = <span class="hljs-literal">NO</span>;bars.translucent = <span class="hljs-literal">YES</span>;</code></pre><h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><p><strong>（1）该何时获取viewController.view.frame? 什么时候布局最合适了？</strong></p><p>viewController.view.bounds的值在生命周期不同阶段是不一样的，</p><p>viewDidLoad：bounds的size是手机设备全屏的尺寸</p><p>在view.frame在viewDidLoad（这时superView和window都是空的）和viewWillAppear（有superView,但window还是空的，并且AutoLayout是发生在viewWillAppear之后(来源于<a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="noopener">Casa大神文章</a>)）都是不准确的</p><p>在<code>viewWillLayoutSubviews</code>，<code>viewDidLayoutSubviews</code>和<code>viewDidAppear</code>中是准确的（尤其是设置了<code>translucent</code>和<code>edgesForExtendedLayout</code>）,但是<code>viewWillLayoutSubviews</code>、<code>viewDidLayoutSubviews</code>会被多次调用，<code>viewDidAppear</code>视图已经显示再去布局子控件会有刷新的效果，也是不合适的。</p><p>最后根据<a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="noopener">Casa大神文章</a>的建议：设置viewController.view的子视图的布局，应该在<code>viewWillLayoutSubviews</code>或者<code>viewDidLayoutSubviews</code>中比较合适，即使这两个方法会被多次调用，但都是页面需要调整的时候才会调用</p><p><strong>（2）translucent=YES的情况下，如何设置navigationBar的背景颜色，不会出现白色蒙层？</strong></p><pre><code class="hljs objc">[<span class="hljs-keyword">self</span>.navigationController.navigationBar setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageWithColor:[<span class="hljs-built_in">UIColor</span> colorWithHexString:<span class="hljs-string">@"#12B3B3"</span>]] forBarMetrics:<span class="hljs-built_in">UIBarMetricsDefault</span>];</code></pre>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>横屏竖屏，不再难</title>
    <link href="/2020/06/12/%E6%A8%AA%E5%B1%8F%E7%AB%96%E5%B1%8F%EF%BC%8C%E4%B8%8D%E5%86%8D%E9%9A%BE/"/>
    <url>/2020/06/12/%E6%A8%AA%E5%B1%8F%E7%AB%96%E5%B1%8F%EF%BC%8C%E4%B8%8D%E5%86%8D%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是实现AVPlayer边播放边缓存功能的番外篇，由于需要封装一个简单的播放器，肯定需要切换全屏和小屏，所有才有了这篇文章…</p><p>说实话横屏竖屏的切换，还真的没自己动过，都是使用第三方库播放器自带的功能，所以第一反应就是百度，但是看了许多文章，都没找到理想的方式，</p><p>我理想中的横屏</p><p>第一：<strong>避免过多的设置</strong></p><p>第二：<strong>无侵入式的添加</strong></p><p>第三：<strong>切换效果体验好</strong></p><p>第四：<strong>真横屏（如收到的推送消息也是横屏的），并且能够展示状态栏</strong></p><p>黑暗中的一束光，<a href="https://github.com/changsanjiang/SJVideoPlayer" target="_blank" rel="noopener">畅大神写的SJVideoPlayer</a>，应该是满足了绝大部分的短视频需求，并且体验很好，如果你是有涉及到播放器开发的话，建议多次阅读研究，肯定收益匪浅。</p><p><strong>本篇文章的目标是理清楚横竖屏切换的原理，并且抽离一个切换横竖屏的框架，可以快速的加入到项目中。</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="一、InterfaceOrientation-和-UIDeviceOrientation"><a href="#一、InterfaceOrientation-和-UIDeviceOrientation" class="headerlink" title="一、InterfaceOrientation 和 UIDeviceOrientation"></a>一、InterfaceOrientation 和 UIDeviceOrientation</h3><p>首先要明白两个概念：</p><p><code>InterfaceOrientation</code>用户界面方向：就是手机屏幕显示内容的方向，可以以状态栏为参考</p><pre><code class="hljs objc"><span class="hljs-comment">///获取方法（iOS 13.0 开始被丢弃了，暂未找到其他的替代方法）</span>[<span class="hljs-built_in">UIApplication</span> sharedApplication].statusBarOrientation</code></pre><p><code>UIDeviceOrientation</code>手机设备方向：手机硬件的方向，通常以home键为参考</p><pre><code class="hljs objc"><span class="hljs-comment">/// 获取方法</span>[<span class="hljs-built_in">UIDevice</span> currentDevice].orientation</code></pre><p><code>它们之间是什么关系了？</code></p><p>其实是两个互不相关的属性，但是大多数情况，两者会一起出现，主要是为了达到<code>视觉上的统一</code>。</p><p>比如：</p><p>手机方向锁定<img src="https://i.loli.net/2020/06/12/YHrxgNePnfiSM5C.jpg" srcset="/img/loading.gif" alt="8221591947013_.pic" style="zoom:18%;" />状态下，手机旋转，手机屏幕是不会改变的</p><p>如果是没锁定，则手机屏幕会跟随手机设备的方向旋转。</p><p><code>修改InterfaceOrientation用户界面的方向</code>，只能通过修改UIDeviceOrientation<code>间接</code>改变，是<code>被动</code>的改变，以达到视觉上的统一</p><p><code>修改UIDeviceOrientation方向有两种方式：</code></p><p>第一：手机自带的加速器</p><p>第二：通过KVC的方式代码修改UIDeviceOrientation的方向</p><pre><code class="hljs objc"><span class="hljs-comment">/// 首先要设置UIDeviceOrientationUnknown欺骗系统，避免可能出现设置无效的情况</span>[<span class="hljs-built_in">UIDevice</span>.currentDevice setValue:@(<span class="hljs-built_in">UIDeviceOrientationUnknown</span>) forKey:<span class="hljs-string">@"orientation"</span>];[<span class="hljs-built_in">UIDevice</span>.currentDevice setValue:@(orientation) forKey:<span class="hljs-string">@"orientation"</span>];</code></pre><h3 id="二、配置-勘误点1"><a href="#二、配置-勘误点1" class="headerlink" title="二、配置(勘误点1)"></a>二、配置(勘误点1)</h3><p>InterfaceOrientation的方向是被动改变了，只有UIDeviceOrientation改变了，才能间接地改变InterfaceOrientation的方向。</p><p>而InterfaceOrientation支持的方向可以通过下面三种方式设置（是同步的）</p><blockquote><p>tips：这一步很重要，因为这是全局的设置，并且UIDeviceOrientation旋转的时候会先调用这个方法，判断InterfaceOrientation是否支持，如果支持则继续走后面的逻辑，如果不支持则跳过，不改变InterfaceOrientation的方向</p></blockquote><p>第一：在info.plist列表中</p><p><img src="https://i.loli.net/2020/06/12/pPARc4iM6j1fVNa.png" srcset="/img/loading.gif" alt="image-20200612161510433"></p><p>第二：在General设置中</p><p><img src="https://i.loli.net/2020/06/12/pzJOoRlMZ59LTt3.png" srcset="/img/loading.gif" alt="image-20200612161555749"></p><p>第三：在Appdelegate中</p><pre><code class="hljs objc">- (<span class="hljs-built_in">UIInterfaceOrientationMask</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(<span class="hljs-built_in">UIWindow</span> *)window &#123;  <span class="hljs-comment">/// 通常设置这个值，去除UpsideDown的方向</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIInterfaceOrientationMaskAllButUpsideDown</span>;&#125;</code></pre><h3 id="三、ViewController单独设置"><a href="#三、ViewController单独设置" class="headerlink" title="三、ViewController单独设置"></a>三、ViewController单独设置</h3><p>以上配置是全局设置，对所有的ViewController都生效</p><p>但如果要单独设置某个ViewController的InterfaceOrientation方向，要设置以下三个方法</p><pre><code class="hljs objc"><span class="hljs-comment">/// Interface的方向是否会跟随设备方向自动旋转，如果返回NO，InterfaceOrientattion则保持不变，后面两个方法没有意义了</span><span class="hljs-comment">/// 默认值 YES</span>- (<span class="hljs-built_in">BOOL</span>)shouldAutorotate &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;&#125;<span class="hljs-comment">/// 返回当前ViewController支持的方向</span>- (<span class="hljs-built_in">UIInterfaceOrientationMask</span>)suppertedInterfaceOrientation &#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIInterfaceOrientationMaskAllButUpsideDown</span>;&#125;<span class="hljs-comment">//返回最优先显示的屏幕方向</span>- (<span class="hljs-built_in">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIInterfaceOrientationPortrait</span>;&#125;</code></pre><p>如果ViewController是window的rootViewController，则可以直接按上方的方式修改就可以</p><p>但如果ViewController是<code>UINavigationController</code>、<code>UITabBarController</code>的根视图，则还需重写以下方法（建议可以使用分类的方式重写）</p><pre><code class="hljs objc">#<span class="hljs-built_in">UINavigationController</span>- (<span class="hljs-built_in">BOOL</span>)shouldAutorotate &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.topViewController.shouldAutorotate;&#125;- (<span class="hljs-built_in">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.topViewController.supportedInterfaceOrientations;&#125;- (<span class="hljs-built_in">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.topViewController.preferredInterfaceOrientationForPresentation;&#125;#<span class="hljs-built_in">UITabBarController</span>- (<span class="hljs-built_in">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.selectedViewController.supportedInterfaceOrientations;&#125;- (<span class="hljs-built_in">BOOL</span>)shouldAutorotate &#123;    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.selectedViewController shouldAutorotate];&#125;- (<span class="hljs-built_in">UIInterfaceOrientation</span>)preferredInterfaceOrientationForPresentation &#123;    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.selectedViewController preferredInterfaceOrientationForPresentation];&#125;</code></pre><p>以上就是InterfaceOrientation是随着UIDeviceOrientation的改变而改变的逻辑，SJVideoPlayer库当中旋转也是基于此实现的</p><p><img src="https://i.loli.net/2020/06/12/HN5Po1kvVJ8hI3T.png" srcset="/img/loading.gif" alt="image-20200612172008669"></p><h3 id="四、SJVideoPlayer旋转原理"><a href="#四、SJVideoPlayer旋转原理" class="headerlink" title="四、SJVideoPlayer旋转原理"></a>四、SJVideoPlayer旋转原理</h3><p>SJVideoPlayer中的旋转是基于上面的逻辑外，而且为了避免个别界面添加全屏的功能，而对原有项目的修改大的问题，新建了一个UIWindow子类，比如FullScreenWindow，这就很巧妙了，让原来的Window保持不可旋转的属性，而通过新建的FullScreenWindow实现全屏的功能。这样做的好处，能将全屏的功能独立出来，而且不会影响原来Window中ViewController的其他子视图的布局，让其保持原来的竖屏布局，切换的时候过渡效果比较好。</p><p>（嘻嘻嘻嘻，多个Window的操作很溜，可以运用在多个方面。多个window可以并存的哦，并且切换简单）</p><p>以下是对SJVideoPlayer当中旋转模块SJRotationManager的解析（只对关键的代码解读，其余的忽略）</p><p><strong>第一步</strong>：点击全屏，触发修改UIDeviceOrientation方向的方法</p><p><img src="https://i.loli.net/2020/06/12/PdwNgjJ8x7yn5Yo.png" srcset="/img/loading.gif" alt="image-20200612174216489"></p><p><strong>第二步</strong>：判断是否支持自动旋转及支持的方向 (如果是支持自动旋转的，继续后面的操作，否则就结束，不旋转)</p><p><img src="https://i.loli.net/2020/06/12/AkdfHSBiQD5ZzFy.png" srcset="/img/loading.gif" alt="image-20200612174859862"></p><p><img src="https://i.loli.net/2020/06/12/phZQuWSwXxOL3qH.png" srcset="/img/loading.gif" alt="image-20200612174720571"></p><p><strong>第三步</strong>：将要全屏的View添加到新建的Window中</p><p><img src="https://i.loli.net/2020/06/12/4s6VnHeJDtv195X.png" srcset="/img/loading.gif" alt="image-20200612175544438"></p><p><img src="https://i.loli.net/2020/06/12/HQWjObiVPTDL92G.png" srcset="/img/loading.gif" alt="image-20200612175726422"></p><p><strong>第四步</strong>：完成旋转</p><p><img src="https://i.loli.net/2020/06/12/Ze67yvT4zxWSUBh.png" srcset="/img/loading.gif" alt="image-20200612180105380"></p><p>以上就是SJVideoPlayer全屏小屏的原理，是不是貌似很简单，(<del>~</del>[泪目])但是小编看了3天才整理出来，不容易，特耗神</p><h3 id="五、LERotationManager框架"><a href="#五、LERotationManager框架" class="headerlink" title="五、LERotationManager框架"></a>五、LERotationManager框架</h3><p>使用方法</p><p>（1）将LERotationManager拉入项目中</p><img src="https://i.loli.net/2020/06/15/xQy56CY97nkU2KW.png" srcset="/img/loading.gif" alt="image-20200615154701929" style="zoom: 33%;" /><p>（2）设置支持旋转的方向</p><p><img src="https://i.loli.net/2020/06/15/zZHMk9NCfsyW2Ar.png" srcset="/img/loading.gif" alt="image-20200615154829260"></p><p>或者在AppDelegate中设置（两个方法，选择其一就行）</p><pre><code class="hljs objc">- (<span class="hljs-built_in">UIInterfaceOrientationMask</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(<span class="hljs-built_in">UIWindow</span> *)window &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIInterfaceOrientationMaskAllButUpsideDown</span>;&#125;</code></pre><p>（3）创建RotationManager对象，并设置将要旋转的UIView</p><img src="https://i.loli.net/2020/06/15/5DNuWIQPvgAVaUB.png" srcset="/img/loading.gif" alt="image-20200615155142138" style="zoom:50%;" /><p>（4）触发rotate方法，实现横竖屏切换</p><h3 id="六、坑点"><a href="#六、坑点" class="headerlink" title="六、坑点"></a>六、坑点</h3><p><strong>（1）keyWindow iOS13 适配</strong></p><pre><code class="hljs objc"><span class="hljs-comment">/// 获取keyWindow</span>- (<span class="hljs-built_in">UIWindow</span> *)currentKeyWindow &#123;    <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">13.0</span>,*)) &#123;        <span class="hljs-built_in">UIWindow</span> *keyWindow = [<span class="hljs-built_in">UIApplication</span>.sharedApplication.windows objectAtIndex:<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> keyWindow;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIApplication</span>.sharedApplication.keyWindow;    &#125;&#125;</code></pre><p>这样写，是正确的写法，不过对于有些项目可能会出错，因为keyWindow并不是windows中的第0个，而是第1个，这是为什么了，是不是跟iOS13有关系？</p><p>解惑：这是因为有些人新建项目的时候没有将info.plist列表中的Main storyboard file base name置为空的同时，还在appdelegate方法中返回自定义的window，最终导致在windows中多了一个window。所以如果要在appdelegate中返回自定义的window，那么要将这个参数置为空</p><p><img src="https://i.loli.net/2020/06/15/kFY4j8NLgbmEJhT.png" srcset="/img/loading.gif" alt="image-20200615145518809"></p><h3 id="七、框架下载地址"><a href="#七、框架下载地址" class="headerlink" title="七、框架下载地址"></a>七、框架下载地址</h3><p><a href="https://github.com/CallLiven/LERotationManager" target="_blank" rel="noopener">CallMeLiven</a></p><p>如果喜欢的或者对你有一丝丝的帮助，请给个星星，谢谢</p><h3 id="八、勘误"><a href="#八、勘误" class="headerlink" title="八、勘误"></a>八、勘误</h3><p><strong>2020年06月16=======勘误1：第二节配置的勘误（很重要）</strong></p><p>上文提到设置InterfaceOrientation支持方向的三种方法是同步的，实质上会有所不同，</p><p>但是第一种info.plist和第二种General方法就是真的完全同步。</p><p>为什么说会有所不同了，主要是因为app启动的流程有关，会优先通过info.plist获取参数设置，再走appdelegate方法，因此三种设置的先后顺序是这样的：info.plis（和General）—&gt; appdelegate，所以最后InterfaceOrientation支持的方向是以appdelegate为准。</p><p><strong>那为什么要勘误这一点了？</strong></p><p>因为，当APP只需要在某个界面支持横屏的功能，其他界面都是竖屏的，</p><p>如果这个时候，你在info.plist中设置支持横竖屏，并且在appdelegate中也是设置支持横竖屏。</p><p>在手机<img src="https://i.loli.net/2020/06/12/YHrxgNePnfiSM5C.jpg" srcset="/img/loading.gif" alt="8221591947013_.pic" style="zoom:18%;" />锁屏的时候，那就没什么问题，打开app就是竖屏的，需要横屏的界面可以切换横屏；</p><p>当时如果手机没有锁屏，那么在手机设备横屏放置的时候，打开app则一开始是横屏的，导致不需要横屏的界面，变成默认成横屏的了。</p><p>解决的办法有两种：</p><pre><code class="hljs objc"><span class="hljs-comment">/// 第一种</span><span class="hljs-comment">/// 设置ViewController（设置viewController只支持竖屏，并且能主动旋转shouldAutorotate，否则无效）</span>- (<span class="hljs-built_in">BOOL</span>)shouldAutorotate &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;&#125;- (<span class="hljs-built_in">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIInterfaceOrientationMaskPortrait</span>;&#125;</code></pre><pre><code class="hljs objc"><span class="hljs-comment">/// 第二种（强烈推荐这种方式）</span><span class="hljs-comment">/// 设置info.plist或General中设置只支持竖屏，然后appdelegate设置同时支持横竖屏就可以了</span><span class="hljs-comment">/// 解释：像上面描述的，app启动会先通过info.plist和General的值设置设备的UIDeviceOrientation，因为只支持竖屏，也就是进入app，设备的方向是默认为竖屏，当然其他界面也是可以切换横竖屏的，因为最后支持的方向是由appdelegate返回的值相关</span></code></pre><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a href="https://www.jianshu.com/p/e473749f1c30" target="_blank" rel="noopener">iOS 屏幕旋转问题总结</a></p><p><a href="https://www.jianshu.com/p/6c45fa2bb970" target="_blank" rel="noopener">iOS强制改变物理设备方向的进阶方法</a></p><p><a href="http://www.cocoachina.com/articles/19808" target="_blank" rel="noopener">代码处理iOS的横竖屏旋转（上）</a></p><p><a href="http://www.cocoachina.com/articles/19829" target="_blank" rel="noopener">代码处理iOS的横竖屏旋转（下）</a></p><center class="half"> <div>感谢你“一分”支持</div>   <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media,Framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Bugly跟踪BUG</title>
    <link href="/2020/05/25/Bug%E8%B7%9F%E8%B8%AA/"/>
    <url>/2020/05/25/Bug%E8%B7%9F%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>BUG 是每一个开发人员不可避免要面对的问题，即使是经过了一轮又一轮的测试，最终发布到应用市场后，可能由于机型、系统、网络状况、用户操作习惯等原因会出现一些BUG，很难保证零BUG的代码，但是并不意味着允许BUG的大量存在，这对于我们的用户来说是灾难，随时可能会丢失这些用户，对于当前获客成本这么高的环境，要尽可能的减少。</p><p>当发生BUG后，如果能准确的定位到原因，就能避免下次的出现，所以出现本文如何追踪定位BUG</p><h2 id="二、-术语定义"><a href="#二、-术语定义" class="headerlink" title="二、 术语定义"></a>二、 术语定义</h2><blockquote><h4 id="1、什么是符号表？"><a href="#1、什么是符号表？" class="headerlink" title="1、什么是符号表？"></a>1、什么是符号表？</h4><p>符号表是内存地址与函数名、文件名、行号的<code>映射表</code>。</p><p>符号表元素如下所示：</p><p>&lt;起始地址&gt;&lt;结束地址&gt;&lt;函数&gt; [&lt;文件名：行号&gt;]</p></blockquote><blockquote><h4 id="2、什么是符号化"><a href="#2、什么是符号化" class="headerlink" title="2、什么是符号化"></a>2、什么是符号化</h4><p>为了能快速并准确定位用户app发送crash的代码位置，使用符号表可以对app发生的crash的程序堆栈进行<code>解析和还原</code>（简而言之就是’翻译‘，将十六进制的数字转换为易读的方法名和行数）</p></blockquote><blockquote><h4 id="3、什么是dSYM文件？"><a href="#3、什么是dSYM文件？" class="headerlink" title="3、什么是dSYM文件？"></a>3、什么是dSYM文件？</h4><p>iOS平台中，dSYM文件是指<code>具有调试信息</code>的目标文件，文件名通常为：xxx.app.dSYM。dSYM是一个文件目录，包含了上面提到的符号表</p></blockquote><blockquote><h4 id="4、如何获取dSYM文件？"><a href="#4、如何获取dSYM文件？" class="headerlink" title="4、如何获取dSYM文件？"></a>4、如何获取dSYM文件？</h4><p>（1）通过<code>Xcode</code>的Archive找回(PS:苹果官方也是推荐这种方式，所以每次构建版本的时候要都要保存)</p><p>打开Xcode顶部菜单栏—&gt;Window–&gt;Organizer窗口—选择Archives</p><p><img src="https://i.loli.net/2020/05/26/Y5lsSI42hfWVkbx.png" srcset="/img/loading.gif" alt="image-20200526140335577"></p><p><img src="https://i.loli.net/2020/05/26/rtoKsc3iqEdz1Oj.png" srcset="/img/loading.gif" alt="image-20200526140510387"></p><p><img src="https://i.loli.net/2020/05/26/yagEPCiBWJs4olL.png" srcset="/img/loading.gif" alt="image-20200526140543419"></p><p>（2）通过<code>iTunes Connect</code>找回</p><p>登录<a href="https://itunesconnect.apple.com" target="_blank" rel="noopener">iTunes Connect</a>，进入“我的App”的“活动”页面</p><p><img src="https://i.loli.net/2020/05/26/rGkVjmc32ABpxb9.png" srcset="/img/loading.gif" alt="image-20200526141119674"></p><p><img src="https://i.loli.net/2020/05/26/UEGiV3pbN8dFD6J.png" srcset="/img/loading.gif" alt="image-20200526141148251"></p><p>（3）使用<code>终端mdfind</code>命令找回</p><p>补充：每次构建版本都会有一个唯一的UUID与之相对应，即使是相同的代码构建，它创建的UUID也是不同的，并且前面提到的dSYM和.crash文件都是跟这个UUID相对应的。如果要完成.crash文件符号化，那么使用dSYM文件的UUID要和.crash文件的UUID一致才能符号化(具体如何查看.crash文件和dSYM文件的UUID请看下方)</p><pre><code class="hljs objc">mdfind <span class="hljs-string">"com_apple_xcode_dsym_uuids == &lt;UUID&gt;"</span></code></pre><p>注意：使用mdfind时，UUID需要转换格式(添加“-”间隔)： 12345678-1234-1234-1234-xxxxxxxxxxxx</p><p>比如.crash文件的UUID为：E30FC309DF7B3C9F8AC57F0F6047D65F，则输入的终端命令命令如下</p><pre><code class="hljs objc">mdfind <span class="hljs-string">"com_apple_xcode_dsym_uuids == E30FC309-DF7B-3C9F-8AC5-7F0F6047D65F"</span></code></pre></blockquote><blockquote><h4 id="5、如何获取crash文件？"><a href="#5、如何获取crash文件？" class="headerlink" title="5、如何获取crash文件？"></a>5、如何获取crash文件？</h4><p>（1）从<code>Xcode的崩溃管理器</code>，这种方式能直接查看到崩溃符号化后的信息，也就说能直接查看崩溃详情了，不需要进行其他操作。（PS：这种方式只适合于AppStore中发布的应用，并且<code>用户同意与开发人员共享崩溃信息</code>，或者通过TestFlight发布的内侧App，这种方式会自动与开发人员共享这些日志的，苹果推荐使用TestFlight也是有这部分的原因）<a href="https://help.apple.com/xcode/mac/current/#/dev861f46ea8" target="_blank" rel="noopener">官方文档</a></p><p>缺点：</p><p>a、这种方式会有时间差的问题，也就是发生崩溃到发送到崩溃管理器有一个时间差，最长可能一天</p><p>b、需要用户同意共享崩溃信息</p><p>打开Xcode顶部菜单栏—&gt;Window–&gt;Organizer窗口—选择Crashes</p><p><img src="https://i.loli.net/2020/05/26/UrRLQSzHcYhKd9g.png" srcset="/img/loading.gif" alt="image-20200526142940814"></p><p>(2) 使用<code>Xcode的Devices</code>工具，这种方式只适合手机连接电脑DEBUG的时候，也是可以直接查看符号化后的崩溃信息，不需要其他的操作</p><p>打开Xcode顶部菜单栏—&gt;Window–&gt;Devices and Simulators窗口—选择Devices</p><p><img src="https://i.loli.net/2020/05/26/vjwnzMrXu7gyaeS.png" srcset="/img/loading.gif" alt="image-20200526143633176"></p><p><img src="https://i.loli.net/2020/05/26/kfgEDlCJmFzZAaN.png" srcset="/img/loading.gif" alt="image-20200526143734537"></p><p>（3）用户通过设备<code>发送的崩溃信息文件</code></p><p><img src="https://i.loli.net/2020/05/26/w8nDmPqkU1FeHdg.png" srcset="/img/loading.gif" alt="image-20200526145451909"></p><p>分享的崩溃信息文件，是未符号化的信息，可以通过Xcode的Devices工具快速的符号化，前提是此app是通过这台电脑发布的</p><p>第一步：下载用户分享的崩溃信息文件，并且将文件后缀名改为.crash文件</p><p>第二步：打开Xcode的Devices工具，选择<code>View Device Logs</code></p><p>第三部：将.crash文件拉到左边的崩溃列表，需要稍等一段时间，如下图</p><p><img src="https://i.loli.net/2020/05/26/EFqN3ACkVxdaeZs.png" srcset="/img/loading.gif" alt="image-20200526150015656"></p><p>（4）集成<code>第三方SDK</code>获取（比如下方的Bugly）</p></blockquote><h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><p><img src="https://i.loli.net/2020/05/26/gvRBnbl8JNAGzDs.png" srcset="/img/loading.gif" alt="image-20200526113401471"></p><p>以上是苹果官方提供的崩溃报告和符号化的流程图(<a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION" target="_blank" rel="noopener">苹果官方说明地址</a>)，这里简单的描述一下：</p><p>当应用程序发生崩溃时，会创建崩溃日志并将其存储在设备上。崩溃日志描述了应用程序终止的条件，包含了每个执行线程的完整回溯(内存不足的崩溃是没有执行线程的完整回溯)，这对于调试程序的问题非常有帮助，崩溃日志的默认是十六进制的数字，需要<code>符号化</code>替换成易于理解的函数名称和行号。</p><p><strong>（1）</strong>当编译器将代码转换为机器代码时，会生成调试符号，这些调试符号将已编译二进制文件中的每一条机器指令映射回其源码代码。这些调试符号将存储在二进制文件或dSYM文件中，默认情况下，应用程序的debug版本将调试符号存储在已编译的二进制文件中，而Appstroe的release发布版本将调试符号存储在配套的dSYM文件中，已减少二进制文件的大小。</p><p>调试符号文件与应用程序二进制文件是通过UUID捆绑在一起的，应用程序的每一个构建版本都会生成一个新的UUID，并且是唯一的。即使使用相同的编译器设置从相同的源代码重建相同的可执行文件，它也将具有不同的构建UUID</p><p><strong>（2）</strong>当archive应用程序的时候，Xcode将会收集应用功能程序二进制文件以及.dSYM文件，并将它们存储在主文件夹内。可以在Xcode Organizer的”Archived”中找到已存档的应用程序。</p><p><strong>（3）</strong>如果通过AppStore发布应用程序，或者使用Test Flight 进行Beta测试，则dSYM会上传到iTunes Connect。上传dSYM文件是接收TextFlighty用户和选择共享开发数据的AppStore用户的崩溃报告所必须的</p><p><strong>（4）</strong>当应用程序发生崩溃时，会创建一个非符号化的报告并保存在设备上</p><p><strong>（5）</strong>用户可以已安装应用程序的设备上，直接导出崩溃信息文件。这是AdHoc或Enterprise企业App获取崩溃日志的唯一方法</p><p><strong>（6）</strong>从设备中导出的崩溃报告是没有符号化的，需要使用Xcode进行符号化</p><p><strong>（7）</strong>如果用户选择与Apple共享诊断数据，或者用户是通过TestFlight安装了Beta版本，那么崩溃日志会上传到AppStore</p><p><strong>（8）</strong>App Store 符号化崩溃报告，并将其与相似的崩溃报告进行分组</p><p><strong>（9）</strong>符号化的崩溃报告可在Xcode的崩溃管理器中查看</p><h2 id="四、跟踪BUG日志"><a href="#四、跟踪BUG日志" class="headerlink" title="四、跟踪BUG日志"></a>四、跟踪BUG日志</h2><p>推荐使用第三方的方式，会比较简单并且时效性好，并且除了可以查看崩溃日志，还附加了其他功能，比如数据统计等等，这对于App运营也是很有必须的</p><p>本人使用腾讯提供的<code>Bugly</code></p><p><img src="https://i.loli.net/2020/05/25/54GyZgxJusW6SBv.png" srcset="/img/loading.gif" alt="image-20200525173520662"></p><p><img src="https://i.loli.net/2020/05/25/RZMl8XPCn37cIHd.png" srcset="/img/loading.gif" alt="image-20200525173758754"></p><p><img src="https://i.loli.net/2020/05/25/unLgqtRxbHOBX3i.png" srcset="/img/loading.gif" alt="image-20200525173849874"></p><p>符号表工具<a href="https://bugly.qq.com/v2/downloads" target="_blank" rel="noopener">下载地址</a></p><p>dSYM符号表生成和上传</p><p>推荐使用mdfind找回dSYM文件，这样可以避免对比UUID是否一致的问题</p><p><strong>第一步：</strong>下载bugly的符号表工具：buglySymboliOS3</p><p><strong>第二步</strong>：找崩溃信息的UUID</p><p><img src="https://i.loli.net/2020/05/26/msIqSniDjCfd9Ty.png" srcset="/img/loading.gif" alt="image-20200526151636911"></p><p><strong>第三步：</strong>使用<code>终端mdfind</code>命令找到对应的UUID</p><p><strong>第四步：</strong>将第一步下载的buglySymboliOS3文件和第三部找的dSYM文件放在同一个文件夹，比如桌面的debug文件夹</p><p><strong>第五步：</strong></p><pre><code class="hljs objc">cd buglySymboliOS3目录java -jar buglySymboliOS.jar -i dSYM文件路径</code></pre><p>比如</p><p><img src="https://i.loli.net/2020/05/26/NChivP74OxUzsGw.png" srcset="/img/loading.gif" alt="image-20200526152251285"></p><p>运行后，debug文件夹会多了一个.zip的压缩文件</p><p><strong>第六步：</strong>上传zip文件（PS：上传需要bugly处理一段时间后，就能看到符号化的崩溃信息了）</p><p><img src="https://i.loli.net/2020/05/26/RXtH82U3LEQVN7g.png" srcset="/img/loading.gif" alt="image-20200526152529064"></p><p>时间仓促，如果有写的不对的地方，请各位多多指教！</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVPlayer边播放边缓存-02</title>
    <link href="/2020/05/22/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9802/"/>
    <url>/2020/05/22/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9802/</url>
    
    <content type="html"><![CDATA[<p><strong>边缓存边播放库：<a href="https://github.com/CallLiven/LEAVPlayerCache" target="_blank" rel="noopener">LEAVPlayerCache</a></strong></p><h1 id="续集"><a href="#续集" class="headerlink" title="续集"></a>续集</h1><p><a href="https://callliven.github.io/2020/05/19/AVPlayer边播放边缓存01/" target="_blank" rel="noopener">上文</a>完成了一个简单的自定义下载数据播放器，在这之后我们可以拿到下载的数据，接下来就是保存下载的数据，</p><p>既然要保存，首先就是要确定保存在什么位置，关于<a href="https://www.jianshu.com/p/b841ea19a8de" target="_blank" rel="noopener">苹果的沙盒</a>机制这里就不细聊了。</p><p>出于对短视频用户操作习惯的分析，对同一个视频，在不同时间，比如数小时之后，是不会再多次播放，也就是说我们做的缓存更多为了优化是以下的操作：</p><p>第一：观看短视频，会重播，可以直接读取上次的数据，避免流量浪费</p><p>第二：提高观看当前视频的流畅度</p><p>第三：切换视频，能更快播放</p><p>简而言之，视频文件是没有长时间保存在手机这么一个需求的，特别是说视频文件相对于其他文件，是比较大的。</p><p>最终我们是将视频及缓存文件保存在临时文件<code>tmp目录</code>下</p><p>创建一个CacheFileManager类用于管理缓存文件，这个类我是这么定义的，一个视频只对应一个CacheFileManager对象，便于管理一个视频多个下载的情况。</p><p>到这一步，由于是在上文中的第二种方式的基础上添加，就有点困难的，混乱中……对于整体架构没什么概念…单一职责…..工厂模式…..观察者模式……</p><p>当思索了许久都没有idea，则可以参考其他人的实现方式，这里推荐<a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA" target="_blank" rel="noopener">VIMediaCache</a>这篇文章，模块职责分得比较细，嵌套的有点多，所以要多看几次，方能了解原理（VIMediaCache第三方库，貌似还有点问题，本地已缓存整个视频的数据了，但是如果我关闭了网络，视频会出现播放不了的问题，并且经测试，在播放视频的时候，绝大部分数据依然是从线上拉取的。可能是我没搞清楚而出现这些疑问）</p><p><a href="https://sm.ms/image/LGARJkYIt3uUFre" target="_blank"><img src="https://i.loli.net/2020/05/27/LGARJkYIt3uUFre.png" srcset="/img/loading.gif" ></p></a><p>以上是初步的结构流程，虽不完整但是很关键。基于设计模式的单一职能，可以将上图划分2大模块，一个是缓存处理模块，一个是下载模块；而这两个对于视频资源URL和LoadingRequest对于关系是这样的，【<strong>关系公式</strong>】</p><p>（1）一个视频URL —— &gt; 若干个LoadingRequest</p><p>（2）一个视频URL ——–&gt; 一个缓存处理模块</p><p>（3）一个LoadingRequest ——–&gt; 一个下载模块</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>完整代码<a href="https://github.com/CallLiven/LEAVPlayerCache" target="_blank" rel="noopener">下载地址</a>，喜欢的老铁，给我个Start</p><p>对于分片下载，上文提到的方式二，更合适，因此本文是基于此做的优化</p><p>提示，上面提到的【关系公式】是理解的关键，也是封装划分的基础</p><p>首先视频URL和缓存模块是一一对应，而一个视频URL与LoadingRequest是一对多，并且下载模块跟LoadingRequest一一对应，这决定了对应模块创建的时机</p><p><strong>Loader：</strong>用于封装视频URL和缓存器</p><p><strong>Downloader:</strong> 用于封装下载和视频对应的多个LoadingRequests</p><h3 id="一、LEResourceLoaderManager"><a href="#一、LEResourceLoaderManager" class="headerlink" title="一、LEResourceLoaderManager"></a>一、LEResourceLoaderManager</h3><blockquote><p>实现AVAssetResourceLoaderDelegate代理</p></blockquote><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - AVAssetResourceLoaderDelegate</span>- (<span class="hljs-built_in">BOOL</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-built_in">NSURL</span> *resourceURL = loadingRequest.request.URL;    <span class="hljs-keyword">if</span> ([resourceURL.absoluteString hasPrefix:kCustomScheme]) &#123;        <span class="hljs-comment">// 获取原请求URL</span>        <span class="hljs-built_in">NSString</span> *originStr = [resourceURL.absoluteString stringByReplacingOccurrencesOfString:kCustomScheme withString:<span class="hljs-string">@""</span>];        <span class="hljs-built_in">NSURL</span> *originURL = [<span class="hljs-built_in">NSURL</span> URLWithString:originStr];                <span class="hljs-comment">// 一个视频对应一个Loader</span>        LEResourceLoader *loader = [<span class="hljs-keyword">self</span>.loaders objectForKey:originStr];        <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">nil</span>) &#123;            loader = [[LEResourceLoader alloc]initWithURL:originURL];            [<span class="hljs-keyword">self</span>.loaders setObject:loader forKey:originStr];        &#125;                <span class="hljs-comment">// 保存管理loadingRequest</span>        [loader addLoadingRequest:loadingRequest];        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;- (<span class="hljs-keyword">void</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    LEResourceLoader *loader = [<span class="hljs-keyword">self</span>.loaders objectForKey:[<span class="hljs-keyword">self</span> orginRequestURLStrWithLoadingRequest:loadingRequest]];    [loader removeLoadingRequest:loadingRequest];&#125;</code></pre><h3 id="二、LEResourceLoader"><a href="#二、LEResourceLoader" class="headerlink" title="二、LEResourceLoader"></a>二、LEResourceLoader</h3><blockquote><p>每一个loadingRequest 创建一个Downloader，但是同一个是视频URL的话，都是对应一个cacheManager</p></blockquote><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">LEResourceLoader</span>()</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURL</span> *originURL;<span class="hljs-comment">/* 下载模块 **/</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span>&lt;LERequestDowndloader *&gt; *downloaders;<span class="hljs-comment">/* 缓存模块 **/</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) LERequestCacheManager *cacheManager;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">LEResourceLoader</span></span><span class="hljs-comment">/// 初始化</span><span class="hljs-comment">/// @param url 不带customScheme的url</span>- (<span class="hljs-keyword">instancetype</span>)initWithURL:(<span class="hljs-built_in">NSURL</span> *)url &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        _originURL = url;        _downloaders = [<span class="hljs-built_in">NSMutableArray</span> array];        _cacheManager = [[LERequestCacheManager alloc]initWithRequestURL:url];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;<span class="hljs-comment">/// 添加loadingRequest</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>- (<span class="hljs-keyword">void</span>)addLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    LERequestDowndloader *downloader = [LERequestDowndloader startDownLoadWithLoadingRequest:loadingRequest cacheFielManager:_cacheManager];    [<span class="hljs-keyword">self</span>.downloaders addObject:downloader];&#125;<span class="hljs-comment">/// 移除loadingRequest</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>- (<span class="hljs-keyword">void</span>)removeLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"取消下载"</span>);    __block LERequestDowndloader *downloader = <span class="hljs-literal">nil</span>;    [<span class="hljs-keyword">self</span>.downloaders enumerateObjectsUsingBlock:^(LERequestDowndloader * _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;        <span class="hljs-keyword">if</span> (obj.loadingRequest == loadingRequest) &#123;            downloader = obj;            *stop = <span class="hljs-literal">YES</span>;        &#125;    &#125;];        <span class="hljs-keyword">if</span> (downloader) &#123;        [downloader cancle];        [<span class="hljs-keyword">self</span>.downloaders removeObject:downloader];    &#125;&#125;<span class="hljs-keyword">@end</span></code></pre><h3 id="三、LERequestDowndloader"><a href="#三、LERequestDowndloader" class="headerlink" title="三、LERequestDowndloader"></a>三、LERequestDowndloader</h3><blockquote><p>关键点是对比获取LoadingRequest的请求范围range与本地已缓存的范围，切分为若干的Local和Remote片段</p><p>如果是：local，则拼接data；</p><p>如果是：remote，则设置HTTPHeader的range，发起请求。</p><p><strong>除此之外</strong>，在<code>\- (void)processFragments</code>方法中要拿本地存储的资源描述信息填充到<code>contentInformationRequest</code>中，因为请求的数据本地都有，没有发起请求，那么就没填充了，所以这里一定要加上，并且是在拼接data之前</p></blockquote><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">LERequestDowndloader</span>()&lt;<span class="hljs-title">NSURLSessionDataDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *fragments;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURL</span> *requestURL;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  currentOffset;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">LERequestDowndloader</span></span><span class="hljs-comment">/// 开始下载</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>+ (<span class="hljs-keyword">instancetype</span>)startDownLoadWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest cacheFielManager:(LERequestCacheManager *)cacheManager &#123;    LERequestDowndloader *downer = [[LERequestDowndloader alloc]initWithLoadingRequest:loadingRequest cacheFielManager:cacheManager];    <span class="hljs-keyword">return</span> downer;&#125;- (<span class="hljs-keyword">instancetype</span>)initWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest cacheFielManager:(LERequestCacheManager *)cacheManager &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest = loadingRequest;        <span class="hljs-keyword">self</span>.cacheManager = cacheManager;        [<span class="hljs-keyword">self</span> configRequest];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;<span class="hljs-comment">/// 取消下载</span>- (<span class="hljs-keyword">void</span>)cancle &#123;    [<span class="hljs-keyword">self</span>.task cancel];    [<span class="hljs-keyword">self</span>.session invalidateAndCancel];&#125;<span class="hljs-comment">/// 发起请求</span>- (<span class="hljs-keyword">void</span>)configRequest &#123;    <span class="hljs-comment">// 获取请求范围</span>    <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest = <span class="hljs-keyword">self</span>.loadingRequest.dataRequest;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = dataRequest.requestedOffset;    <span class="hljs-built_in">NSInteger</span> length = dataRequest.requestedLength;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        offset = dataRequest.currentOffset;    &#125;        <span class="hljs-keyword">if</span> (dataRequest.requestsAllDataToEndOfResource) &#123;        length = <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength - offset;    &#125;        <span class="hljs-comment">// 根据range与本地缓存对比切分为若干个local和remote</span>    <span class="hljs-keyword">self</span>.fragments = [[<span class="hljs-keyword">self</span>.cacheManager calculateRangeForRange:<span class="hljs-built_in">NSMakeRange</span>(offset, length)] mutableCopy];    <span class="hljs-comment">// 原来的请求</span>    <span class="hljs-keyword">self</span>.requestURL = <span class="hljs-keyword">self</span>.cacheManager.url;    <span class="hljs-comment">// 处理fragments</span>    [<span class="hljs-keyword">self</span> processFragments];&#125;<span class="hljs-comment">/// 处理请求片段fragments</span>- (<span class="hljs-keyword">void</span>)processFragments &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.fragments.count &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.cacheManager.contentInfo &amp;&amp; <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength&gt;<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength;            <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentType;            <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="hljs-keyword">self</span>.cacheManager.contentInfo.byteRangeAccessSupported;        &#125;                LERequestFragment *fragment = <span class="hljs-keyword">self</span>.fragments.firstObject;        <span class="hljs-keyword">if</span> (fragment.modelType == RangeFragmentTypeLocal) &#123;            <span class="hljs-comment">// 本地缓存数据</span>            <span class="hljs-built_in">NSData</span> *cacheData = [<span class="hljs-keyword">self</span>.cacheManager cacheDataForRange:fragment.range error:<span class="hljs-literal">nil</span>];            <span class="hljs-keyword">self</span>.currentOffset = fragment.range.location + fragment.range.length;            [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:cacheData];            [<span class="hljs-keyword">self</span>.fragments removeObject:fragment];            [<span class="hljs-keyword">self</span> processFragments];        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">NSRange</span> fragmentRange = fragment.range;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = fragmentRange.location;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = fragmentRange.location + fragmentRange.length - <span class="hljs-number">1</span>;            <span class="hljs-comment">// 发起请求</span>            <span class="hljs-built_in">NSMutableURLRequest</span> *request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:<span class="hljs-keyword">self</span>.requestURL cachePolicy:<span class="hljs-built_in">NSURLRequestReloadIgnoringCacheData</span> timeoutInterval:<span class="hljs-number">20.0</span>];            <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"bytes=%lld-%lld"</span>,offset,endOffset];            [request setValue:range forHTTPHeaderField:<span class="hljs-string">@"Range"</span>];            <span class="hljs-keyword">self</span>.currentOffset = offset;            [<span class="hljs-keyword">self</span>.fragments removeObject:fragment];                        <span class="hljs-comment">// 开始下载</span>            <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];            [<span class="hljs-keyword">self</span>.task resume];        &#125;            &#125;<span class="hljs-keyword">else</span>&#123;        [<span class="hljs-keyword">self</span> cancle];        [<span class="hljs-keyword">self</span>.loadingRequest finishLoading];    &#125;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDataDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];        contentLength = [[[httpResponse.allHeaderFields[<span class="hljs-string">@"Content-Range"</span>] componentsSeparatedByString:<span class="hljs-string">@"/"</span>] lastObject] longLongValue];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentLength&gt;<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.cacheManager &amp;&amp; <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength = contentLength;        <span class="hljs-keyword">self</span>.cacheManager.contentInfo.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"总大小:%lld,请求视频片段大小：%f M"</span>,contentLength,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:data];    [<span class="hljs-keyword">self</span>.cacheManager writeData:data range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-keyword">self</span>.currentOffset, data.length) error:<span class="hljs-literal">nil</span>];    <span class="hljs-keyword">self</span>.currentOffset += data.length;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"已下载：%f M"</span>,<span class="hljs-keyword">self</span>.currentOffset/<span class="hljs-number">1024.0</span>/<span class="hljs-number">1024.0</span>);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    [<span class="hljs-keyword">self</span> processFragments];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><h3 id="四、LERequestCacheManager"><a href="#四、LERequestCacheManager" class="headerlink" title="四、LERequestCacheManager"></a>四、LERequestCacheManager</h3><blockquote><p>有一个难点：对于请求的range与本地缓存的fragment的对比，划分出请求的range当中有哪些是已缓存的，哪些是要发起请求下载的</p><p>此处是参考<a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA" target="_blank" rel="noopener">VIMediaCache</a>中的策略，先获取请求的range与本地的fragments是否有交集，如果有交集则再对比切分</p></blockquote><pre><code class="hljs objc"><span class="hljs-comment">/// 对比loadingRequest的请求范围与本地已缓存的情况，将range切割成若干的fragment</span>- (<span class="hljs-built_in">NSArray</span> &lt;LERequestFragment *&gt;*)calculateRangeForRange:(<span class="hljs-built_in">NSRange</span>)range &#123;    <span class="hljs-built_in">NSArray</span> *cachedFragments = [<span class="hljs-keyword">self</span>.contentInfo cachedDataRanges];    <span class="hljs-built_in">NSMutableArray</span> *resultFragments = [<span class="hljs-built_in">NSMutableArray</span> array];    <span class="hljs-keyword">if</span> (range.length == <span class="hljs-number">0</span> || range.location == <span class="hljs-built_in">NSNotFound</span>) &#123;        <span class="hljs-keyword">return</span> [resultFragments <span class="hljs-keyword">copy</span>];    &#125;        <span class="hljs-built_in">NSInteger</span> endOffset = range.location + range.length;    [cachedFragments enumerateObjectsUsingBlock:^(<span class="hljs-built_in">NSString</span> *obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;        <span class="hljs-built_in">NSRange</span> cacheFragment = <span class="hljs-built_in">NSRangeFromString</span>(obj);        <span class="hljs-comment">// 求交集,有交集则表示range范围内有一部分本地是有缓存的</span>        <span class="hljs-built_in">NSRange</span> intersectionRange = <span class="hljs-built_in">NSIntersectionRange</span>(range, cacheFragment);        <span class="hljs-keyword">if</span> (intersectionRange.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">NSInteger</span> package = intersectionRange.length / kPackageLength;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i&lt;= package; i++) &#123;                <span class="hljs-built_in">NSInteger</span> offset = i * kPackageLength;                <span class="hljs-built_in">NSInteger</span> offsetLocation = intersectionRange.location + offset;                <span class="hljs-built_in">NSInteger</span> maxLocation = intersectionRange.location + intersectionRange.length;                <span class="hljs-built_in">NSInteger</span> length = (offsetLocation + kPackageLength) &gt; maxLocation ? (maxLocation - offsetLocation) : kPackageLength;                                LERequestFragment *fragment = [[LERequestFragment alloc]initWithModelType:RangeFragmentTypeLocal requestRange:<span class="hljs-built_in">NSMakeRange</span>(offsetLocation, length)];                [resultFragments addObject:fragment];            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cacheFragment.location &gt;= endOffset) &#123;            *stop = <span class="hljs-literal">YES</span>;        &#125;            &#125;];            <span class="hljs-keyword">if</span> (resultFragments.count == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 与本地缓存没有交集，表示请求的rang没有缓存数据，需要发起服务器请求获取数据</span>        LERequestFragment *fragment = [[LERequestFragment alloc]initWithModelType:RangeFragmentTypeRemote requestRange:range];        [resultFragments addObject:fragment];    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">NSMutableArray</span> *localRemoteFragments = [<span class="hljs-built_in">NSMutableArray</span> array];        [resultFragments enumerateObjectsUsingBlock:^(LERequestFragment *obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;            <span class="hljs-built_in">NSRange</span> fragmentRange = obj.range;            <span class="hljs-comment">// 最开端的片段</span>            <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (range.location &lt; fragmentRange.location) &#123;                    LERequestFragment *fragment = [LERequestFragment new];                    fragment.modelType = RangeFragmentTypeRemote;                    fragment.range = <span class="hljs-built_in">NSMakeRange</span>(range.location, fragmentRange.location - range.location);                    [localRemoteFragments addObject:fragment];                &#125;                                [localRemoteFragments addObject:obj];            &#125;            <span class="hljs-keyword">else</span> &#123;                LERequestFragment *lastFragment = [localRemoteFragments lastObject];                <span class="hljs-built_in">NSInteger</span> lastOffset = lastFragment.range.location + lastFragment.range.length;                <span class="hljs-keyword">if</span> (fragmentRange.location &gt; lastOffset) &#123;                    LERequestFragment *fragment = [LERequestFragment new];                    fragment.modelType = RangeFragmentTypeRemote;                    fragment.range = <span class="hljs-built_in">NSMakeRange</span>(lastOffset, fragmentRange.location - lastOffset);                    [localRemoteFragments addObject:fragment];                &#125;                [localRemoteFragments addObject:obj];            &#125;                                    <span class="hljs-comment">// 最尾端的片段</span>            <span class="hljs-keyword">if</span> (idx == resultFragments.count - <span class="hljs-number">1</span>) &#123;                <span class="hljs-built_in">NSInteger</span> localEndOffset = fragmentRange.location + fragmentRange.length;                <span class="hljs-keyword">if</span> (endOffset &gt; localEndOffset) &#123;                    LERequestFragment *fragment = [LERequestFragment new];                    fragment.modelType = RangeFragmentTypeRemote;                    fragment.range = <span class="hljs-built_in">NSMakeRange</span>(localEndOffset, endOffset - localEndOffset);                    [localRemoteFragments addObject:fragment];                &#125;            &#125;                    &#125;];                resultFragments = localRemoteFragments;    &#125;        <span class="hljs-keyword">return</span> [resultFragments <span class="hljs-keyword">copy</span>];&#125;</code></pre><h3 id="五、LERequestContentInfo"><a href="#五、LERequestContentInfo" class="headerlink" title="五、LERequestContentInfo"></a>五、LERequestContentInfo</h3><blockquote><p>归档，资源文件的描述信息，比如长度、文件格式、是否能分片下载、以及本地缓存的range片段</p><p>有个注意点就是NSRange数组在归档的时候，需要转换为NSString，而转为NSValue是没用的，</p><p>并且在解档的时候，需要表示解档对象的类型，否则会解档失败。本人在这里卡了一会，好不容易才知道原因</p></blockquote><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSCoding</span>- (<span class="hljs-keyword">void</span>)encodeWithCoder:(<span class="hljs-built_in">NSCoder</span> *)coder &#123;    [coder encodeInt64:<span class="hljs-keyword">self</span>.contentLength forKey:kContentLength];    [coder encodeBool:<span class="hljs-keyword">self</span>.byteRangeAccessSupported forKey:kByteRangeAccessSupported];    [coder encodeObject:<span class="hljs-keyword">self</span>.contentType forKey:kContentType];    [coder encodeObject:<span class="hljs-keyword">self</span>.fragmengs forKey:kFragments];&#125;<span class="hljs-comment">///  tips: （1）数组解档的时候，一定要用decodeObjectOfClass:forKey:的方法，确认解档的是数组，否则会解档失败</span><span class="hljs-comment">///      （2）NSRange 转化为NSValue 存放在数组中，解档也是会有问题的，所以这里是将NSRange转为NString</span>- (<span class="hljs-keyword">instancetype</span>)initWithCoder:(<span class="hljs-built_in">NSCoder</span> *)coder &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        _contentLength = [coder decodeInt64ForKey:kContentLength];        _contentType = [coder decodeObjectOfClass:<span class="hljs-built_in">NSString</span>.class forKey:kContentType];        _byteRangeAccessSupported = [coder decodeBoolForKey:kByteRangeAccessSupported];        _fragmengs = [coder decodeObjectOfClass:<span class="hljs-built_in">NSMutableArray</span>.class forKey:kFragments];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;</code></pre><h3 id="六：如何使用"><a href="#六：如何使用" class="headerlink" title="六：如何使用"></a>六：如何使用</h3><p>超级简单哦！只要使用LEResourceLoaderManager创建AVPlayerItem，就能实现边播边缓存。</p><p>提示：AVPlayer的<code>automaticallyWaitsToMinimizeStalling</code>属性一定要设置为YES，这样能在缓存尽可能少的数据时就能播放视频，否则可能要等到视频缓存完成了才播放视频</p><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayer</span> *player;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerLayer</span> *playerLayer;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVURLAsset</span> *urlAsset;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerItem</span> *playerItem;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) LEResourceLoaderManager *loaderManager;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;    [<span class="hljs-keyword">super</span> viewDidLoad];        <span class="hljs-keyword">self</span>.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> blackColor];        <span class="hljs-keyword">self</span>.loaderManager = [[LEResourceLoaderManager alloc]init];    <span class="hljs-comment">// URL</span>    <span class="hljs-built_in">NSString</span> *url = <span class="hljs-string">@"http://vfx.mtime.cn/Video/2019/03/18/mp4/190318231014076505.mp4"</span>;        <span class="hljs-comment">// PlayerItem</span>    _playerItem = [<span class="hljs-keyword">self</span>.loaderManager playerItemWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:url]];    [_playerItem addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@"status"</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];    <span class="hljs-comment">// Player</span>    _player = [[<span class="hljs-built_in">AVPlayer</span> alloc]initWithPlayerItem:<span class="hljs-keyword">self</span>.playerItem];        <span class="hljs-comment">// 决定音频是否马上开始播放的关键性参数！！！</span>    <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">10.0</span>, *)) &#123;        _player.automaticallyWaitsToMinimizeStalling = <span class="hljs-literal">NO</span>;    &#125;        <span class="hljs-comment">// PlayerLayer</span>    _playerLayer = [<span class="hljs-built_in">AVPlayerLayer</span> playerLayerWithPlayer:<span class="hljs-keyword">self</span>.player];    _playerLayer.videoGravity = <span class="hljs-built_in">AVLayerVideoGravityResizeAspect</span>;    _playerLayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.height);    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_playerLayer];        &#125;</code></pre><center class="half"> <div>感谢你“一分”支持</div>  <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVPlayer边播放边缓存-01</title>
    <link href="/2020/05/19/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9801/"/>
    <url>/2020/05/19/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9801/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>随着抖音的兴起，短视频是乎是每个app的标配，虽然以往开发的项目都有视频播放的功能，但都是集成第三方库的控件，直接使用的，对于avplayer的边播边缓存是如何实现不了解，趁着疫情宅在家里有空，研究一下，目标是自己也能封装一个播放器</p><p>分4篇文章</p><p>01 - 视频播放</p><p>02 - 视频分片下载</p><p>03 - 视频缓存</p><p>04 - 播放器封装</p><h1 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a>二、基本原理</h1><p>AVPlayer 没有提供API获取播放器下载的数据，所以无法直接获取缓存，但是可以通过设置AVAssetResourceLoader代理的方式，自己使用NSURLSession下载数据，再传给播放器播放，同时缓存在本地，下次播放的时候可以使用。</p><p>AVAssetResourceLoader 只有在AVURLAsset加载不能识别的URL资源的时候，才会回调代理方法，所以在初始化AVURLAsset的时候把目标视频URL地址的scheme替换成系统不能识别的schemen。</p><p><img src="https://i.loli.net/2020/05/19/BJWvbsLajEKHDFr.png" srcset="/img/loading.gif" alt="引用zltunes中的图片"></p><h4 id="（1）AVAssetResourceLoaderDelegate-代理有两个必须要实现的方法"><a href="#（1）AVAssetResourceLoaderDelegate-代理有两个必须要实现的方法" class="headerlink" title="（1）AVAssetResourceLoaderDelegate 代理有两个必须要实现的方法"></a>（1）AVAssetResourceLoaderDelegate 代理有两个必须要实现的方法</h4><p>要求加载资源的代理方法</p><p>返回YES，表示该代理类现在可以处理该请求，需要在这里保存loadingReques并开启下载数据的任务</p><p>下载回调中拿到响应数据后再对loadingRequest进行填充</p><p>如果返回NO，则表示当前代理不能处理，视频数据需要AVPlayer自己处理(但是之前视频URL的scheme被设置自定义的，所以AVPlayer不能识别，最后导致 AVPlayerItemStatusFailed)</p><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</code></pre><p>AVAssetResourceLoader取消了本次请求</p><p>把loadingRequest移除下载任务回调列表(停止填充数据)</p><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</code></pre><p>代理方法中<code>AVAssetResourceLoadingRequest</code>类非常关键，以下是该类常用的属性和方法</p><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSURLRequest</span> *request;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">AVAssetResourceLoadingContentInformationRequest</span> *contentInformationRequest;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest;- (<span class="hljs-keyword">void</span>)finishLoading;- (<span class="hljs-keyword">void</span>)finishLoadingWithError:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSError</span> *)error;</code></pre><p><code>request</code> 代表原始的请求，获取资源请求地址</p><p><code>contentInformationRequest</code> 播放资源相关的信息，比如资源格式contentType、资源长度大小contentLength、是否支持分片下载byteRangeAccessSupported等</p><p><code>dataRequest</code> 表示请求资源数据的范围。由于AVPlayer会触发分片下载的策略，也就是说一个视频资源可能对应多个AVAssetResourceLoadingRequest，可以从这个属性获取每个AVAssetResourceLoadingRequest请求数据的范围</p><p><code>- (void)finishLoading</code> 如果AVAssetResourceLoadingRequest要求下载的数据都下载完毕则调用此方法完成下载</p><p><code>- (void)finishLoadingWithError:(nullable NSError *)error;</code> 如果AVAssetResourceLoadingRequest对应的下载发生失败，则调用此方法</p><h4 id="（2）流程原理"><a href="#（2）流程原理" class="headerlink" title="（2）流程原理"></a>（2）流程原理</h4><p><img src="https://i.loli.net/2020/05/21/MPngKXNyshlxWLi.png" srcset="/img/loading.gif" alt="image-20200521141931947"></p><p>AVPlayer是分片式下载策略，可能会发起多个LoadingRequest请求，但触发下载的时候，会先发起一个Range为0~2的数据请求，获取视频资源的描述信息，比如文件类型、文件大小，这需要我们填充到<code>AVAssetResourceLoadingRequest</code>类中的<code>contentInformationRequest</code>属性，而获取到的data填充至<code>AVAssetResourceLoadingRequest</code>的<code>dataRequest</code>，<code>dataRequest</code>属性中有个方法可以接收增量连续的data数据:<code>- (void)respondWithData:(NSData *)data</code>，当<code>AVAssetResourceLoadingRequest</code>要求下载的数据都下载完毕，则调用<code>- (void)finishLoading</code>完成请求，并且AVPlayer会在调用<code>finishLoading</code>时判断接下来要怎么处理，比如视频文件类型是否支持、是否要发起下一个LoadingRequest等</p><h4 id="（3）重试机制"><a href="#（3）重试机制" class="headerlink" title="（3）重试机制"></a>（3）重试机制</h4><p>AVAssetResourceLoader在执行加载的时候，会时不时触发取消下载方法<code>\- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoa</code>，然后重新发起加载请求策略，如果下载了部分，重新发起的下载请求会从还没下载的部分开始。</p><h1 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h1><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>完整代码：链接:<a href="https://pan.baidu.com/s/1BR9MkKHxrk_T-mH5vV7NIQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1BR9MkKHxrk_T-mH5vV7NIQ</a>  密码:st0g</p><p><img src="https://i.loli.net/2020/05/21/p1Y4sXlwrFnbHx8.png" srcset="/img/loading.gif" alt="image-20200521134545223"></p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"ViewController.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;CoreServices/CoreServices.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kScheme @<span class="hljs-meta-string">"scheme"</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">AVAssetResourceLoaderDelegate</span>,<span class="hljs-title">NSURLSessionDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayer</span> *player;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerLayer</span> *playerLayer;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVURLAsset</span> *urlAsset;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerItem</span> *playerItem;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span>&lt;<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *&gt; *requestsArray;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSOperationQueue</span> *downloadQueue;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableData</span> *downloadData;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">BOOL</span>  byteRangeAccessSupported;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span>  contentLength;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>  ) <span class="hljs-built_in">NSString</span>  *contentType;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;    [<span class="hljs-keyword">super</span> viewDidLoad];        <span class="hljs-keyword">self</span>.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> blackColor];        _requestsArray = [<span class="hljs-built_in">NSMutableArray</span> array];    _downloadData = [<span class="hljs-built_in">NSMutableData</span> data];    <span class="hljs-comment">// URL</span>    <span class="hljs-built_in">NSString</span> *url = <span class="hljs-string">@"http://vfx.mtime.cn/Video/2019/03/18/mp4/190318231014076505.mp4"</span>;    <span class="hljs-built_in">NSURL</span> *videoURL = [<span class="hljs-built_in">NSURL</span> URLWithString:[kScheme stringByAppendingString:url]];        <span class="hljs-comment">// AVURLAsset</span>    _urlAsset = [<span class="hljs-built_in">AVURLAsset</span> URLAssetWithURL:videoURL options:<span class="hljs-literal">nil</span>];    [_urlAsset.resourceLoader setDelegate:<span class="hljs-keyword">self</span> queue:dispatch_get_main_queue()];    <span class="hljs-comment">// PlayerItem</span>    _playerItem = [<span class="hljs-built_in">AVPlayerItem</span> playerItemWithAsset:<span class="hljs-keyword">self</span>.urlAsset];    [_playerItem addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@"status"</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];    <span class="hljs-comment">// Player</span>    _player = [[<span class="hljs-built_in">AVPlayer</span> alloc]initWithPlayerItem:<span class="hljs-keyword">self</span>.playerItem];        <span class="hljs-comment">// PlayerLayer</span>    _playerLayer = [<span class="hljs-built_in">AVPlayerLayer</span> playerLayerWithPlayer:<span class="hljs-keyword">self</span>.player];    _playerLayer.videoGravity = <span class="hljs-built_in">AVLayerVideoGravityResizeAspect</span>;    _playerLayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.height);    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_playerLayer];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - AVAssetResourceLoaderDelegate</span><span class="hljs-comment">/// 要求加载资源的代理方法</span><span class="hljs-comment">/// 返回YES，表示该代理类现在可以处理该请求，需要在这里保存loadingReques并开启下载数据的任务</span><span class="hljs-comment">/// 下载回调中拿到响应数据后再对loadingRequest进行填充</span><span class="hljs-comment">/// 如果返回NO，则表示当前代理不能处理，视频数据需要AVPlayer自己处理(但是之前视频URL的scheme被设置自定义的，所以AVPlayer不能识别，最后导致 AVPlayerItemStatusFailed)</span>- (<span class="hljs-built_in">BOOL</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-built_in">NSString</span> *requestURL = loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([requestURL containsString:kScheme] &amp;&amp; ![_requestsArray containsObject:loadingRequest]) &#123;        [_requestsArray addObject:loadingRequest];                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.task == <span class="hljs-literal">nil</span>) &#123;            <span class="hljs-built_in">NSString</span> *orginURL = [requestURL stringByReplacingOccurrencesOfString:kScheme withString:<span class="hljs-string">@""</span>];            <span class="hljs-built_in">NSMutableURLRequest</span> *request = [[<span class="hljs-built_in">NSMutableURLRequest</span> alloc]initWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:orginURL] cachePolicy:(<span class="hljs-built_in">NSURLRequestUseProtocolCachePolicy</span>) timeoutInterval:<span class="hljs-number">20</span>];            <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];            [<span class="hljs-keyword">self</span>.task resume];        &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;<span class="hljs-comment">/// AVAssetResourceLoader取消了本次请求</span><span class="hljs-comment">/// 把loadingRequest移除下载任务回调列表(停止填充数据)</span>- (<span class="hljs-keyword">void</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    [_requestsArray removeObject:loadingRequest];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        <span class="hljs-keyword">self</span>.byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">self</span>.contentLength = response.expectedContentLength;    <span class="hljs-keyword">self</span>.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    <span class="hljs-comment">// 缓存下载的data</span>    [<span class="hljs-keyword">self</span>.downloadData appendData:data];    <span class="hljs-comment">// 拼接下载的data</span>    [<span class="hljs-keyword">self</span> processRequestData];        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"已下载：%f ，正在下载：%f"</span>,<span class="hljs-keyword">self</span>.downloadData.length/<span class="hljs-number">1024.0</span>,data.length/<span class="hljs-number">1024.0</span>);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - ProcessRequestData</span>- (<span class="hljs-keyword">void</span>)processRequestData &#123;    <span class="hljs-built_in">NSMutableArray</span> *requestCompleted = [<span class="hljs-built_in">NSMutableArray</span> array];    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *loadingRequest <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.requestsArray) &#123;        loadingRequest.contentInformationRequest.contentLength = <span class="hljs-keyword">self</span>.contentLength;        loadingRequest.contentInformationRequest.contentType = <span class="hljs-keyword">self</span>.contentType;        loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="hljs-keyword">self</span>.byteRangeAccessSupported;                <span class="hljs-built_in">BOOL</span> didRespondCompletely = [<span class="hljs-keyword">self</span> respondWithDataForRequest:loadingRequest.dataRequest];        <span class="hljs-keyword">if</span> (didRespondCompletely) &#123;            [requestCompleted addObject:loadingRequest];            [loadingRequest finishLoading];        &#125;    &#125;    [<span class="hljs-keyword">self</span>.requestsArray removeObjectsInArray:requestCompleted];&#125;<span class="hljs-comment">/// 判断loadingRequest要求下载的数据是否全部下载完毕</span><span class="hljs-comment">/// 以及将下载的数据data拼接到dataRequest当中</span><span class="hljs-comment">/// @param dataRequest dataRequest</span>- (<span class="hljs-built_in">BOOL</span>)respondWithDataForRequest:(<span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *)dataRequest &#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> startOffset = dataRequest.requestedOffset;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        startOffset = dataRequest.currentOffset;    &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.downloadData.length &lt; startOffset) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;    &#125;        <span class="hljs-built_in">NSUInteger</span> unreadBytes = <span class="hljs-keyword">self</span>.downloadData.length - startOffset;    <span class="hljs-built_in">NSUInteger</span> numberOfBytesToRespondWith = MIN(dataRequest.requestedLength, unreadBytes);        [dataRequest respondWithData:[<span class="hljs-keyword">self</span>.downloadData subdataWithRange:<span class="hljs-built_in">NSMakeRange</span>(startOffset, numberOfBytesToRespondWith)]];        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = startOffset + dataRequest.requestedLength;    <span class="hljs-built_in">BOOL</span> didResponsdComplete = <span class="hljs-keyword">self</span>.downloadData.length &gt;= endOffset;        <span class="hljs-keyword">return</span> didResponsdComplete;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - KVO</span>- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-keyword">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-keyword">id</span>&gt; *)change context:(<span class="hljs-keyword">void</span> *)context &#123;    <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-string">@"status"</span>]) &#123;        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">self</span>.playerItem.status) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusUnknown</span>: &#123;                <span class="hljs-comment">// 未知状态，不能播放</span>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusUnknown"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusReadyToPlay</span>: &#123;                <span class="hljs-comment">// 准备完毕，可以播放</span>                <span class="hljs-comment">// 此方法可以在视频未播放的时候，获取视频的总时长(备注：一定要在AVPlayer预加载状态status是AVPlayerItemStatusReadyToPlay才能获取)</span>                <span class="hljs-comment">// NSLog(@"total %f",CMTimeGetSeconds(self.playerItem.asset.duration));</span>                [<span class="hljs-keyword">self</span>.player play];                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusReadyToPlay"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusFailed</span>: &#123;                <span class="hljs-comment">// 加载失败，网络或者服务器出现问题</span>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusFailed"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>（PS：关于初始化NSURLSession请求会话的时候，设置<code>delegateQueue</code>代理回调线程的值，一定要设置成<code>主线程</code>，如果设置成其他自定义的operationQueue，AVPlayer会播放失败，这可能是在拼接数据及完成finishLoading的时候，AVPlayer会在当前线程刷新UI，所以必须设置在主线程完成）</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>完整代码：链接:<a href="https://pan.baidu.com/s/1C5JH6onUsmqgie1Loi1OgQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1C5JH6onUsmqgie1Loi1OgQ</a>  密码:rerp</p><p>这种方式是基于原理假想出来的，但是实际运行视频播放不出来，在完成第一个Range为0~2的loadingRequest请求后，提示<strong>AVPlayerItemStatusFailed</strong>错误，尝试了很久，一直都未能解决，百思不得其解。如果有其他同行知道原因的，麻烦在评论区留意，感谢</p><p><img src="https://i.loli.net/2020/05/21/spL4GkAVWXM38fJ.png" srcset="/img/loading.gif" alt="image-20200521140754935"></p><p>以下是RequestDownder的代码</p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"RequestDownder.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;MobileCoreServices/MobileCoreServices.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RequestDownder</span>()&lt;<span class="hljs-title">NSURLSessionDataDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RequestDownder</span></span><span class="hljs-comment">/// 开始下载</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>+ (<span class="hljs-keyword">instancetype</span>)startDownLoadWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    RequestDownder *downer = [[RequestDownder alloc]initWithLoadingRequest:loadingRequest];    <span class="hljs-keyword">return</span> downer;&#125;- (<span class="hljs-keyword">instancetype</span>)initWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest = loadingRequest;        [<span class="hljs-keyword">self</span> setup];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;- (<span class="hljs-keyword">void</span>)cancle &#123;    [<span class="hljs-keyword">self</span>.session invalidateAndCancel];&#125;<span class="hljs-comment">/// 发起请求</span>- (<span class="hljs-keyword">void</span>)setup  &#123;    <span class="hljs-comment">// 获取请求范围</span>    <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest = <span class="hljs-keyword">self</span>.loadingRequest.dataRequest;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = dataRequest.requestedOffset;    <span class="hljs-built_in">NSInteger</span> length = dataRequest.requestedLength;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        offset = dataRequest.currentOffset;    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = offset + length - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 获取请求连接URL</span>    <span class="hljs-built_in">NSString</span> *urlStr = <span class="hljs-keyword">self</span>.loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([urlStr hasPrefix:<span class="hljs-string">@"scheme"</span>]) &#123;       urlStr = [urlStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"scheme"</span> withString:<span class="hljs-string">@""</span>];    &#125;        <span class="hljs-comment">// 发起请求</span>    <span class="hljs-built_in">NSMutableURLRequest</span> *request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:urlStr] cachePolicy:<span class="hljs-built_in">NSURLRequestReloadIgnoringCacheData</span> timeoutInterval:<span class="hljs-number">20.0</span>];    <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"bytes=%lld-%lld"</span>,offset,endOffset];    [request setValue:range forHTTPHeaderField:<span class="hljs-string">@"Range"</span>];        <span class="hljs-comment">// 开始下载</span>    <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];    [<span class="hljs-keyword">self</span>.task resume];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDataDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = response.expectedContentLength;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];    &#125;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = response.MIMEType;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:data];&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d -- %d"</span>,<span class="hljs-keyword">self</span>.loadingRequest.isCancelled,<span class="hljs-keyword">self</span>.loadingRequest.isFinished);    [<span class="hljs-keyword">self</span>.loadingRequest finishLoading];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(requestDowner:didComplete:)]) &#123;        [<span class="hljs-keyword">self</span>.delegate requestDowner:<span class="hljs-keyword">self</span> didComplete:error];    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>突然心情开朗，终于知道第二种方式问题的关键点(测试代码下载地址：链接:<a href="https://pan.baidu.com/s/16hFRJaDgFJzj2IQadaW87w" target="_blank" rel="noopener">https://pan.baidu.com/s/16hFRJaDgFJzj2IQadaW87w</a>  密码:z0cw）</p><p>前面说的resourceLoader触发下载，会先发起一个range为0~2的request，来获取视频资源的详情，比如文件长度，接着就是将获取的文件详情填充至<code>contentInformationRequest</code>，到这为止是没有错的，但是，<code>contentInformationRequest</code>是相对于整个视频资源文件的，这非常关键，也就是说设置的文件格式、文件长度都是指整个文件，而并不是指每一个发起的<code>AVAssetResourceLoadingRequest</code>的长度。</p><p>所以在第二种方式中，由于每一个<code>AVAssetResourceLoadingRequest</code>单独发起一个request请求，并且设置request请求数据范围range值，所以获取到的文件长度是对应于当前请求范围range，并不是指整个文件的长度。因此才会在发起第一个<code>AVAssetResourceLoadingRequest</code>请求range为0~2后，就没有继续发起第二个<code>AVAssetResourceLoadingRequest</code>了，因为resourceLoader会判断整个视频资源已经下载完成了。</p><p>激动<del>~</del>终于知道原因了，可以继续往前走，太不容易了，每一个小细节都可能导致失败</p><p><strong>好了，问题来了，那要怎么分片下载，并且获取整个视频文件的长度？</strong></p><p>貌似很矛盾的一个问题，其实是文件长度的取的字段有问题，通过答应服务器响应的<code>NSURLResponse</code>如下图，使用，代码改为如下就能解决问题了</p><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];        contentLength = [[[httpResponse.allHeaderFields[<span class="hljs-string">@"Content-Range"</span>] componentsSeparatedByString:<span class="hljs-string">@"/"</span>] lastObject] longLongValue];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentLength&gt;<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;</code></pre><p><img src="https://i.loli.net/2020/05/22/jSz4NmBFy3TR8LV.png" srcset="/img/loading.gif" alt="image-20200522120244479"></p><p><strong>修改后完整的代码</strong></p><p>下载地址：链接:<a href="https://pan.baidu.com/s/1voLndB23xy8Jcggrf_fYCQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1voLndB23xy8Jcggrf_fYCQ</a>  密码:2kc2</p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"RequestDownder.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;MobileCoreServices/MobileCoreServices.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RequestDownder</span>()&lt;<span class="hljs-title">NSURLSessionDataDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RequestDownder</span></span><span class="hljs-comment">/// 开始下载</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>+ (<span class="hljs-keyword">instancetype</span>)startDownLoadWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    RequestDownder *downer = [[RequestDownder alloc]initWithLoadingRequest:loadingRequest];    <span class="hljs-keyword">return</span> downer;&#125;- (<span class="hljs-keyword">instancetype</span>)initWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest = loadingRequest;        [<span class="hljs-keyword">self</span> setup];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;- (<span class="hljs-keyword">void</span>)cancle &#123;    [<span class="hljs-keyword">self</span>.session invalidateAndCancel];&#125;<span class="hljs-comment">/// 发起请求</span>- (<span class="hljs-keyword">void</span>)setup  &#123;    <span class="hljs-comment">// 获取请求范围</span>    <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest = <span class="hljs-keyword">self</span>.loadingRequest.dataRequest;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = dataRequest.requestedOffset;    <span class="hljs-built_in">NSInteger</span> length = dataRequest.requestedLength;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        offset = dataRequest.currentOffset;    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = offset + length - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 获取请求连接URL</span>    <span class="hljs-built_in">NSString</span> *urlStr = <span class="hljs-keyword">self</span>.loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([urlStr hasPrefix:<span class="hljs-string">@"scheme"</span>]) &#123;       urlStr = [urlStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"scheme"</span> withString:<span class="hljs-string">@""</span>];    &#125;        <span class="hljs-comment">// 发起请求</span>    <span class="hljs-built_in">NSMutableURLRequest</span> *request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:urlStr] cachePolicy:<span class="hljs-built_in">NSURLRequestReloadIgnoringCacheData</span> timeoutInterval:<span class="hljs-number">20.0</span>];    <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"bytes=%lld-%lld"</span>,offset,endOffset];    [request setValue:range forHTTPHeaderField:<span class="hljs-string">@"Range"</span>];        <span class="hljs-comment">// 开始下载</span>    <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];    [<span class="hljs-keyword">self</span>.task resume];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDataDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];        contentLength = [[[httpResponse.allHeaderFields[<span class="hljs-string">@"Content-Range"</span>] componentsSeparatedByString:<span class="hljs-string">@"/"</span>] lastObject] longLongValue];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentLength&gt;<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:data];&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    [<span class="hljs-keyword">self</span>.loadingRequest finishLoading];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(requestDowner:didComplete:)]) &#123;        [<span class="hljs-keyword">self</span>.delegate requestDowner:<span class="hljs-keyword">self</span> didComplete:error];    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>到这为止，已经能完成一个通过自己自定义的下载，再将下载数据填充给AVPlayer播放器播放的例子，距离封装一个自己的播放器的路很有很远，继续前行…为自己加油</p><h1 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h1><p>1、 <a href="https://juejin.im/post/5cb69acbf265da03b4460955" target="_blank" rel="noopener">AVPlayer详解系列（一）参数设置</a></p><p>2、 <a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA?#%23" target="_blank" rel="noopener">可能是目前最好的 AVPlayer 音视频缓存方案</a></p><p>3、 <a href="https://zltunes.github.io/2019/04/23/avplayer-best-practice/" target="_blank" rel="noopener">AVPlayer 边下边播与最佳实践</a></p><p>4、  <a href="http://chuquan.me/2019/12/03/ios-avplayer-support-cache/" target="_blank" rel="noopener">iOS AVPlayer 视频缓存的设计与实现</a></p><p>5、  <a href="http://xferris.cn/avplayer_cache/" target="_blank" rel="noopener">AVPlayer初体验之边下边播与视频缓存</a></p><p>6、  <a href="https://juejin.im/post/5a1e94b7f265da4326529995" target="_blank" rel="noopener">唱吧 iOS 音视频缓存处理框架</a></p><p>7、  <a href="https://chenzhengying.com/html/iOS/ZYPlayer/ZYPlayer.html" target="_blank" rel="noopener">基于AVPlayer封装的播放器细节</a></p><p>8、  <a href="https://msching.github.io/blog/2016/05/24/audio-in-ios-9/" target="_blank" rel="noopener">iOS音频播放 (九)：边播边缓存</a></p><p>9、<a href="https://www.jianshu.com/p/c157476474f1" target="_blank" rel="noopener">基于AVPlayer实现边缓存边播放</a></p><p>PPT下载地址</p><p>链接:<a href="https://pan.baidu.com/s/1Jx88y25EmNu7SMpkVyTr4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1Jx88y25EmNu7SMpkVyTr4Q</a>  密码:8rt3</p><center class="half"> <div>感谢你的“一分”支持</div>  <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基本使用和封装教程看我的就可以了</title>
    <link href="/2020/05/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>赶在2019年春节放假前一天，发一最后一波文章，虽然有点凌乱，但绝对使用<br>大力我上一家公司是做即时聊天应用的，聊天功能不是走第三方的平台,如环信、网易云等，毕竟是应用的核心功能，所以还是掌握在自己手上比较靠谱(结果各种坑)，当然还没到自定义协议那一高层次，我们使用的WebSocket，所以比如socket发消息的保证、socket重连、UI搭建等等都是需要自己从零开始做起，其中少不了重要的一环：聊天记录和用户数据的保存。<br>铺垫这么久了，是时候回归我们今天要讨论的话题：数据库</p><p>项目数据库管理是使用常用的第三方框架：FMDB，今天只讲一些常用的sql语法和功能，具体的代码说明已经在代码注释写了…请看代码</p><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>, <span class="hljs-keyword">readwrite</span>) <span class="hljs-built_in">NSString</span> *fileName;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readwrite</span>) FMDatabase *db;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readwrite</span>) FMDatabaseQueue *queue;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;    [<span class="hljs-keyword">super</span> viewDidLoad];        <span class="hljs-comment">// 数据库路径</span>    <span class="hljs-built_in">NSString</span> *doc = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSDocumentDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) lastObject];    <span class="hljs-built_in">NSString</span> *fileName = [doc stringByAppendingPathComponent:<span class="hljs-string">@"student.db"</span>];    <span class="hljs-keyword">self</span>.fileName = fileName;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"====%@"</span>,fileName);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - touch</span>- (<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<span class="hljs-comment">//    [self insert];</span><span class="hljs-comment">//    [self update];</span><span class="hljs-comment">//    [self delete];</span><span class="hljs-comment">//    [self query];</span>    [<span class="hljs-keyword">self</span> dataBaseQueueAction];&#125;<span class="hljs-keyword">@end</span></code></pre><h1 id="1、数据库基本使用：增删改查"><a href="#1、数据库基本使用：增删改查" class="headerlink" title="1、数据库基本使用：增删改查"></a>1、数据库基本使用：增删改查</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - FMDB 增删改查</span>- (<span class="hljs-keyword">void</span>)baseUseDemo &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     三大类</span><span class="hljs-comment">     (1)FMDatabase</span><span class="hljs-comment">     一个FMDatabase对象就代表一个单独的SQLite数据库</span><span class="hljs-comment">     用来执行SQL语句</span><span class="hljs-comment">     (2)FMResultSet</span><span class="hljs-comment">     使用FMDatabase执行查询后的结果集</span><span class="hljs-comment">     (3)FMDatabaseQueue</span><span class="hljs-comment">     用于在多线程中执行多个查询或更新，它是线程安全的</span><span class="hljs-comment">     */</span>            <span class="hljs-comment">// 获得数据库</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">     有三种情况</span><span class="hljs-comment">     （1）具体文件路径</span><span class="hljs-comment">     　　如果不存在会自动创建</span><span class="hljs-comment">     （2）空字符串@""</span><span class="hljs-comment">     　　会在临时目录创建一个空的数据库</span><span class="hljs-comment">     　　当FMDatabase连接关闭时，数据库文件也被删除</span><span class="hljs-comment">     （3）nil</span><span class="hljs-comment">     　　会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</span><span class="hljs-comment">     */</span>    FMDatabase *db = [FMDatabase databaseWithPath:<span class="hljs-keyword">self</span>.fileName];        <span class="hljs-comment">// 打开数据库</span>    <span class="hljs-keyword">if</span> ([db open]) &#123;        <span class="hljs-built_in">NSString</span> *sqlString = <span class="hljs-string">@"CREATE TABLE IF NOT EXISTS t_student(id integer PRIMARY KEY AUTOINCREMENT,name text NOT NULL , age integer NOT NULL);"</span>;        <span class="hljs-built_in">BOOL</span> result = [db executeUpdate:sqlString];        <span class="hljs-keyword">if</span> (result) &#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"创表成功"</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"创表失败"</span>);        &#125;    &#125;        <span class="hljs-keyword">self</span>.db = db;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 数据库sql语句</span><span class="hljs-comment">// w3school sql 语句学习：http://www.w3school.com.cn/sql/sql_distinct.asp</span><span class="hljs-comment">/**</span><span class="hljs-comment"> 插入数据</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)insert &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-built_in">NSString</span> *name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"liven-%d"</span>,arc4random_uniform(<span class="hljs-number">100</span>)];        [<span class="hljs-keyword">self</span>.db executeUpdate:<span class="hljs-string">@"INSERT INTO t_student (name,age) VALUES (?,?)"</span>,name,@(arc4random_uniform(<span class="hljs-number">40</span>))];    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> 删除</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)delete &#123;    <span class="hljs-comment">// 清空数据库表的数据(这只是删除所有行的数据，并不会对表的结构、属性和索性有影响)</span>    <span class="hljs-comment">//（即使数据库没有这张表，删除也不会崩溃，只会报错）</span>    [<span class="hljs-keyword">self</span>.db executeUpdate:<span class="hljs-string">@"DELETE FROM t_student"</span>];        <span class="hljs-comment">// 删除某一行：DELETE FROM 表名称 WHERE 列名称 = 值</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> 更新</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)update &#123;    <span class="hljs-comment">// 公式：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</span>  [<span class="hljs-keyword">self</span>.db executeUpdate:<span class="hljs-string">@"UPDATE t_student SET age=? WHERE name='大力'"</span>,@(<span class="hljs-number">18</span>)];&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> 查询</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)query &#123;    FMResultSet *resultSet = [<span class="hljs-keyword">self</span>.db executeQuery:<span class="hljs-string">@"SELECT * FROM t_student"</span>];    <span class="hljs-keyword">while</span> ([resultSet next]) &#123;        <span class="hljs-keyword">int</span> ID = [resultSet intForColumn:<span class="hljs-string">@"id"</span>];        <span class="hljs-built_in">NSString</span> *name = [resultSet stringForColumn:<span class="hljs-string">@"name"</span>];        <span class="hljs-keyword">int</span> age = [resultSet intForColumn:<span class="hljs-string">@"age"</span>];        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d %@ %d"</span>,ID,name,age);    &#125;&#125;</code></pre><h1 id="2、批处理"><a href="#2、批处理" class="headerlink" title="2、批处理"></a>2、批处理</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 批处理</span>- (<span class="hljs-keyword">void</span>)lotOperation &#123;    <span class="hljs-built_in">NSString</span> *creatSqlString = <span class="hljs-string">@"CREATE TABLE IF NOT EXISTS t_person (id integer PRINARY KEY AUTOINCREMENT,name text NOT NULL, age integer NOT NULL, age integer NOT NULL);"</span>    <span class="hljs-string">@"CREATE TABLE IF NOT EXISTS t_student (id integer PRINARY KEY AUTOINCREMENT,name text NOT NULL, age integer NOT NULL, age integer NOT NULL);"</span>;    [<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        [db executeStatements:creatSqlString];    &#125;];&#125;</code></pre><h1 id="3、线程安全databaseQueue"><a href="#3、线程安全databaseQueue" class="headerlink" title="3、线程安全databaseQueue"></a>3、线程安全databaseQueue</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - dataBaseQueue线程安全</span>- (<span class="hljs-keyword">void</span>)dataBaseQueueAction &#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">      备注：</span><span class="hljs-comment">        1、FMDatabaseQueue初始化时已将数据库打开和关闭封装好了，所以操作时不需要单独调用FMDatabase的open和close方法</span><span class="hljs-comment">        2、FMDatabaseQueue是基于同步串行队列保证数据库访问的安全性，所以不能叠加使用，避免死锁</span><span class="hljs-comment">     */</span>        <span class="hljs-comment">// 获取数据库队列</span>    FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:<span class="hljs-keyword">self</span>.fileName];    [queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        <span class="hljs-built_in">BOOL</span> resutl = [db executeUpdate:<span class="hljs-string">@"CREATE TABLE IF NOT EXISTS t_person (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL);"</span>];        <span class="hljs-keyword">if</span> (resutl) &#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"创表成功"</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"创表失败"</span>);        &#125;    &#125;];    <span class="hljs-keyword">self</span>.queue = queue;        <span class="hljs-comment">// 插入数据</span>    [<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"wendingding"</span>,@(<span class="hljs-number">22</span>)];    &#125;];        <span class="hljs-comment">// 查询</span>    [<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        FMResultSet *resultSet = [db executeQuery:<span class="hljs-string">@"SELECT * FROM t_person"</span>];        <span class="hljs-keyword">while</span> ([resultSet next]) &#123;            <span class="hljs-keyword">int</span> ID = [resultSet intForColumn:<span class="hljs-string">@"id"</span>];            <span class="hljs-built_in">NSString</span> *name = [resultSet stringForColumn:<span class="hljs-string">@"name"</span>];            <span class="hljs-keyword">int</span> age = [resultSet intForColumn:<span class="hljs-string">@"age"</span>];            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d %@ %d"</span>,ID,name,age);        &#125;    &#125;];        <span class="hljs-comment">/*</span><span class="hljs-comment">     备注：</span><span class="hljs-comment">     https://stackoverflow.com/questions/15720272/when-to-close-sqlite-database-using-fmdb</span><span class="hljs-comment">     数据库不需频繁的切换open和close两种状态，否则会造成不小的性能损耗(如cpu使用率)，FMDB的作者也提到</span><span class="hljs-comment">     只有在需要更改数据库模式的时候才需要切换状态，即使是退到后台线程也是不需要关闭的，维持数据打开的状态就可以</span><span class="hljs-comment">     */</span>    &#125;</code></pre><h1 id="4、事务"><a href="#4、事务" class="headerlink" title="4、事务"></a>4、事务</h1><pre><code class="hljs objc"><span class="hljs-comment">// 事务:所有任务执行完成后才再将结果一次性提交到数据库</span><span class="hljs-comment">// 特点:要么全部成功，要么全部失败(如果中途出现问题，则会回滚)</span><span class="hljs-comment">// 注意：开启事务比不开事务的耗时更少</span>[<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;    <span class="hljs-comment">// 开启事务</span>    [db beginTransaction];    <span class="hljs-built_in">BOOL</span> first = [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"lucky"</span>,@(<span class="hljs-number">22</span>)];    <span class="hljs-built_in">BOOL</span> second = [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"james"</span>,@(<span class="hljs-number">22</span>)];    <span class="hljs-comment">// 如果其中一个失败，则结束，数据回滚</span>    <span class="hljs-keyword">if</span> (!first || !second) &#123;        [db rollback];        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-comment">// 提交事务</span>    [db commit];&#125;];<span class="hljs-comment">// 另外一种实现方式</span>[<span class="hljs-keyword">self</span>.queue inTransaction:^(FMDatabase * _Nonnull db, <span class="hljs-built_in">BOOL</span> * _Nonnull rollback) &#123;    <span class="hljs-built_in">BOOL</span> first = [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"wendi"</span>,@(<span class="hljs-number">22</span>)];    <span class="hljs-built_in">BOOL</span> second = [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"davi"</span>,@(<span class="hljs-number">22</span>)];    <span class="hljs-keyword">if</span> (!first || !second) &#123;        *rollback = <span class="hljs-literal">YES</span>;        <span class="hljs-keyword">return</span> ;    &#125;&#125;];</code></pre><h1 id="5、判断某张表是否存在"><a href="#5、判断某张表是否存在" class="headerlink" title="5、判断某张表是否存在"></a>5、判断某张表是否存在</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 判断某张表是否存在</span>- (<span class="hljs-keyword">void</span>)chectDatabaseTableExists &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     备注：</span><span class="hljs-comment">        sqlite中有一个内k建表sqlite_master,这个表中存储这个所有自建表的表名称等信息</span><span class="hljs-comment">        可以通过：select * from sqlite_master 查看这个内建表的所有记录</span><span class="hljs-comment">     </span><span class="hljs-comment">     </span><span class="hljs-comment">        引申：判断指定的表是否存在，可以用如下语句</span><span class="hljs-comment">        select count(*) from sqlite_master wheretype='table' and name='要查询的表名'</span><span class="hljs-comment">        如果查询结果大于0，表示该表存在于数据库中，否则不存在</span><span class="hljs-comment">     </span><span class="hljs-comment">        详情：</span><span class="hljs-comment">        https://blog.csdn.net/aflyeaglenku/article/details/50884837</span><span class="hljs-comment">     */</span>&#125;</code></pre><h1 id="6、检测字段是否存在-并且添加字段"><a href="#6、检测字段是否存在-并且添加字段" class="headerlink" title="6、检测字段是否存在(并且添加字段)"></a>6、检测字段是否存在(并且添加字段)</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 检测字段是否存在(并且添加字段)</span>- (<span class="hljs-keyword">void</span>)checkDatabaseColumn &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        sqlite中并没有直接删除列和重命名列名称的sql语句，但是可以使用下面的思路实现同样的效果</span><span class="hljs-comment">        1、新建一个新表(新表的字段除了要删除的字段外，其余的都要)</span><span class="hljs-comment">        2、将旧表的值copy到新表</span><span class="hljs-comment">        3、删除旧表</span><span class="hljs-comment">        4、重命名表表名</span><span class="hljs-comment">     </span><span class="hljs-comment">        详情：</span><span class="hljs-comment">        https://blog.csdn.net/aflyeaglenku/article/details/50884837</span><span class="hljs-comment">     */</span>        [<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        <span class="hljs-keyword">if</span> ([db columnExists:<span class="hljs-string">@"phone"</span> inTableWithName:<span class="hljs-string">@"t_person"</span>]) &#123;            <span class="hljs-comment">// 如果t_person表中存在phone这个字段，不需要操作</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">// 如果t_person表中不存在phone这个字段，插入列</span>            [db executeUpdate:<span class="hljs-string">@"ALTER TABLE t_person ADD phone text"</span>];        &#125;    &#125;];&#125;</code></pre><h1 id="7、表迁移"><a href="#7、表迁移" class="headerlink" title="7、表迁移"></a>7、表迁移</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 表迁移</span>- (<span class="hljs-keyword">void</span>)updateToNewTable &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     这功能主要是表设计结构变更的时候需要使用</span><span class="hljs-comment">     思路：</span><span class="hljs-comment">        重新创建一个表</span><span class="hljs-comment">        将旧表数据导入到新的表中</span><span class="hljs-comment">        删除旧表</span><span class="hljs-comment">     */</span>&#125;</code></pre><h1 id="8、多表联查-重点：此处先介绍左连、右连、内连的概念"><a href="#8、多表联查-重点：此处先介绍左连、右连、内连的概念" class="headerlink" title="8、多表联查(重点：此处先介绍左连、右连、内连的概念)"></a>8、多表联查(重点：此处先介绍左连、右连、内连的概念)</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 多表连查 join</span>- (<span class="hljs-keyword">void</span>)mulTable &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     左连接：左边有的，右边没有的为null</span><span class="hljs-comment">     右连接：左边没有的，右边有的为null</span><span class="hljs-comment">     内连接：显示左边右边共有的</span><span class="hljs-comment">     </span><span class="hljs-comment">     详情介绍：</span><span class="hljs-comment">     https://blog.csdn.net/wang0112233/article/details/78418698</span><span class="hljs-comment">     https://blog.csdn.net/plg17/article/details/78758593</span><span class="hljs-comment">     */</span>        <span class="hljs-comment">// 实例：比如有两个表A和B,联查条件A.a字段与B.b字段相同</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"select A.*,B.* from A left join B on(A.a = B.b)"</span>);&#125;</code></pre><h1 id="9、创建索引"><a href="#9、创建索引" class="headerlink" title="9、创建索引"></a>9、创建索引</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 创建索引(有索引后查找速度更快速)</span>- (<span class="hljs-keyword">void</span>)createIndex &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        备注：</span><span class="hljs-comment">        1、在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</span><span class="hljs-comment">        2、更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。</span><span class="hljs-comment">           因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引</span><span class="hljs-comment">     </span><span class="hljs-comment">        公式：CREATE INDEX index_name ON table_name (column_name)</span><span class="hljs-comment">        详情介绍：</span><span class="hljs-comment">        http://www.w3school.com.cn/sql/sql_create_index.asp</span><span class="hljs-comment">     */</span>        <span class="hljs-comment">// 实例：创建一个简单的索引，名为 "PersonIndex"，在 Person 表的 LastName 列：</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"CREATE INDEX PersonIndex ON Person(LastName)"</span>);&#125;</code></pre><h1 id="10、数据库的删除-清空"><a href="#10、数据库的删除-清空" class="headerlink" title="10、数据库的删除(清空)"></a>10、数据库的删除(清空)</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 数据库的删除(清空)</span>- (<span class="hljs-keyword">void</span>)clearTable &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        1、删除表(表的结构、属性以及索引也会被删除)</span><span class="hljs-comment">        DROP TABLE表名称</span><span class="hljs-comment">     </span><span class="hljs-comment">        2、删除数据库</span><span class="hljs-comment">        DROP DATABASE数据库名称</span><span class="hljs-comment">     </span><span class="hljs-comment">        3、清空表内的数据，但并不删除表本身</span><span class="hljs-comment">        TRUNCATE TABLE表名称</span><span class="hljs-comment">     </span><span class="hljs-comment">     */</span>&#125;</code></pre><h1 id="11、统计表的数据"><a href="#11、统计表的数据" class="headerlink" title="11、统计表的数据"></a>11、统计表的数据</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 统计表的数据</span>- (<span class="hljs-keyword">void</span>)tableCount &#123;        <span class="hljs-comment">// 统计某表（如Person）的数据量</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"SELECT COUNT(*) FROM Person"</span>);        <span class="hljs-comment">// 统计某表某列的数据量（如：Person中name的数量，备注：NULL不计入）</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"SELECT COUNT(name) FROM Person"</span>);&#125;</code></pre><h1 id="12、分页读取数据"><a href="#12、分页读取数据" class="headerlink" title="12、分页读取数据"></a>12、分页读取数据</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 分页读取数据</span>- (<span class="hljs-keyword">void</span>)pageData &#123;    <span class="hljs-comment">// 实例：分页获取表Person中数据，每页20条</span>    <span class="hljs-comment">// 从第0行开始获取 一次获取20条</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"SELECT * FROM Person LIMIT 0,20"</span>);    <span class="hljs-comment">// 从第21行开始获取 一次获取20条</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"SELECT * FROM Person LIMIT 20,20"</span>);    &#125;</code></pre><h1 id="13、数据写入和读出处理-如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理"><a href="#13、数据写入和读出处理-如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理" class="headerlink" title="13、数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)"></a>13、数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)</span>- (<span class="hljs-built_in">NSString</span> *)inDBReplaceStr:(<span class="hljs-built_in">NSString</span> *)inStr &#123;    <span class="hljs-built_in">NSString</span> *tempStr = inStr;    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/"</span> withString:<span class="hljs-string">@"//"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"'"</span> withString:<span class="hljs-string">@"''"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"["</span> withString:<span class="hljs-string">@"/["</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"]"</span> withString:<span class="hljs-string">@"/]"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"%"</span> withString:<span class="hljs-string">@"/%"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"&amp;"</span> withString:<span class="hljs-string">@"/&amp;"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"_"</span> withString:<span class="hljs-string">@"/_"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"("</span> withString:<span class="hljs-string">@"/("</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@")"</span> withString:<span class="hljs-string">@"/)"</span>];    <span class="hljs-keyword">return</span> tempStr;&#125;- (<span class="hljs-built_in">NSString</span> *)outDBReplaceStr:(<span class="hljs-built_in">NSString</span> *)outStr &#123;    <span class="hljs-built_in">NSString</span> *tempStr = outStr;    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"//"</span> withString:<span class="hljs-string">@"/"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"''"</span> withString:<span class="hljs-string">@"'"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/["</span> withString:<span class="hljs-string">@"["</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/]"</span> withString:<span class="hljs-string">@"]"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/%"</span> withString:<span class="hljs-string">@"%"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/&amp;"</span> withString:<span class="hljs-string">@"&amp;"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/_"</span> withString:<span class="hljs-string">@"_"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/("</span> withString:<span class="hljs-string">@"("</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/)"</span> withString:<span class="hljs-string">@")"</span>];    <span class="hljs-keyword">return</span> tempStr;&#125;</code></pre><h1 id="数据库的封装"><a href="#数据库的封装" class="headerlink" title="数据库的封装"></a>数据库的封装</h1><p><img src="https://i.loli.net/2020/05/18/MyLpRig83CkEv97.png" srcset="/img/loading.gif" alt="image-20200518155431105"></p><p><a href="https://pan.baidu.com/s/1aXkiPCs3ze4bdsbl6Qn2VA" target="_blank" rel="noopener">完整DEMO</a></p>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS脚本打包一学就会</title>
    <link href="/2020/05/14/iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E4%B8%80%E5%AD%A6%E5%B0%B1%E4%BC%9A/"/>
    <url>/2020/05/14/iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E4%B8%80%E5%AD%A6%E5%B0%B1%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>上篇文章提到的Jenkins打包，因为需要配置参数比较多，并且坑也比较多，要运行起来确实比较不容易，本人虽然是很早就有接触到Jenkins，但由于一直配置不成功，而放弃了。所以在此之前另寻路径，学了其他比较简单的自动化打包方式，比如Python和接下来要讲的shell脚本。</p><p>条条道路通罗马，不管哪种方式，能提高效率和解放双手的都可以。自动打包确实会比手动打包的快，操作简单，一句代码就解决。</p><p>这种方式对于小项目，比如我现在的公司来说，是够用得了，只有一个iOS开发人员，项目配置也比较简单，所以够用了。</p><p><strong>备注</strong>：使用前提==Xcode证书配置使用<code>自动获取</code>（Automatically manager signing）的方式,并且项目运行正常</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h4 id="第一步：下载脚本文件夹"><a href="#第一步：下载脚本文件夹" class="headerlink" title="第一步：下载脚本文件夹"></a>第一步：下载脚本文件夹</h4><p>链接:<a href="https://pan.baidu.com/s/1Sj19uzzzKu7TJdXMJ6smZw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Sj19uzzzKu7TJdXMJ6smZw</a>  密码:9buq</p><p>下载完成后，将文件夹拉到项目根目录中</p><p><img src="https://i.loli.net/2020/05/18/VxHuq5r7ikIE3OF.png" srcset="/img/loading.gif" alt="image-20200518103113243"></p><h4 id="第二步：配置脚本文件"><a href="#第二步：配置脚本文件" class="headerlink" title="第二步：配置脚本文件"></a>第二步：配置脚本文件</h4><p>（1）修改<code>debug_config.plist</code>文件</p><p><img src="https://i.loli.net/2020/05/18/tkrRLco8DHdjOIK.png" srcset="/img/loading.gif" alt="image-20200518101737159"></p><p>（2）修改<code>test.sh</code>文件配置</p><p>只需要修改头部几个变量的值，备注已注明</p><p><img src="https://i.loli.net/2020/05/18/caUnCg9yLwtKufA.png" srcset="/img/loading.gif" alt="image-20200518101916357"></p><h4 id="第三步：运行脚本"><a href="#第三步：运行脚本" class="headerlink" title="第三步：运行脚本"></a>第三步：运行脚本</h4><p>cd 项目目录下的debug文件夹</p><p>终端输入</p><pre><code class="hljs plain">bash -l test.sh</code></pre><h4 id="第四步：安静的等待脚本执行完成即可"><a href="#第四步：安静的等待脚本执行完成即可" class="headerlink" title="第四步：安静的等待脚本执行完成即可"></a>第四步：安静的等待脚本执行完成即可</h4><p><img src="https://i.loli.net/2020/05/18/Z62PQYgifw5HkB7.png" srcset="/img/loading.gif" alt="image-20200518102152874"></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins自动打包--从零开始</title>
    <link href="/2020/05/14/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85-Jenkins/"/>
    <url>/2020/05/14/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85-Jenkins/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Jenkins是基于Java开发的一种持续集成工具，支持自动化、部署、构建。</p><p>简而言之，对于开发者可以避免做重复并且耗时的事情，专注于代码的开发(测试的小姐姐就不用每次跟我要安装包)</p><p>篇幅较长，请耐心看完，本人亲测有效。</p><p>写文不容易，翻阅了多篇博客，构建失败将近50次，总结的文章，除了文字描述，也附上图片说明，方便阅读。</p><p>如果喜欢本文的，请打赏一分支持</p><h1 id="二、Jenkins安装"><a href="#二、Jenkins安装" class="headerlink" title="二、Jenkins安装"></a>二、Jenkins安装</h1><h4 id="2-0-java-SDK-安装"><a href="#2-0-java-SDK-安装" class="headerlink" title="2.0 java SDK 安装"></a>2.0 java SDK 安装</h4><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">下载地址</a>,双击完成安装</p><h4 id="2-1-安装方式："><a href="#2-1-安装方式：" class="headerlink" title="2.1 安装方式："></a>2.1 安装方式：</h4><p>(1)<a href="https://www.jenkins.io/zh/download/" target="_blank" rel="noopener">官网</a>下载最新版的Jenkins安装包pkg（<a href="">其他版本下载地址</a>）</p><p>双击安装包，按指导完成安装</p><p>(2)Homebrew工具下载</p><pre><code class="hljs plain">brew install jenkins</code></pre><h4 id="2-2-安装结束后，终端输入命令："><a href="#2-2-安装结束后，终端输入命令：" class="headerlink" title="2.2 安装结束后，终端输入命令："></a>2.2 安装结束后，终端输入命令：</h4><pre><code class="hljs plain">jenkins</code></pre><p>启动服务完毕后，在浏览器中打开<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><h4 id="2-3-根据提示路径打开initialAdminPassword文件，复制密码登录"><a href="#2-3-根据提示路径打开initialAdminPassword文件，复制密码登录" class="headerlink" title="2.3 根据提示路径打开initialAdminPassword文件，复制密码登录"></a>2.3 根据提示路径打开initialAdminPassword文件，复制密码登录</h4><p><img src="https://i.loli.net/2020/05/14/epd8L24Eho5QTY6.png" srcset="/img/loading.gif" alt="image-20200514175313623"></p><p>（PS：如果因为权限问题打不开initialAdminPassword文件，请先跳转目录第三：修复jenkins文件权限后再操作）</p><h4 id="2-4-安装推荐插件"><a href="#2-4-安装推荐插件" class="headerlink" title="2.4 安装推荐插件"></a>2.4 安装推荐插件</h4><p>备注：插件安装不一定会一次性全都安装成功，如果失败了，可以点击重试，如果重试还是有没安装成功的，则选择跳过，继续执行下一步，完成Jenkins的安装，因为插件可以在后续继续完成</p><p>(备注：如果Jenkins插件多次在线安装失败，可以先下载<a href="https://updates.jenkins-ci.org/download/plugins/" target="_blank" rel="noopener">插件</a>,下载成功后，在插件管理界面选择【高级】上传的方式安装)</p><p><img src="https://i.loli.net/2020/05/14/pW5wqIvCajTPlgR.png" srcset="/img/loading.gif" alt="image-20200514175232751"></p><p><img src="https://i.loli.net/2020/05/14/vtQ2SFZsNeVx1Kj.png" srcset="/img/loading.gif" alt="image-20200514175258436"></p><h4 id="2-5-设置管理账号"><a href="#2-5-设置管理账号" class="headerlink" title="2.5 设置管理账号"></a>2.5 设置管理账号</h4><p><img src="https://i.loli.net/2020/05/14/Y7lsWZN8Ldvkbae.png" srcset="/img/loading.gif" alt="image-20200514184912707"></p><h4 id="2-6-输入管理账号登录"><a href="#2-6-输入管理账号登录" class="headerlink" title="2.6 输入管理账号登录"></a>2.6 输入管理账号登录</h4><p><img src="https://i.loli.net/2020/05/15/eAvEiq63pkdagXu.png" srcset="/img/loading.gif" alt="image-20200515094050171"></p><h1 id="三、修改Jenkins文件访问权限"><a href="#三、修改Jenkins文件访问权限" class="headerlink" title="三、修改Jenkins文件访问权限"></a>三、修改Jenkins文件访问权限</h1><p>这一步很关键，会影响接下来操作出现莫名的失败，比如证书的配置、代码的拉取等</p><p>首先，安装好Jenkins之后，会默认在Mac登录用户系统中添加一个“Jenkins”的登陆用户，而在Jenkins的主目录文件夹及其子文件夹的访问权限都是只有Mac Jenkins登录用户能读写</p><p><img src="https://i.loli.net/2020/05/15/9J6pEIYFazLysc5.png" srcset="/img/loading.gif" alt="image-20200515101951144"></p><p>（1）停止Jenkins</p><pre><code class="hljs plain">sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p>（2）打开Jenkins配置文件</p><pre><code class="hljs plain">sudo vim &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p><img src="https://i.loli.net/2020/05/15/AQOZ19vUD86zcxI.png" srcset="/img/loading.gif" alt="image-20200515162016570"></p><p><img src="https://i.loli.net/2020/05/15/Q7oHyfUvtWAgmuX.png" srcset="/img/loading.gif" alt="image-20200515162124239"></p><p>（3）运行以下命令，使配置修改生效</p><pre><code class="hljs plain">sudo chown -R yyk:daemon &#x2F;Users&#x2F;Shared&#x2F;Jenkins&#x2F;sudo chown -R yyk:daemon &#x2F;var&#x2F;log&#x2F;jenkins&#x2F;</code></pre><p>（4）启动Jenkins，完成权限修改</p><pre><code class="hljs plain">sudo launchctl load &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p><img src="https://i.loli.net/2020/05/15/uLb8qFNJ215wo4g.png" srcset="/img/loading.gif" alt="image-20200515163217384"></p><h1 id="四、插件安装及配置"><a href="#四、插件安装及配置" class="headerlink" title="四、插件安装及配置"></a>四、插件安装及配置</h1><h4 id="4-0-打开管理界面"><a href="#4-0-打开管理界面" class="headerlink" title="4.0 打开管理界面"></a>4.0 打开管理界面</h4><p><img src="https://i.loli.net/2020/05/15/ILy63UZTptOeD5i.png" srcset="/img/loading.gif" alt="image-20200515094540316"></p><h4 id="4-1-打开插件管理"><a href="#4-1-打开插件管理" class="headerlink" title="4.1 打开插件管理"></a>4.1 打开插件管理</h4><p><img src="https://i.loli.net/2020/05/15/ulNab1tfmWABZG4.png" srcset="/img/loading.gif" alt="image-20200515094621266"></p><h4 id="4-2-安装插件"><a href="#4-2-安装插件" class="headerlink" title="4.2 安装插件"></a>4.2 安装插件</h4><p>有三个插件是必须额外安装：</p><p>(1) 代码管理插件Git</p><p>​    本人用的是码云Gitee管理代码，所以需要安装一个gitee插件</p><p>(2) 代码打包使用：XCode 插件</p><p>(3) 钥匙串及证书管理工具： Keychain and Provisioning Profiles Management</p><p><img src="https://i.loli.net/2020/05/15/RpCiXuOqMPJDeTZ.png" srcset="/img/loading.gif" alt="image-20200515095036236"></p><p><img src="https://i.loli.net/2020/05/15/k3xP6uAYOyNDdVS.png" srcset="/img/loading.gif" alt="image-20200515100234175"></p><p><img src="https://i.loli.net/2020/05/15/M7OJhuKa4Rvjtfc.png" srcset="/img/loading.gif" alt="image-20200515103305563"></p><h4 id="4-3-插件配置"><a href="#4-3-插件配置" class="headerlink" title="4.3 插件配置"></a>4.3 插件配置</h4><p><img src="https://i.loli.net/2020/05/15/Rq6mtnB7YTkgiCp.png" srcset="/img/loading.gif" alt="image-20200515112009897"></p><p>(1) 上传keychains 文件</p><p>keychains文件存放路径：<code>~/Library/Keychains</code></p><p><img src="https://i.loli.net/2020/05/15/IJ3LPUnbX9wQv6d.png" srcset="/img/loading.gif" alt="image-20200515112322044"></p><p>（2）Provisioning Profiles Directory Path 路径</p><p><code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code></p><p>（3）上传配置文件：Provisioning Profile</p><p>如果没有了，则登录<a href="https://developer.apple.com" target="_blank" rel="noopener">苹果开发网址</a>重新生成，只需要开发证书和生产证书</p><p>（4）配置完成的界面</p><p>备注：需要校验上传的开发证书和测试证书对应的UUID，在<code>Provisioning Profiles Directory Path</code>文件夹中是否存在，如果不存在也是会出现本文提到的<code>问题二</code></p><p><img src="https://i.loli.net/2020/05/15/Tg1JiLMfS89hHRA.png" srcset="/img/loading.gif" alt="image-20200515113355974"></p><p><strong>PS：如果项目是有用CocoPods，则需要修改系统配置</strong></p><p>终端输入</p><pre><code class="hljs plain">echo $PATH</code></pre><p>复制输出内容</p><p><img src="https://i.loli.net/2020/05/15/T2Eh6g7aGuLlXdv.png" srcset="/img/loading.gif" alt="image-20200515135717113"></p><p><img src="https://i.loli.net/2020/05/15/U5Cg1dVPOonDjy4.png" srcset="/img/loading.gif" alt="image-20200515135849747"></p><h1 id="五、新建任务"><a href="#五、新建任务" class="headerlink" title="五、新建任务"></a>五、新建任务</h1><h4 id="5-0-创建自由风格工程"><a href="#5-0-创建自由风格工程" class="headerlink" title="5.0 创建自由风格工程"></a>5.0 创建自由风格工程</h4><p><img src="https://i.loli.net/2020/05/15/cDEXgAT4PhemkR9.png" srcset="/img/loading.gif" alt="image-20200515114306575"></p><p><img src="https://i.loli.net/2020/05/15/Dh5uYBUHFQG6stV.png" srcset="/img/loading.gif" alt="image-20200515114411371"></p><h4 id="5-1-General-项配置"><a href="#5-1-General-项配置" class="headerlink" title="5.1 General 项配置"></a>5.1 General 项配置</h4><p><img src="https://i.loli.net/2020/05/15/RlpH5QLohaMeDjV.png" srcset="/img/loading.gif" alt="image-20200515114722913"></p><h4 id="5-2-源码管理"><a href="#5-2-源码管理" class="headerlink" title="5.2 源码管理"></a>5.2 源码管理</h4><p><img src="https://i.loli.net/2020/05/15/ayDpQMf4BiqUCAe.png" srcset="/img/loading.gif" alt="image-20200515115320879"></p><p>PS: ssh密钥生成命令</p><pre><code class="hljs plain">$ cat ~&#x2F;.ssh&#x2F;id_rsa</code></pre><p>复制密钥时一定要将<code>-----BEGIN RSA PRIVATE KEY-----</code>和<code>-----END RSA PRIVATE KEY-----</code>一起复制</p><p><img src="https://i.loli.net/2020/05/15/xgoGJylOtUDTFdu.png" srcset="/img/loading.gif" alt="image-20200515120011740"></p><p><img src="https://i.loli.net/2020/05/15/U5WoP1DXARaxdv7.png" srcset="/img/loading.gif" alt="image-20200515120347621"></p><p><img src="https://i.loli.net/2020/05/15/QgiTUVtj3qGExvB.png" srcset="/img/loading.gif" alt="image-20200515115446447"></p><h4 id="5-3-构建配置"><a href="#5-3-构建配置" class="headerlink" title="5.3 构建配置"></a>5.3 构建配置</h4><p>（1）添加<code>Execute shell</code> 和<code>Xcode</code></p><p><img src="https://i.loli.net/2020/05/15/V18cEzLuJkiOx2N.png" srcset="/img/loading.gif" alt="image-20200515120627317"></p><p>（2）添加shell代码</p><pre><code class="hljs plain">export LANG&#x3D;en_US.UTF-8export LANGUAGE&#x3D;en_US.UTF-8export LC_ALL&#x3D;en_US.UTF-8pod install</code></pre><p><img src="https://i.loli.net/2020/05/15/GeUxkSYn5Z8NyaV.png" srcset="/img/loading.gif" alt="image-20200515121053406"></p><p>（3）Xcode 设置</p><p><img src="https://i.loli.net/2020/05/15/FIVhd28qNHkPivS.png" srcset="/img/loading.gif" alt="image-20200515121332662"></p><blockquote><p>teamid 可以在钥匙串中找到对应的证书，其双括号内的字符串就是teamId</p><p><img src="https://i.loli.net/2020/05/15/xPdnr3DSUIobvCZ.png" srcset="/img/loading.gif" alt="image-20200515121248304"></p></blockquote><p><img src="https://i.loli.net/2020/05/15/QuqzBp1A4UgPWro.png" srcset="/img/loading.gif" alt="image-20200515122523325"></p><p><img src="https://i.loli.net/2020/05/15/5C2NReYgkyFoLmA.png" srcset="/img/loading.gif" alt="image-20200515122300749"></p><h4 id="5-4-Code-signing-amp-OS-X-keychain-options-配置"><a href="#5-4-Code-signing-amp-OS-X-keychain-options-配置" class="headerlink" title="5.4 Code signing &amp; OS X keychain options 配置"></a>5.4 Code signing &amp; OS X keychain options 配置</h4><p><img src="https://i.loli.net/2020/05/15/9LlGQPmUWynzZhg.png" srcset="/img/loading.gif" alt="image-20200515122958510"></p><h4 id="5-5-Advanced-Xcode-build-options-配置"><a href="#5-5-Advanced-Xcode-build-options-配置" class="headerlink" title="5.5 Advanced Xcode build options 配置"></a>5.5 Advanced Xcode build options 配置</h4><p><img src="https://i.loli.net/2020/05/15/eT2gsG1YRPNfV5X.png" srcset="/img/loading.gif" alt="image-20200515133436256"></p><h1 id="六、可能会遇到的问题"><a href="#六、可能会遇到的问题" class="headerlink" title="六、可能会遇到的问题"></a>六、可能会遇到的问题</h1><blockquote><p>问题一：FATAL:Failed to copy ….mobileprovision文件</p><p><img src="https://i.loli.net/2020/05/14/SGyoWFXNt48hPa7.png" srcset="/img/loading.gif" alt="image-20200514140913355"></p><p>解决方法</p><p><img src="https://i.loli.net/2020/05/14/AwOIsMch4iPfjoT.png" srcset="/img/loading.gif" alt="image-20200514141426735"></p><p><img src="https://i.loli.net/2020/05/14/OQo4XysuDTCNqWY.png" srcset="/img/loading.gif" alt="image-20200514141708063"></p></blockquote><blockquote><p>问题二：Execute Shell 脚本代码中的 Pod install 执行错误</p><p><img src="https://i.loli.net/2020/05/14/uULrbqH21W9tPB7.png" srcset="/img/loading.gif" alt="image-20200514141832527"></p><p>解决方法：</p><p>终端输入 echo $PATH</p><p>将输入的PATH值复制，然后到Jenkins的系统管理设置</p><p><img src="https://i.loli.net/2020/05/14/xrASPOGgeLVo6w8.png" srcset="/img/loading.gif" alt="image-20200514143727060"></p></blockquote><h1 id="七、待续"><a href="#七、待续" class="headerlink" title="七、待续"></a>七、待续</h1><p>至此我们实现可持续开发的第一步，自动化打包，除此之外还需要配置多个scheme，打出不同环境的安装包</p><p>比如测试妹纸需要一个SIT包，产品经理需要一个SIM包等等，因为我们总不能修改一下代码，提交一下，打一个包，再修改代码再提交再打包，这样的操作依然需要开发人员的配合，增添了不少的成本。</p><p>对此下一篇则会侧重点解决这个问题</p><pre><code class="hljs plain">DEV Development 研发环境SIT System Integrate Test 系统集成测试环境（内测）UAT User Acceptance Test 用户验收测试环境PET Performance Evaluation Test 性能评估测试环境（压测）SIM Simulation 高仿真环境&#x2F;预发布PRD&#x2F;PROD Production 正式&#x2F;生产环境</code></pre><h1 id="八、参考文章"><a href="#八、参考文章" class="headerlink" title="八、参考文章"></a>八、参考文章</h1><p><a href="http://paocai.site/2020/04/27/iOS%20最新Jenkins自动化打包配置完整教程/#&gid=1&pid=13" target="_blank" rel="noopener">iOS 最新Jenkins自动化打包配置完整教程</a></p><p><a href="https://www.jianshu.com/p/70e4335b0bd6" target="_blank" rel="noopener">Jenins自动打包</a></p><p><a href="https://www.jianshu.com/p/04b5fe2e8598" target="_blank" rel="noopener">Mac修改jenkins进程默认账户解决权限问题</a></p><p><a href="https://www.jianshu.com/p/5be50ee32450" target="_blank" rel="noopener">CocoaPods管理的项目配置Jenkins遇到的坑</a></p><p><a href="https://www.jianshu.com/p/8b2fc2da0466" target="_blank" rel="noopener">使用 Jenkins 持续集成 iOS 项目时碰到的一些问题</a></p><p><a href="https://www.jianshu.com/p/13e34671788f" target="_blank" rel="noopener">iOS使用Jenkins+Xcode+fir 搭建持续集成环境</a></p><p><a href="https://www.jietusoft.com/faq/detail/262.html" target="_blank" rel="noopener">苹果证书的介绍和申请教程</a></p><center class="half"> <div>感谢你“一分”支持</div>   <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Github 搭建博客完整版</title>
    <link href="/2020/04/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/04/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Hexo搭建"><a href="#一、Hexo搭建" class="headerlink" title="一、Hexo搭建"></a>一、Hexo搭建</h2><h3 id="1-0-环境准备-具体的参考百度文章"><a href="#1-0-环境准备-具体的参考百度文章" class="headerlink" title="1.0 环境准备(具体的参考百度文章)"></a>1.0 环境准备(具体的参考百度文章)</h3><p>a&gt; npm安装</p><p>b&gt; Git 安装</p><p>c&gt; node.js 安装（建议安装10.0以上版本）</p><h3 id="2-0-Hexo安装"><a href="#2-0-Hexo安装" class="headerlink" title="2.0 Hexo安装"></a>2.0 Hexo安装</h3><pre><code class="hljs plain">$ npm install -g hexo-cli</code></pre><p>可以输入hexo -v ，检查hexo是否安装成功</p><h3 id="3-0-搭建网站"><a href="#3-0-搭建网站" class="headerlink" title="3.0 搭建网站"></a>3.0 搭建网站</h3><h5 id="3-1-创建一个文件夹存放网站文件，比如在桌面中添加一个-Blog-文件夹"><a href="#3-1-创建一个文件夹存放网站文件，比如在桌面中添加一个-Blog-文件夹" class="headerlink" title="3.1 创建一个文件夹存放网站文件，比如在桌面中添加一个 Blog 文件夹"></a>3.1 创建一个文件夹存放网站文件，比如在桌面中添加一个 Blog 文件夹</h5><h5 id="3-2-初始化Blog文件夹（上个厕所再回来…）"><a href="#3-2-初始化Blog文件夹（上个厕所再回来…）" class="headerlink" title="3.2 初始化Blog文件夹（上个厕所再回来…）"></a>3.2 初始化Blog文件夹（上个厕所再回来…）</h5><pre><code class="hljs plain">hexo init</code></pre><p><img src="https://i.loli.net/2020/05/09/ABecuswPyQEt6kT.png" srcset="/img/loading.gif" alt="image-20200509150624387"></p><h5 id="3-3-安装所需要安装的组件"><a href="#3-3-安装所需要安装的组件" class="headerlink" title="3.3 安装所需要安装的组件"></a>3.3 安装所需要安装的组件</h5><pre><code class="hljs plain">npm install</code></pre><h5 id="3-4-生成静态文件"><a href="#3-4-生成静态文件" class="headerlink" title="3.4 生成静态文件"></a>3.4 生成静态文件</h5><pre><code class="hljs plain">hexo g</code></pre><h5 id="3-5-开启服务器，访问本地网址，体验hexo"><a href="#3-5-开启服务器，访问本地网址，体验hexo" class="headerlink" title="3.5 开启服务器，访问本地网址，体验hexo"></a>3.5 开启服务器，访问<a href="http://localhost:4000" target="_blank" rel="noopener">本地网址</a>，体验hexo</h5><pre><code class="hljs plain">hexo s</code></pre><p>这是一个激动人心的时刻，请高举92年的可乐，一起土嗨！！！！</p><p><img src="https://i.loli.net/2020/05/09/81OLJZCFreMfQ7R.png" srcset="/img/loading.gif" alt="image-20200509151727917"></p><p><em>提示：</em>如果界面无法跳转，可能是端口号被占用了，终端输入<code>ctrl + c</code> 停止服务器，接着输入 <code>hexo server -p 端口号</code> 来修改端口号</p><p><em>扩展：</em>Mac查看端口号是否被占用及释放</p><pre><code class="hljs plain">&#x2F;&#x2F; 查看使用端口号进程lsof -i:端口号&#x2F;&#x2F; 释放端口号kill 进程的PID&#x2F;&#x2F; 再次执行，查看无进程占用lsof -i:端口号</code></pre><h5 id="3-6-关联Github"><a href="#3-6-关联Github" class="headerlink" title="3.6 关联Github"></a>3.6 关联Github</h5><p>登录Github,创建库，比如本人的CallLiven.github.io，并复制https地址</p><p>（注意点是github.io的前缀一定要跟github的名称一致，否则登录网址会提示404错误，找不到对应的文件）</p><p><img src="https://i.loli.net/2020/05/09/8ErvzakRN6dsw1l.png" srcset="/img/loading.gif" alt="image-20200509152540582"></p><p>打开之前创建的<code>Blog</code>文件夹，打开<code>_config.yml</code>文件，在文件最底部编写以下内容</p><pre><code class="hljs plain"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy:  type: git  repo:  &lt;仓库地址&gt;  branch: master</code></pre><p>安装插件Git bash 将文章推到仓库</p><pre><code class="hljs plain">npm install hexo-deloper-git --save</code></pre><p>部署到远端服务器Github</p><pre><code class="hljs plain">hexo g (生成静态文件)hexo d （将本地数据部署到远端服务器）</code></pre><p>恭喜，已经成功了</p><p>浏览器直接打开：<a href="https://callliven.github.io" target="_blank" rel="noopener">https://callliven.github.io</a></p><h3 id="4-0-创建博客"><a href="#4-0-创建博客" class="headerlink" title="4.0 创建博客"></a>4.0 创建博客</h3><pre><code class="hljs plain">hexo new 文件标题</code></pre><p><img src="https://i.loli.net/2020/05/09/1oapDuFHGPSfRgB.png" srcset="/img/loading.gif" alt="image-20200509155650478"></p><p>根据路径打开md文件，开始编辑文章，比如大海啊大海，海大啊海大</p><h2 id="二、编辑博客推荐工具：Typora-下载地址"><a href="#二、编辑博客推荐工具：Typora-下载地址" class="headerlink" title="二、编辑博客推荐工具：Typora 下载地址"></a>二、编辑博客推荐工具：Typora <a href="https://www.typora.io" target="_blank" rel="noopener">下载地址</a></h2><p>PS：一定要安装最新版本的，因为最新版本的支持图床设置，也就是将拖拽的图片自动上传到设置好的服务上</p><p>(1) 上传工具：PicGo 下载地址</p><p>(2) 图床选择：SM.MS （特点：永久存储免费，图片链接支持https，可以删除上传的图片，但图片上传有限制：每张图片最大5M，每次最多上传10张）</p><h3 id="1-SM-MS注册"><a href="#1-SM-MS注册" class="headerlink" title="1.SM.MS注册"></a>1.SM.MS注册</h3><p><a href="https://sm.ms/login" target="_blank" rel="noopener">https://sm.ms/login</a></p><h3 id="2-生成token"><a href="#2-生成token" class="headerlink" title="2.生成token"></a>2.生成token</h3><p><a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">https://sm.ms/home/apitoken</a></p><h3 id="3-配置PicGo的SM-MS图床服务"><a href="#3-配置PicGo的SM-MS图床服务" class="headerlink" title="3.配置PicGo的SM.MS图床服务"></a>3.配置PicGo的SM.MS图床服务</h3><p>文件路径：~/.picgo/config.json</p><pre><code class="hljs plain">&#123;  &quot;picBed&quot;: &#123;    &quot;uploader&quot;: &quot;smms&quot;, &#x2F;&#x2F; 代表当前的默认上传图床为 SM.MS,    &quot;smms&quot;: &#123;      &quot;token&quot;: &quot;&quot; &#x2F;&#x2F; 从https:&#x2F;&#x2F;sm.ms&#x2F;home&#x2F;apitoken获取的token    &#125;  &#125;,  &quot;picgoPlugins&quot;: &#123;&#125; &#x2F;&#x2F; 为插件预留&#125;</code></pre><h3 id="4-修改Typora配置"><a href="#4-修改Typora配置" class="headerlink" title="4.修改Typora配置"></a>4.修改Typora配置</h3><p>偏好设置–&gt;图像</p><p><img src="https://i.loli.net/2020/05/08/9nfTSi5F47jcVoE.png" srcset="/img/loading.gif" alt="image-20200508175202269"></p><h3 id="5-编辑文章"><a href="#5-编辑文章" class="headerlink" title="5.编辑文章"></a>5.编辑文章</h3><p>完成以上操作就可以开始编辑文章，方式跟简书等博客是一样的</p><h2 id="三、更换主题"><a href="#三、更换主题" class="headerlink" title="三、更换主题"></a>三、更换主题</h2><p>我当前使用的主题是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid</a>,安装方法请参考界面所介绍的。(<a href="https://hexo.io/themes/" target="_blank" rel="noopener">更多主题选择</a>)</p><p>Fluid主题预览（风格简易大气，并且支持文章搜索、标签、分类、评论等等）</p><ol><li><p>下载主题包</p></li><li><p>将主题解压，并重命名为“fluid”</p></li><li><p>将主题包拖动“Blog”文件夹中的“themes”</p></li></ol><p><img src="https://i.loli.net/2020/05/09/zEn3GPj4gxXVWRw.png" srcset="/img/loading.gif" alt="image-20200509161029217"></p><ol start="4"><li>最后一步，修改hexo主题配置</li></ol><p><img src="https://i.loli.net/2020/05/09/vY6ZAIPQiGqMag7.png" srcset="/img/loading.gif" alt="image-20200509161241944"></p><h2 id="四、个性化功能-非必须的"><a href="#四、个性化功能-非必须的" class="headerlink" title="四、个性化功能(非必须的)"></a>四、个性化功能(非必须的)</h2><p>该主题支持的个性化功能，具体的都在<code>_config.yml</code>文件中都有教程，操作非常简单，此处只介绍添加评论和音乐的方法</p><h3 id="1-添加评论"><a href="#1-添加评论" class="headerlink" title="1. 添加评论"></a>1. 添加评论</h3><p>Fluid主题支持多种评论插件，此处选择<code>Valine</code>，因为我刚好有<a href="https://leancloud.cn" target="_blank" rel="noopener">Leancloud</a>账号，并且Valine不需要提供多种资料，比较简单</p><p><img src="https://i.loli.net/2020/05/11/PsGnZXDcqeTL2Ni.png" srcset="/img/loading.gif" alt="image-20200511151845391"></p><p><img src="https://i.loli.net/2020/05/11/1Zoes23wUP9gupr.png" srcset="/img/loading.gif" alt="image-20200511151734203"></p><h3 id="2-播放音乐"><a href="#2-播放音乐" class="headerlink" title="2. 播放音乐"></a>2. 播放音乐</h3><p>安装音乐播放器插件: <a href="https://aplayer.js.org" target="_blank" rel="noopener">音乐播放插件APlayer</a></p><pre><code class="hljs plain">cd 博客文件夹npm install aplayer --save</code></pre><p>修改配置文件 <code>_config.yml</code> (需要将mp3文件拉到博客文件夹中)</p><p><img src="https://i.loli.net/2020/05/11/QVRrAqEi8FyOkJw.png" srcset="/img/loading.gif" alt="image-20200511151228772"></p><h3 id="3-统计百度统计"><a href="#3-统计百度统计" class="headerlink" title="3.统计百度统计"></a>3.统计百度统计</h3><p>注册百度统计账号:<a href="https://tongji.baidu.com/sc-web/10000203072/home/site/index?from=3" target="_blank" rel="noopener">网址</a></p><p><img src="https://i.loli.net/2020/05/11/dEcX2NUipmMIlJz.png" srcset="/img/loading.gif" alt="image-20200511200825592"></p><p><img src="https://i.loli.net/2020/05/11/noBJX8NObVx12GU.png" srcset="/img/loading.gif" alt="image-20200511200840983"></p><p><img src="https://i.loli.net/2020/05/11/dBKwlPy2Le36DY5.png" srcset="/img/loading.gif" alt="image-20200511201033923"></p><p><img src="https://i.loli.net/2020/05/11/WEZuYoTLrkmgMSn.png" srcset="/img/loading.gif" alt="image-20200511201111996"></p><p>编辑根目录Blog下的<code>_config.yml</code>文件</p><p><img src="https://i.loli.net/2020/05/11/6kvT37Ne1ayjDSQ.png" srcset="/img/loading.gif" alt="image-20200511201330541"></p><p>重新生成静态文件及部署到github上，就可以了（每次修改内容，都需要重新生成静态文件，再部署git上）</p><pre><code class="hljs plain">hexo ghexo d</code></pre><p><img src="https://i.loli.net/2020/05/11/9fjyTMAwRBiuUZ6.png" srcset="/img/loading.gif" alt="image-20200511201511851"></p><h2 id="五、Typora-常用快捷键"><a href="#五、Typora-常用快捷键" class="headerlink" title="五、Typora 常用快捷键"></a>五、Typora 常用快捷键</h2><pre><code class="hljs plain">无序列表：输入-之后输入空格有序列表：输入数字+“.”之后输入空格任务列表：-[空格]空格 文字标题：ctrl+数字表格：ctrl+t生成目录：[TOC]按回车选中一整行：ctrl+l选中单词：ctrl+d选中相同格式的文字：ctrl+e跳转到文章开头：ctrl+home跳转到文章结尾：ctrl+end搜索：ctrl+f替换：ctrl+h引用：输入&gt;之后输入空格代码块：ctrl+alt+f加粗：ctrl+b倾斜：ctrl+i下划线：ctrl+u删除线：alt+shift+5插入图片：直接拖动到指定位置即可或者ctrl+shift+i插入链接：ctrl+k</code></pre><h2 id="六、参考文章："><a href="#六、参考文章：" class="headerlink" title="六、参考文章："></a>六、参考文章：</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><p><a href="https://doc.sm.ms/" target="_blank" rel="noopener">SM.MS API 文档</a></p><p><a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#默认配置文件" target="_blank" rel="noopener">PinGo-Core官方文档</a></p><p><a href="https://www.jianshu.com/p/7b8faf77d1af" target="_blank" rel="noopener">Hexo常用指令</a></p><p><a href="https://aplayer.js.org" target="_blank" rel="noopener">音乐播放插件APlayer</a></p><p><a href="https://leancloud.cn" target="_blank" rel="noopener">Leancloud第三方服务器</a></p><center class="half"> <div>感谢你“一分”支持</div>   <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
