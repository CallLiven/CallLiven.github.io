<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用Bugly跟踪BUG</title>
    <link href="/2020/05/25/Bug%E8%B7%9F%E8%B8%AA/"/>
    <url>/2020/05/25/Bug%E8%B7%9F%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>BUG 是每一个开发人员不可避免要面对的问题，即使是经过了一轮又一轮的测试，最终发布到应用市场后，可能由于机型、系统、网络状况、用户操作习惯等原因会出现一些BUG，很难保证零BUG的代码，但是并不意味着允许BUG的大量存在，这对于我们的用户来说是灾难，随时可能会丢失这些用户，对于当前获客成本这么高的环境，要尽可能的减少。</p><p>当发生BUG后，如果能准确的定位到原因，就能避免下次的出现，所以出现本文如何追踪定位BUG</p><h2 id="二、-术语定义"><a href="#二、-术语定义" class="headerlink" title="二、 术语定义"></a>二、 术语定义</h2><blockquote><h4 id="1、什么是符号表？"><a href="#1、什么是符号表？" class="headerlink" title="1、什么是符号表？"></a>1、什么是符号表？</h4><p>符号表是内存地址与函数名、文件名、行号的<code>映射表</code>。</p><p>符号表元素如下所示：</p><p>&lt;起始地址&gt;&lt;结束地址&gt;&lt;函数&gt; [&lt;文件名：行号&gt;]</p></blockquote><blockquote><h4 id="2、什么是符号化"><a href="#2、什么是符号化" class="headerlink" title="2、什么是符号化"></a>2、什么是符号化</h4><p>为了能快速并准确定位用户app发送crash的代码位置，使用符号表可以对app发生的crash的程序堆栈进行<code>解析和还原</code>（简而言之就是’翻译‘，将十六进制的数字转换为易读的方法名和行数）</p></blockquote><blockquote><h4 id="3、什么是dSYM文件？"><a href="#3、什么是dSYM文件？" class="headerlink" title="3、什么是dSYM文件？"></a>3、什么是dSYM文件？</h4><p>iOS平台中，dSYM文件是指<code>具有调试信息</code>的目标文件，文件名通常为：xxx.app.dSYM。dSYM是一个文件目录，包含了上面提到的符号表</p></blockquote><blockquote><h4 id="4、如何获取dSYM文件？"><a href="#4、如何获取dSYM文件？" class="headerlink" title="4、如何获取dSYM文件？"></a>4、如何获取dSYM文件？</h4><p>（1）通过<code>Xcode</code>的Archive找回(PS:苹果官方也是推荐这种方式，所以每次构建版本的时候要都要保存)</p><p>打开Xcode顶部菜单栏—&gt;Window–&gt;Organizer窗口—选择Archives</p><p><img src="https://i.loli.net/2020/05/26/Y5lsSI42hfWVkbx.png" srcset="/img/loading.gif" alt="image-20200526140335577"></p><p><img src="https://i.loli.net/2020/05/26/rtoKsc3iqEdz1Oj.png" srcset="/img/loading.gif" alt="image-20200526140510387"></p><p><img src="https://i.loli.net/2020/05/26/yagEPCiBWJs4olL.png" srcset="/img/loading.gif" alt="image-20200526140543419"></p><p>（2）通过<code>iTunes Connect</code>找回</p><p>登录<a href="https://itunesconnect.apple.com" target="_blank" rel="noopener">iTunes Connect</a>，进入“我的App”的“活动”页面</p><p><img src="https://i.loli.net/2020/05/26/rGkVjmc32ABpxb9.png" srcset="/img/loading.gif" alt="image-20200526141119674"></p><p><img src="https://i.loli.net/2020/05/26/UEGiV3pbN8dFD6J.png" srcset="/img/loading.gif" alt="image-20200526141148251"></p><p>（3）使用<code>终端mdfind</code>命令找回</p><p>补充：每次构建版本都会有一个唯一的UUID与之相对应，即使是相同的代码构建，它创建的UUID也是不同的，并且前面提到的dSYM和.crash文件都是跟这个UUID相对应的。如果要完成.crash文件符号化，那么使用dSYM文件的UUID要和.crash文件的UUID一致才能符号化(具体如何查看.crash文件和dSYM文件的UUID请看下方)</p><pre><code class="hljs objc">mdfind <span class="hljs-string">"com_apple_xcode_dsym_uuids == &lt;UUID&gt;"</span></code></pre><p>注意：使用mdfind时，UUID需要转换格式(添加“-”间隔)： 12345678-1234-1234-1234-xxxxxxxxxxxx</p><p>比如.crash文件的UUID为：E30FC309DF7B3C9F8AC57F0F6047D65F，则输入的终端命令命令如下</p><pre><code class="hljs objc">mdfind <span class="hljs-string">"com_apple_xcode_dsym_uuids == E30FC309-DF7B-3C9F-8AC5-7F0F6047D65F"</span></code></pre></blockquote><blockquote><h4 id="5、如何获取crash文件？"><a href="#5、如何获取crash文件？" class="headerlink" title="5、如何获取crash文件？"></a>5、如何获取crash文件？</h4><p>（1）从<code>Xcode的崩溃管理器</code>，这种方式能直接查看到崩溃符号化后的信息，也就说能直接查看崩溃详情了，不需要进行其他操作。（PS：这种方式只适合于AppStore中发布的应用，并且<code>用户同意与开发人员共享崩溃信息</code>，或者通过TestFlight发布的内侧App，这种方式会自动与开发人员共享这些日志的，苹果推荐使用TestFlight也是有这部分的原因）<a href="https://help.apple.com/xcode/mac/current/#/dev861f46ea8" target="_blank" rel="noopener">官方文档</a></p><p>缺点：</p><p>a、这种方式会有时间差的问题，也就是发生崩溃到发送到崩溃管理器有一个时间差，最长可能一天</p><p>b、需要用户同意共享崩溃信息</p><p>打开Xcode顶部菜单栏—&gt;Window–&gt;Organizer窗口—选择Crashes</p><p><img src="https://i.loli.net/2020/05/26/UrRLQSzHcYhKd9g.png" srcset="/img/loading.gif" alt="image-20200526142940814"></p><p>(2) 使用<code>Xcode的Devices</code>工具，这种方式只适合手机连接电脑DEBUG的时候，也是可以直接查看符号化后的崩溃信息，不需要其他的操作</p><p>打开Xcode顶部菜单栏—&gt;Window–&gt;Devices and Simulators窗口—选择Devices</p><p><img src="https://i.loli.net/2020/05/26/vjwnzMrXu7gyaeS.png" srcset="/img/loading.gif" alt="image-20200526143633176"></p><p><img src="https://i.loli.net/2020/05/26/kfgEDlCJmFzZAaN.png" srcset="/img/loading.gif" alt="image-20200526143734537"></p><p>（3）用户通过设备<code>发送的崩溃信息文件</code></p><p><img src="https://i.loli.net/2020/05/26/w8nDmPqkU1FeHdg.png" srcset="/img/loading.gif" alt="image-20200526145451909"></p><p>分享的崩溃信息文件，是未符号化的信息，可以通过Xcode的Devices工具快速的符号化，前提是此app是通过这台电脑发布的</p><p>第一步：下载用户分享的崩溃信息文件，并且将文件后缀名改为.crash文件</p><p>第二步：打开Xcode的Devices工具，选择<code>View Device Logs</code></p><p>第三部：将.crash文件拉到左边的崩溃列表，需要稍等一段时间，如下图</p><p><img src="https://i.loli.net/2020/05/26/EFqN3ACkVxdaeZs.png" srcset="/img/loading.gif" alt="image-20200526150015656"></p><p>（4）集成<code>第三方SDK</code>获取（比如下方的Bugly）</p></blockquote><h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><p><img src="https://i.loli.net/2020/05/26/gvRBnbl8JNAGzDs.png" srcset="/img/loading.gif" alt="image-20200526113401471"></p><p>以上是苹果官方提供的崩溃报告和符号化的流程图(<a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION" target="_blank" rel="noopener">苹果官方说明地址</a>)，这里简单的描述一下：</p><p>当应用程序发生崩溃时，会创建崩溃日志并将其存储在设备上。崩溃日志描述了应用程序终止的条件，包含了每个执行线程的完整回溯(内存不足的崩溃是没有执行线程的完整回溯)，这对于调试程序的问题非常有帮助，崩溃日志的默认是十六进制的数字，需要<code>符号化</code>替换成易于理解的函数名称和行号。</p><p><strong>（1）</strong>当编译器将代码转换为机器代码时，会生成调试符号，这些调试符号将已编译二进制文件中的每一条机器指令映射回其源码代码。这些调试符号将存储在二进制文件或dSYM文件中，默认情况下，应用程序的debug版本将调试符号存储在已编译的二进制文件中，而Appstroe的release发布版本将调试符号存储在配套的dSYM文件中，已减少二进制文件的大小。</p><p>调试符号文件与应用程序二进制文件是通过UUID捆绑在一起的，应用程序的每一个构建版本都会生成一个新的UUID，并且是唯一的。即使使用相同的编译器设置从相同的源代码重建相同的可执行文件，它也将具有不同的构建UUID</p><p><strong>（2）</strong>当archive应用程序的时候，Xcode将会收集应用功能程序二进制文件以及.dSYM文件，并将它们存储在主文件夹内。可以在Xcode Organizer的”Archived”中找到已存档的应用程序。</p><p><strong>（3）</strong>如果通过AppStore发布应用程序，或者使用Test Flight 进行Beta测试，则dSYM会上传到iTunes Connect。上传dSYM文件是接收TextFlighty用户和选择共享开发数据的AppStore用户的崩溃报告所必须的</p><p><strong>（4）</strong>当应用程序发生崩溃时，会创建一个非符号化的报告并保存在设备上</p><p><strong>（5）</strong>用户可以已安装应用程序的设备上，直接导出崩溃信息文件。这是AdHoc或Enterprise企业App获取崩溃日志的唯一方法</p><p><strong>（6）</strong>从设备中导出的崩溃报告是没有符号化的，需要使用Xcode进行符号化</p><p><strong>（7）</strong>如果用户选择与Apple共享诊断数据，或者用户是通过TestFlight安装了Beta版本，那么崩溃日志会上传到AppStore</p><p><strong>（8）</strong>App Store 符号化崩溃报告，并将其与相似的崩溃报告进行分组</p><p><strong>（9）</strong>符号化的崩溃报告可在Xcode的崩溃管理器中查看</p><h2 id="四、跟踪BUG日志"><a href="#四、跟踪BUG日志" class="headerlink" title="四、跟踪BUG日志"></a>四、跟踪BUG日志</h2><p>推荐使用第三方的方式，会比较简单并且时效性好，并且除了可以查看崩溃日志，还附加了其他功能，比如数据统计等等，这对于App运营也是很有必须的</p><p>本人使用腾讯提供的<code>Bugly</code></p><p><img src="https://i.loli.net/2020/05/25/54GyZgxJusW6SBv.png" srcset="/img/loading.gif" alt="image-20200525173520662"></p><p><img src="https://i.loli.net/2020/05/25/RZMl8XPCn37cIHd.png" srcset="/img/loading.gif" alt="image-20200525173758754"></p><p><img src="https://i.loli.net/2020/05/25/unLgqtRxbHOBX3i.png" srcset="/img/loading.gif" alt="image-20200525173849874"></p><p>符号表工具<a href="https://bugly.qq.com/v2/downloads" target="_blank" rel="noopener">下载地址</a></p><p>dSYM符号表生成和上传</p><p>推荐使用mdfind找回dSYM文件，这样可以避免对比UUID是否一致的问题</p><p><strong>第一步：</strong>下载bugly的符号表工具：buglySymboliOS3</p><p><strong>第二步</strong>：找崩溃信息的UUID</p><p><img src="https://i.loli.net/2020/05/26/msIqSniDjCfd9Ty.png" srcset="/img/loading.gif" alt="image-20200526151636911"></p><p><strong>第三步：</strong>使用<code>终端mdfind</code>命令找到对应的UUID</p><p><strong>第四步：</strong>将第一步下载的buglySymboliOS3文件和第三部找的dSYM文件放在同一个文件夹，比如桌面的debug文件夹</p><p><strong>第五步：</strong></p><pre><code class="hljs objc">cd buglySymboliOS3目录java -jar buglySymboliOS.jar -i dSYM文件路径</code></pre><p>比如</p><p><img src="https://i.loli.net/2020/05/26/NChivP74OxUzsGw.png" srcset="/img/loading.gif" alt="image-20200526152251285"></p><p>运行后，debug文件夹会多了一个.zip的压缩文件</p><p><strong>第六步：</strong>上传zip文件（PS：上传需要bugly处理一段时间后，就能看到符号化的崩溃信息了）</p><p><img src="https://i.loli.net/2020/05/26/RXtH82U3LEQVN7g.png" srcset="/img/loading.gif" alt="image-20200526152529064"></p><p>时间仓促，如果有写的不对的地方，请各位多多指教！</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVPlayer边播放边缓存-02</title>
    <link href="/2020/05/22/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9802/"/>
    <url>/2020/05/22/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9802/</url>
    
    <content type="html"><![CDATA[<p><strong>边缓存边播放库：<a href="https://github.com/CallLiven/LEAVPlayerCache" target="_blank" rel="noopener">LEAVPlayerCache</a></strong></p><h1 id="续集"><a href="#续集" class="headerlink" title="续集"></a>续集</h1><p><a href="https://callliven.github.io/2020/05/19/AVPlayer边播放边缓存01/" target="_blank" rel="noopener">上文</a>完成了一个简单的自定义下载数据播放器，在这之后我们可以拿到下载的数据，接下来就是保存下载的数据，</p><p>既然要保存，首先就是要确定保存在什么位置，关于<a href="https://www.jianshu.com/p/b841ea19a8de" target="_blank" rel="noopener">苹果的沙盒</a>机制这里就不细聊了。</p><p>出于对短视频用户操作习惯的分析，对同一个视频，在不同时间，比如数小时之后，是不会再多次播放，也就是说我们做的缓存更多为了优化是以下的操作：</p><p>第一：观看短视频，会重播，可以直接读取上次的数据，避免流量浪费</p><p>第二：提高观看当前视频的流畅度</p><p>第三：切换视频，能更快播放</p><p>简而言之，视频文件是没有长时间保存在手机这么一个需求的，特别是说视频文件相对于其他文件，是比较大的。</p><p>最终我们是将视频及缓存文件保存在临时文件<code>tmp目录</code>下</p><p>创建一个CacheFileManager类用于管理缓存文件，这个类我是这么定义的，一个视频只对应一个CacheFileManager对象，便于管理一个视频多个下载的情况。</p><p>到这一步，由于是在上文中的第二种方式的基础上添加，就有点困难的，混乱中……对于整体架构没什么概念…单一职责…..工厂模式…..观察者模式……</p><p>当思索了许久都没有idea，则可以参考其他人的实现方式，这里推荐<a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA" target="_blank" rel="noopener">VIMediaCache</a>这篇文章，模块职责分得比较细，嵌套的有点多，所以要多看几次，方能了解原理（VIMediaCache第三方库，貌似还有点问题，本地已缓存整个视频的数据了，但是如果我关闭了网络，视频会出现播放不了的问题，并且经测试，在播放视频的时候，绝大部分数据依然是从线上拉取的。可能是我没搞清楚而出现这些疑问）</p><p><a href="https://sm.ms/image/LGARJkYIt3uUFre" target="_blank"><img src="https://i.loli.net/2020/05/27/LGARJkYIt3uUFre.png" srcset="/img/loading.gif" ></p></a><p>以上是初步的结构流程，虽不完整但是很关键。基于设计模式的单一职能，可以将上图划分2大模块，一个是缓存处理模块，一个是下载模块；而这两个对于视频资源URL和LoadingRequest对于关系是这样的，【<strong>关系公式</strong>】</p><p>（1）一个视频URL —— &gt; 若干个LoadingRequest</p><p>（2）一个视频URL ——–&gt; 一个缓存处理模块</p><p>（3）一个LoadingRequest ——–&gt; 一个下载模块</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>完整代码<a href="https://github.com/CallLiven/LEAVPlayerCache" target="_blank" rel="noopener">下载地址</a>，喜欢的老铁，给我个Start</p><p>对于分片下载，上文提到的方式二，更合适，因此本文是基于此做的优化</p><p>提示，上面提到的【关系公式】是理解的关键，也是封装划分的基础</p><p>首先视频URL和缓存模块是一一对应，而一个视频URL与LoadingRequest是一对多，并且下载模块跟LoadingRequest一一对应，这决定了对应模块创建的时机</p><p><strong>Loader：</strong>用于封装视频URL和缓存器</p><p><strong>Downloader:</strong> 用于封装下载和视频对应的多个LoadingRequests</p><h3 id="一、LEResourceLoaderManager"><a href="#一、LEResourceLoaderManager" class="headerlink" title="一、LEResourceLoaderManager"></a>一、LEResourceLoaderManager</h3><blockquote><p>实现AVAssetResourceLoaderDelegate代理</p></blockquote><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - AVAssetResourceLoaderDelegate</span>- (<span class="hljs-built_in">BOOL</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-built_in">NSURL</span> *resourceURL = loadingRequest.request.URL;    <span class="hljs-keyword">if</span> ([resourceURL.absoluteString hasPrefix:kCustomScheme]) &#123;        <span class="hljs-comment">// 获取原请求URL</span>        <span class="hljs-built_in">NSString</span> *originStr = [resourceURL.absoluteString stringByReplacingOccurrencesOfString:kCustomScheme withString:<span class="hljs-string">@""</span>];        <span class="hljs-built_in">NSURL</span> *originURL = [<span class="hljs-built_in">NSURL</span> URLWithString:originStr];                <span class="hljs-comment">// 一个视频对应一个Loader</span>        LEResourceLoader *loader = [<span class="hljs-keyword">self</span>.loaders objectForKey:originStr];        <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">nil</span>) &#123;            loader = [[LEResourceLoader alloc]initWithURL:originURL];            [<span class="hljs-keyword">self</span>.loaders setObject:loader forKey:originStr];        &#125;                <span class="hljs-comment">// 保存管理loadingRequest</span>        [loader addLoadingRequest:loadingRequest];        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;- (<span class="hljs-keyword">void</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    LEResourceLoader *loader = [<span class="hljs-keyword">self</span>.loaders objectForKey:[<span class="hljs-keyword">self</span> orginRequestURLStrWithLoadingRequest:loadingRequest]];    [loader removeLoadingRequest:loadingRequest];&#125;</code></pre><h3 id="二、LEResourceLoader"><a href="#二、LEResourceLoader" class="headerlink" title="二、LEResourceLoader"></a>二、LEResourceLoader</h3><blockquote><p>每一个loadingRequest 创建一个Downloader，但是同一个是视频URL的话，都是对应一个cacheManager</p></blockquote><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">LEResourceLoader</span>()</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURL</span> *originURL;<span class="hljs-comment">/* 下载模块 **/</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span>&lt;LERequestDowndloader *&gt; *downloaders;<span class="hljs-comment">/* 缓存模块 **/</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) LERequestCacheManager *cacheManager;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">LEResourceLoader</span></span><span class="hljs-comment">/// 初始化</span><span class="hljs-comment">/// @param url 不带customScheme的url</span>- (<span class="hljs-keyword">instancetype</span>)initWithURL:(<span class="hljs-built_in">NSURL</span> *)url &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        _originURL = url;        _downloaders = [<span class="hljs-built_in">NSMutableArray</span> array];        _cacheManager = [[LERequestCacheManager alloc]initWithRequestURL:url];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;<span class="hljs-comment">/// 添加loadingRequest</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>- (<span class="hljs-keyword">void</span>)addLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    LERequestDowndloader *downloader = [LERequestDowndloader startDownLoadWithLoadingRequest:loadingRequest cacheFielManager:_cacheManager];    [<span class="hljs-keyword">self</span>.downloaders addObject:downloader];&#125;<span class="hljs-comment">/// 移除loadingRequest</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>- (<span class="hljs-keyword">void</span>)removeLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"取消下载"</span>);    __block LERequestDowndloader *downloader = <span class="hljs-literal">nil</span>;    [<span class="hljs-keyword">self</span>.downloaders enumerateObjectsUsingBlock:^(LERequestDowndloader * _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;        <span class="hljs-keyword">if</span> (obj.loadingRequest == loadingRequest) &#123;            downloader = obj;            *stop = <span class="hljs-literal">YES</span>;        &#125;    &#125;];        <span class="hljs-keyword">if</span> (downloader) &#123;        [downloader cancle];        [<span class="hljs-keyword">self</span>.downloaders removeObject:downloader];    &#125;&#125;<span class="hljs-keyword">@end</span></code></pre><h3 id="三、LERequestDowndloader"><a href="#三、LERequestDowndloader" class="headerlink" title="三、LERequestDowndloader"></a>三、LERequestDowndloader</h3><blockquote><p>关键点是对比获取LoadingRequest的请求范围range与本地已缓存的范围，切分为若干的Local和Remote片段</p><p>如果是：local，则拼接data；</p><p>如果是：remote，则设置HTTPHeader的range，发起请求。</p><p><strong>除此之外</strong>，在<code>\- (void)processFragments</code>方法中要拿本地存储的资源描述信息填充到<code>contentInformationRequest</code>中，因为请求的数据本地都有，没有发起请求，那么就没填充了，所以这里一定要加上，并且是在拼接data之前</p></blockquote><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">LERequestDowndloader</span>()&lt;<span class="hljs-title">NSURLSessionDataDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *fragments;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURL</span> *requestURL;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  currentOffset;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">LERequestDowndloader</span></span><span class="hljs-comment">/// 开始下载</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>+ (<span class="hljs-keyword">instancetype</span>)startDownLoadWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest cacheFielManager:(LERequestCacheManager *)cacheManager &#123;    LERequestDowndloader *downer = [[LERequestDowndloader alloc]initWithLoadingRequest:loadingRequest cacheFielManager:cacheManager];    <span class="hljs-keyword">return</span> downer;&#125;- (<span class="hljs-keyword">instancetype</span>)initWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest cacheFielManager:(LERequestCacheManager *)cacheManager &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest = loadingRequest;        <span class="hljs-keyword">self</span>.cacheManager = cacheManager;        [<span class="hljs-keyword">self</span> configRequest];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;<span class="hljs-comment">/// 取消下载</span>- (<span class="hljs-keyword">void</span>)cancle &#123;    [<span class="hljs-keyword">self</span>.task cancel];    [<span class="hljs-keyword">self</span>.session invalidateAndCancel];&#125;<span class="hljs-comment">/// 发起请求</span>- (<span class="hljs-keyword">void</span>)configRequest &#123;    <span class="hljs-comment">// 获取请求范围</span>    <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest = <span class="hljs-keyword">self</span>.loadingRequest.dataRequest;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = dataRequest.requestedOffset;    <span class="hljs-built_in">NSInteger</span> length = dataRequest.requestedLength;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        offset = dataRequest.currentOffset;    &#125;        <span class="hljs-keyword">if</span> (dataRequest.requestsAllDataToEndOfResource) &#123;        length = <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength - offset;    &#125;        <span class="hljs-comment">// 根据range与本地缓存对比切分为若干个local和remote</span>    <span class="hljs-keyword">self</span>.fragments = [[<span class="hljs-keyword">self</span>.cacheManager calculateRangeForRange:<span class="hljs-built_in">NSMakeRange</span>(offset, length)] mutableCopy];    <span class="hljs-comment">// 原来的请求</span>    <span class="hljs-keyword">self</span>.requestURL = <span class="hljs-keyword">self</span>.cacheManager.url;    <span class="hljs-comment">// 处理fragments</span>    [<span class="hljs-keyword">self</span> processFragments];&#125;<span class="hljs-comment">/// 处理请求片段fragments</span>- (<span class="hljs-keyword">void</span>)processFragments &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.fragments.count &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.cacheManager.contentInfo &amp;&amp; <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength&gt;<span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength;            <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentType;            <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="hljs-keyword">self</span>.cacheManager.contentInfo.byteRangeAccessSupported;        &#125;                LERequestFragment *fragment = <span class="hljs-keyword">self</span>.fragments.firstObject;        <span class="hljs-keyword">if</span> (fragment.modelType == RangeFragmentTypeLocal) &#123;            <span class="hljs-comment">// 本地缓存数据</span>            <span class="hljs-built_in">NSData</span> *cacheData = [<span class="hljs-keyword">self</span>.cacheManager cacheDataForRange:fragment.range error:<span class="hljs-literal">nil</span>];            <span class="hljs-keyword">self</span>.currentOffset = fragment.range.location + fragment.range.length;            [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:cacheData];            [<span class="hljs-keyword">self</span>.fragments removeObject:fragment];            [<span class="hljs-keyword">self</span> processFragments];        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">NSRange</span> fragmentRange = fragment.range;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = fragmentRange.location;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = fragmentRange.location + fragmentRange.length - <span class="hljs-number">1</span>;            <span class="hljs-comment">// 发起请求</span>            <span class="hljs-built_in">NSMutableURLRequest</span> *request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:<span class="hljs-keyword">self</span>.requestURL cachePolicy:<span class="hljs-built_in">NSURLRequestReloadIgnoringCacheData</span> timeoutInterval:<span class="hljs-number">20.0</span>];            <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"bytes=%lld-%lld"</span>,offset,endOffset];            [request setValue:range forHTTPHeaderField:<span class="hljs-string">@"Range"</span>];            <span class="hljs-keyword">self</span>.currentOffset = offset;            [<span class="hljs-keyword">self</span>.fragments removeObject:fragment];                        <span class="hljs-comment">// 开始下载</span>            <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];            [<span class="hljs-keyword">self</span>.task resume];        &#125;            &#125;<span class="hljs-keyword">else</span>&#123;        [<span class="hljs-keyword">self</span> cancle];        [<span class="hljs-keyword">self</span>.loadingRequest finishLoading];    &#125;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDataDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];        contentLength = [[[httpResponse.allHeaderFields[<span class="hljs-string">@"Content-Range"</span>] componentsSeparatedByString:<span class="hljs-string">@"/"</span>] lastObject] longLongValue];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentLength&gt;<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.cacheManager &amp;&amp; <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.cacheManager.contentInfo.contentLength = contentLength;        <span class="hljs-keyword">self</span>.cacheManager.contentInfo.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"总大小:%lld,请求视频片段大小：%f M"</span>,contentLength,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:data];    [<span class="hljs-keyword">self</span>.cacheManager writeData:data range:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-keyword">self</span>.currentOffset, data.length) error:<span class="hljs-literal">nil</span>];    <span class="hljs-keyword">self</span>.currentOffset += data.length;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"已下载：%f M"</span>,<span class="hljs-keyword">self</span>.currentOffset/<span class="hljs-number">1024.0</span>/<span class="hljs-number">1024.0</span>);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    [<span class="hljs-keyword">self</span> processFragments];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><h3 id="四、LERequestCacheManager"><a href="#四、LERequestCacheManager" class="headerlink" title="四、LERequestCacheManager"></a>四、LERequestCacheManager</h3><blockquote><p>有一个难点：对于请求的range与本地缓存的fragment的对比，划分出请求的range当中有哪些是已缓存的，哪些是要发起请求下载的</p><p>此处是参考<a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA" target="_blank" rel="noopener">VIMediaCache</a>中的策略，先获取请求的range与本地的fragments是否有交集，如果有交集则再对比切分</p></blockquote><pre><code class="hljs objc"><span class="hljs-comment">/// 对比loadingRequest的请求范围与本地已缓存的情况，将range切割成若干的fragment</span>- (<span class="hljs-built_in">NSArray</span> &lt;LERequestFragment *&gt;*)calculateRangeForRange:(<span class="hljs-built_in">NSRange</span>)range &#123;    <span class="hljs-built_in">NSArray</span> *cachedFragments = [<span class="hljs-keyword">self</span>.contentInfo cachedDataRanges];    <span class="hljs-built_in">NSMutableArray</span> *resultFragments = [<span class="hljs-built_in">NSMutableArray</span> array];    <span class="hljs-keyword">if</span> (range.length == <span class="hljs-number">0</span> || range.location == <span class="hljs-built_in">NSNotFound</span>) &#123;        <span class="hljs-keyword">return</span> [resultFragments <span class="hljs-keyword">copy</span>];    &#125;        <span class="hljs-built_in">NSInteger</span> endOffset = range.location + range.length;    [cachedFragments enumerateObjectsUsingBlock:^(<span class="hljs-built_in">NSString</span> *obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;        <span class="hljs-built_in">NSRange</span> cacheFragment = <span class="hljs-built_in">NSRangeFromString</span>(obj);        <span class="hljs-comment">// 求交集,有交集则表示range范围内有一部分本地是有缓存的</span>        <span class="hljs-built_in">NSRange</span> intersectionRange = <span class="hljs-built_in">NSIntersectionRange</span>(range, cacheFragment);        <span class="hljs-keyword">if</span> (intersectionRange.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">NSInteger</span> package = intersectionRange.length / kPackageLength;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i&lt;= package; i++) &#123;                <span class="hljs-built_in">NSInteger</span> offset = i * kPackageLength;                <span class="hljs-built_in">NSInteger</span> offsetLocation = intersectionRange.location + offset;                <span class="hljs-built_in">NSInteger</span> maxLocation = intersectionRange.location + intersectionRange.length;                <span class="hljs-built_in">NSInteger</span> length = (offsetLocation + kPackageLength) &gt; maxLocation ? (maxLocation - offsetLocation) : kPackageLength;                                LERequestFragment *fragment = [[LERequestFragment alloc]initWithModelType:RangeFragmentTypeLocal requestRange:<span class="hljs-built_in">NSMakeRange</span>(offsetLocation, length)];                [resultFragments addObject:fragment];            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cacheFragment.location &gt;= endOffset) &#123;            *stop = <span class="hljs-literal">YES</span>;        &#125;            &#125;];            <span class="hljs-keyword">if</span> (resultFragments.count == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 与本地缓存没有交集，表示请求的rang没有缓存数据，需要发起服务器请求获取数据</span>        LERequestFragment *fragment = [[LERequestFragment alloc]initWithModelType:RangeFragmentTypeRemote requestRange:range];        [resultFragments addObject:fragment];    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">NSMutableArray</span> *localRemoteFragments = [<span class="hljs-built_in">NSMutableArray</span> array];        [resultFragments enumerateObjectsUsingBlock:^(LERequestFragment *obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;            <span class="hljs-built_in">NSRange</span> fragmentRange = obj.range;            <span class="hljs-comment">// 最开端的片段</span>            <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (range.location &lt; fragmentRange.location) &#123;                    LERequestFragment *fragment = [LERequestFragment new];                    fragment.modelType = RangeFragmentTypeRemote;                    fragment.range = <span class="hljs-built_in">NSMakeRange</span>(range.location, fragmentRange.location - range.location);                    [localRemoteFragments addObject:fragment];                &#125;                                [localRemoteFragments addObject:obj];            &#125;            <span class="hljs-keyword">else</span> &#123;                LERequestFragment *lastFragment = [localRemoteFragments lastObject];                <span class="hljs-built_in">NSInteger</span> lastOffset = lastFragment.range.location + lastFragment.range.length;                <span class="hljs-keyword">if</span> (fragmentRange.location &gt; lastOffset) &#123;                    LERequestFragment *fragment = [LERequestFragment new];                    fragment.modelType = RangeFragmentTypeRemote;                    fragment.range = <span class="hljs-built_in">NSMakeRange</span>(lastOffset, fragmentRange.location - lastOffset);                    [localRemoteFragments addObject:fragment];                &#125;                [localRemoteFragments addObject:obj];            &#125;                                    <span class="hljs-comment">// 最尾端的片段</span>            <span class="hljs-keyword">if</span> (idx == resultFragments.count - <span class="hljs-number">1</span>) &#123;                <span class="hljs-built_in">NSInteger</span> localEndOffset = fragmentRange.location + fragmentRange.length;                <span class="hljs-keyword">if</span> (endOffset &gt; localEndOffset) &#123;                    LERequestFragment *fragment = [LERequestFragment new];                    fragment.modelType = RangeFragmentTypeRemote;                    fragment.range = <span class="hljs-built_in">NSMakeRange</span>(localEndOffset, endOffset - localEndOffset);                    [localRemoteFragments addObject:fragment];                &#125;            &#125;                    &#125;];                resultFragments = localRemoteFragments;    &#125;        <span class="hljs-keyword">return</span> [resultFragments <span class="hljs-keyword">copy</span>];&#125;</code></pre><h3 id="五、LERequestContentInfo"><a href="#五、LERequestContentInfo" class="headerlink" title="五、LERequestContentInfo"></a>五、LERequestContentInfo</h3><blockquote><p>归档，资源文件的描述信息，比如长度、文件格式、是否能分片下载、以及本地缓存的range片段</p><p>有个注意点就是NSRange数组在归档的时候，需要转换为NSString，而转为NSValue是没用的，</p><p>并且在解档的时候，需要表示解档对象的类型，否则会解档失败。本人在这里卡了一会，好不容易才知道原因</p></blockquote><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSCoding</span>- (<span class="hljs-keyword">void</span>)encodeWithCoder:(<span class="hljs-built_in">NSCoder</span> *)coder &#123;    [coder encodeInt64:<span class="hljs-keyword">self</span>.contentLength forKey:kContentLength];    [coder encodeBool:<span class="hljs-keyword">self</span>.byteRangeAccessSupported forKey:kByteRangeAccessSupported];    [coder encodeObject:<span class="hljs-keyword">self</span>.contentType forKey:kContentType];    [coder encodeObject:<span class="hljs-keyword">self</span>.fragmengs forKey:kFragments];&#125;<span class="hljs-comment">///  tips: （1）数组解档的时候，一定要用decodeObjectOfClass:forKey:的方法，确认解档的是数组，否则会解档失败</span><span class="hljs-comment">///      （2）NSRange 转化为NSValue 存放在数组中，解档也是会有问题的，所以这里是将NSRange转为NString</span>- (<span class="hljs-keyword">instancetype</span>)initWithCoder:(<span class="hljs-built_in">NSCoder</span> *)coder &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        _contentLength = [coder decodeInt64ForKey:kContentLength];        _contentType = [coder decodeObjectOfClass:<span class="hljs-built_in">NSString</span>.class forKey:kContentType];        _byteRangeAccessSupported = [coder decodeBoolForKey:kByteRangeAccessSupported];        _fragmengs = [coder decodeObjectOfClass:<span class="hljs-built_in">NSMutableArray</span>.class forKey:kFragments];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;</code></pre><h3 id="六：如何使用"><a href="#六：如何使用" class="headerlink" title="六：如何使用"></a>六：如何使用</h3><p>超级简单哦！只要使用LEResourceLoaderManager创建AVPlayerItem，就能实现边播边缓存。</p><p>提示：AVPlayer的<code>automaticallyWaitsToMinimizeStalling</code>属性一定要设置为YES，这样能在缓存尽可能少的数据时就能播放视频，否则可能要等到视频缓存完成了才播放视频</p><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayer</span> *player;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerLayer</span> *playerLayer;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVURLAsset</span> *urlAsset;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerItem</span> *playerItem;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) LEResourceLoaderManager *loaderManager;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;    [<span class="hljs-keyword">super</span> viewDidLoad];        <span class="hljs-keyword">self</span>.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> blackColor];        <span class="hljs-keyword">self</span>.loaderManager = [[LEResourceLoaderManager alloc]init];    <span class="hljs-comment">// URL</span>    <span class="hljs-built_in">NSString</span> *url = <span class="hljs-string">@"http://vfx.mtime.cn/Video/2019/03/18/mp4/190318231014076505.mp4"</span>;        <span class="hljs-comment">// PlayerItem</span>    _playerItem = [<span class="hljs-keyword">self</span>.loaderManager playerItemWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:url]];    [_playerItem addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@"status"</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];    <span class="hljs-comment">// Player</span>    _player = [[<span class="hljs-built_in">AVPlayer</span> alloc]initWithPlayerItem:<span class="hljs-keyword">self</span>.playerItem];        <span class="hljs-comment">// 决定音频是否马上开始播放的关键性参数！！！</span>    <span class="hljs-keyword">if</span> (@available(iOS <span class="hljs-number">10.0</span>, *)) &#123;        _player.automaticallyWaitsToMinimizeStalling = <span class="hljs-literal">NO</span>;    &#125;        <span class="hljs-comment">// PlayerLayer</span>    _playerLayer = [<span class="hljs-built_in">AVPlayerLayer</span> playerLayerWithPlayer:<span class="hljs-keyword">self</span>.player];    _playerLayer.videoGravity = <span class="hljs-built_in">AVLayerVideoGravityResizeAspect</span>;    _playerLayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.height);    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_playerLayer];        &#125;</code></pre><center class="half"> <div>感谢你“一分”支持</div>  <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVPlayer边播放边缓存-01</title>
    <link href="/2020/05/19/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9801/"/>
    <url>/2020/05/19/AVPlayer%E8%BE%B9%E6%92%AD%E6%94%BE%E8%BE%B9%E7%BC%93%E5%AD%9801/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>随着抖音的兴起，短视频是乎是每个app的标配，虽然以往开发的项目都有视频播放的功能，但都是集成第三方库的控件，直接使用的，对于avplayer的边播边缓存是如何实现不了解，趁着疫情宅在家里有空，研究一下，目标是自己也能封装一个播放器</p><p>分4篇文章</p><p>01 - 视频播放</p><p>02 - 视频分片下载</p><p>03 - 视频缓存</p><p>04 - 播放器封装</p><h1 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a>二、基本原理</h1><p>AVPlayer 没有提供API获取播放器下载的数据，所以无法直接获取缓存，但是可以通过设置AVAssetResourceLoader代理的方式，自己使用NSURLSession下载数据，再传给播放器播放，同时缓存在本地，下次播放的时候可以使用。</p><p>AVAssetResourceLoader 只有在AVURLAsset加载不能识别的URL资源的时候，才会回调代理方法，所以在初始化AVURLAsset的时候把目标视频URL地址的scheme替换成系统不能识别的schemen。</p><p><img src="https://i.loli.net/2020/05/19/BJWvbsLajEKHDFr.png" srcset="/img/loading.gif" alt="引用zltunes中的图片"></p><h4 id="（1）AVAssetResourceLoaderDelegate-代理有两个必须要实现的方法"><a href="#（1）AVAssetResourceLoaderDelegate-代理有两个必须要实现的方法" class="headerlink" title="（1）AVAssetResourceLoaderDelegate 代理有两个必须要实现的方法"></a>（1）AVAssetResourceLoaderDelegate 代理有两个必须要实现的方法</h4><p>要求加载资源的代理方法</p><p>返回YES，表示该代理类现在可以处理该请求，需要在这里保存loadingReques并开启下载数据的任务</p><p>下载回调中拿到响应数据后再对loadingRequest进行填充</p><p>如果返回NO，则表示当前代理不能处理，视频数据需要AVPlayer自己处理(但是之前视频URL的scheme被设置自定义的，所以AVPlayer不能识别，最后导致 AVPlayerItemStatusFailed)</p><pre><code class="hljs objc">- (<span class="hljs-built_in">BOOL</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</code></pre><p>AVAssetResourceLoader取消了本次请求</p><p>把loadingRequest移除下载任务回调列表(停止填充数据)</p><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest</code></pre><p>代理方法中<code>AVAssetResourceLoadingRequest</code>类非常关键，以下是该类常用的属性和方法</p><pre><code class="hljs objc"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSURLRequest</span> *request;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">AVAssetResourceLoadingContentInformationRequest</span> *contentInformationRequest;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest;- (<span class="hljs-keyword">void</span>)finishLoading;- (<span class="hljs-keyword">void</span>)finishLoadingWithError:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSError</span> *)error;</code></pre><p><code>request</code> 代表原始的请求，获取资源请求地址</p><p><code>contentInformationRequest</code> 播放资源相关的信息，比如资源格式contentType、资源长度大小contentLength、是否支持分片下载byteRangeAccessSupported等</p><p><code>dataRequest</code> 表示请求资源数据的范围。由于AVPlayer会触发分片下载的策略，也就是说一个视频资源可能对应多个AVAssetResourceLoadingRequest，可以从这个属性获取每个AVAssetResourceLoadingRequest请求数据的范围</p><p><code>- (void)finishLoading</code> 如果AVAssetResourceLoadingRequest要求下载的数据都下载完毕则调用此方法完成下载</p><p><code>- (void)finishLoadingWithError:(nullable NSError *)error;</code> 如果AVAssetResourceLoadingRequest对应的下载发生失败，则调用此方法</p><h4 id="（2）流程原理"><a href="#（2）流程原理" class="headerlink" title="（2）流程原理"></a>（2）流程原理</h4><p><img src="https://i.loli.net/2020/05/21/MPngKXNyshlxWLi.png" srcset="/img/loading.gif" alt="image-20200521141931947"></p><p>AVPlayer是分片式下载策略，可能会发起多个LoadingRequest请求，但触发下载的时候，会先发起一个Range为0~2的数据请求，获取视频资源的描述信息，比如文件类型、文件大小，这需要我们填充到<code>AVAssetResourceLoadingRequest</code>类中的<code>contentInformationRequest</code>属性，而获取到的data填充至<code>AVAssetResourceLoadingRequest</code>的<code>dataRequest</code>，<code>dataRequest</code>属性中有个方法可以接收增量连续的data数据:<code>- (void)respondWithData:(NSData *)data</code>，当<code>AVAssetResourceLoadingRequest</code>要求下载的数据都下载完毕，则调用<code>- (void)finishLoading</code>完成请求，并且AVPlayer会在调用<code>finishLoading</code>时判断接下来要怎么处理，比如视频文件类型是否支持、是否要发起下一个LoadingRequest等</p><h4 id="（3）重试机制"><a href="#（3）重试机制" class="headerlink" title="（3）重试机制"></a>（3）重试机制</h4><p>AVAssetResourceLoader在执行加载的时候，会时不时触发取消下载方法<code>\- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoa</code>，然后重新发起加载请求策略，如果下载了部分，重新发起的下载请求会从还没下载的部分开始。</p><h1 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h1><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>完整代码：链接:<a href="https://pan.baidu.com/s/1BR9MkKHxrk_T-mH5vV7NIQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1BR9MkKHxrk_T-mH5vV7NIQ</a>  密码:st0g</p><p><img src="https://i.loli.net/2020/05/21/p1Y4sXlwrFnbHx8.png" srcset="/img/loading.gif" alt="image-20200521134545223"></p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"ViewController.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;CoreServices/CoreServices.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kScheme @<span class="hljs-meta-string">"scheme"</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">AVAssetResourceLoaderDelegate</span>,<span class="hljs-title">NSURLSessionDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayer</span> *player;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerLayer</span> *playerLayer;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVURLAsset</span> *urlAsset;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">AVPlayerItem</span> *playerItem;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span>&lt;<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *&gt; *requestsArray;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSOperationQueue</span> *downloadQueue;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableData</span> *downloadData;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">BOOL</span>  byteRangeAccessSupported;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span>  contentLength;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>  ) <span class="hljs-built_in">NSString</span>  *contentType;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;    [<span class="hljs-keyword">super</span> viewDidLoad];        <span class="hljs-keyword">self</span>.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> blackColor];        _requestsArray = [<span class="hljs-built_in">NSMutableArray</span> array];    _downloadData = [<span class="hljs-built_in">NSMutableData</span> data];    <span class="hljs-comment">// URL</span>    <span class="hljs-built_in">NSString</span> *url = <span class="hljs-string">@"http://vfx.mtime.cn/Video/2019/03/18/mp4/190318231014076505.mp4"</span>;    <span class="hljs-built_in">NSURL</span> *videoURL = [<span class="hljs-built_in">NSURL</span> URLWithString:[kScheme stringByAppendingString:url]];        <span class="hljs-comment">// AVURLAsset</span>    _urlAsset = [<span class="hljs-built_in">AVURLAsset</span> URLAssetWithURL:videoURL options:<span class="hljs-literal">nil</span>];    [_urlAsset.resourceLoader setDelegate:<span class="hljs-keyword">self</span> queue:dispatch_get_main_queue()];    <span class="hljs-comment">// PlayerItem</span>    _playerItem = [<span class="hljs-built_in">AVPlayerItem</span> playerItemWithAsset:<span class="hljs-keyword">self</span>.urlAsset];    [_playerItem addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@"status"</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>|<span class="hljs-built_in">NSKeyValueObservingOptionOld</span> context:<span class="hljs-literal">nil</span>];    <span class="hljs-comment">// Player</span>    _player = [[<span class="hljs-built_in">AVPlayer</span> alloc]initWithPlayerItem:<span class="hljs-keyword">self</span>.playerItem];        <span class="hljs-comment">// PlayerLayer</span>    _playerLayer = [<span class="hljs-built_in">AVPlayerLayer</span> playerLayerWithPlayer:<span class="hljs-keyword">self</span>.player];    _playerLayer.videoGravity = <span class="hljs-built_in">AVLayerVideoGravityResizeAspect</span>;    _playerLayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="hljs-built_in">UIScreen</span> mainScreen].bounds.size.height);    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_playerLayer];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - AVAssetResourceLoaderDelegate</span><span class="hljs-comment">/// 要求加载资源的代理方法</span><span class="hljs-comment">/// 返回YES，表示该代理类现在可以处理该请求，需要在这里保存loadingReques并开启下载数据的任务</span><span class="hljs-comment">/// 下载回调中拿到响应数据后再对loadingRequest进行填充</span><span class="hljs-comment">/// 如果返回NO，则表示当前代理不能处理，视频数据需要AVPlayer自己处理(但是之前视频URL的scheme被设置自定义的，所以AVPlayer不能识别，最后导致 AVPlayerItemStatusFailed)</span>- (<span class="hljs-built_in">BOOL</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-built_in">NSString</span> *requestURL = loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([requestURL containsString:kScheme] &amp;&amp; ![_requestsArray containsObject:loadingRequest]) &#123;        [_requestsArray addObject:loadingRequest];                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.task == <span class="hljs-literal">nil</span>) &#123;            <span class="hljs-built_in">NSString</span> *orginURL = [requestURL stringByReplacingOccurrencesOfString:kScheme withString:<span class="hljs-string">@""</span>];            <span class="hljs-built_in">NSMutableURLRequest</span> *request = [[<span class="hljs-built_in">NSMutableURLRequest</span> alloc]initWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:orginURL] cachePolicy:(<span class="hljs-built_in">NSURLRequestUseProtocolCachePolicy</span>) timeoutInterval:<span class="hljs-number">20</span>];            <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];            [<span class="hljs-keyword">self</span>.task resume];        &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;<span class="hljs-comment">/// AVAssetResourceLoader取消了本次请求</span><span class="hljs-comment">/// 把loadingRequest移除下载任务回调列表(停止填充数据)</span>- (<span class="hljs-keyword">void</span>)resourceLoader:(<span class="hljs-built_in">AVAssetResourceLoader</span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    [_requestsArray removeObject:loadingRequest];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        <span class="hljs-keyword">self</span>.byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">self</span>.contentLength = response.expectedContentLength;    <span class="hljs-keyword">self</span>.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    <span class="hljs-comment">// 缓存下载的data</span>    [<span class="hljs-keyword">self</span>.downloadData appendData:data];    <span class="hljs-comment">// 拼接下载的data</span>    [<span class="hljs-keyword">self</span> processRequestData];        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"已下载：%f ，正在下载：%f"</span>,<span class="hljs-keyword">self</span>.downloadData.length/<span class="hljs-number">1024.0</span>,data.length/<span class="hljs-number">1024.0</span>);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - ProcessRequestData</span>- (<span class="hljs-keyword">void</span>)processRequestData &#123;    <span class="hljs-built_in">NSMutableArray</span> *requestCompleted = [<span class="hljs-built_in">NSMutableArray</span> array];    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *loadingRequest <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.requestsArray) &#123;        loadingRequest.contentInformationRequest.contentLength = <span class="hljs-keyword">self</span>.contentLength;        loadingRequest.contentInformationRequest.contentType = <span class="hljs-keyword">self</span>.contentType;        loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="hljs-keyword">self</span>.byteRangeAccessSupported;                <span class="hljs-built_in">BOOL</span> didRespondCompletely = [<span class="hljs-keyword">self</span> respondWithDataForRequest:loadingRequest.dataRequest];        <span class="hljs-keyword">if</span> (didRespondCompletely) &#123;            [requestCompleted addObject:loadingRequest];            [loadingRequest finishLoading];        &#125;    &#125;    [<span class="hljs-keyword">self</span>.requestsArray removeObjectsInArray:requestCompleted];&#125;<span class="hljs-comment">/// 判断loadingRequest要求下载的数据是否全部下载完毕</span><span class="hljs-comment">/// 以及将下载的数据data拼接到dataRequest当中</span><span class="hljs-comment">/// @param dataRequest dataRequest</span>- (<span class="hljs-built_in">BOOL</span>)respondWithDataForRequest:(<span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *)dataRequest &#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> startOffset = dataRequest.requestedOffset;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        startOffset = dataRequest.currentOffset;    &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.downloadData.length &lt; startOffset) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;    &#125;        <span class="hljs-built_in">NSUInteger</span> unreadBytes = <span class="hljs-keyword">self</span>.downloadData.length - startOffset;    <span class="hljs-built_in">NSUInteger</span> numberOfBytesToRespondWith = MIN(dataRequest.requestedLength, unreadBytes);        [dataRequest respondWithData:[<span class="hljs-keyword">self</span>.downloadData subdataWithRange:<span class="hljs-built_in">NSMakeRange</span>(startOffset, numberOfBytesToRespondWith)]];        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = startOffset + dataRequest.requestedLength;    <span class="hljs-built_in">BOOL</span> didResponsdComplete = <span class="hljs-keyword">self</span>.downloadData.length &gt;= endOffset;        <span class="hljs-keyword">return</span> didResponsdComplete;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - KVO</span>- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-keyword">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-keyword">id</span>&gt; *)change context:(<span class="hljs-keyword">void</span> *)context &#123;    <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-string">@"status"</span>]) &#123;        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">self</span>.playerItem.status) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusUnknown</span>: &#123;                <span class="hljs-comment">// 未知状态，不能播放</span>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusUnknown"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusReadyToPlay</span>: &#123;                <span class="hljs-comment">// 准备完毕，可以播放</span>                <span class="hljs-comment">// 此方法可以在视频未播放的时候，获取视频的总时长(备注：一定要在AVPlayer预加载状态status是AVPlayerItemStatusReadyToPlay才能获取)</span>                <span class="hljs-comment">// NSLog(@"total %f",CMTimeGetSeconds(self.playerItem.asset.duration));</span>                [<span class="hljs-keyword">self</span>.player play];                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusReadyToPlay"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-built_in">AVPlayerItemStatusFailed</span>: &#123;                <span class="hljs-comment">// 加载失败，网络或者服务器出现问题</span>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"AVPlayerItemStatusFailed"</span>);            &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>（PS：关于初始化NSURLSession请求会话的时候，设置<code>delegateQueue</code>代理回调线程的值，一定要设置成<code>主线程</code>，如果设置成其他自定义的operationQueue，AVPlayer会播放失败，这可能是在拼接数据及完成finishLoading的时候，AVPlayer会在当前线程刷新UI，所以必须设置在主线程完成）</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>完整代码：链接:<a href="https://pan.baidu.com/s/1C5JH6onUsmqgie1Loi1OgQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1C5JH6onUsmqgie1Loi1OgQ</a>  密码:rerp</p><p>这种方式是基于原理假想出来的，但是实际运行视频播放不出来，在完成第一个Range为0~2的loadingRequest请求后，提示<strong>AVPlayerItemStatusFailed</strong>错误，尝试了很久，一直都未能解决，百思不得其解。如果有其他同行知道原因的，麻烦在评论区留意，感谢</p><p><img src="https://i.loli.net/2020/05/21/spL4GkAVWXM38fJ.png" srcset="/img/loading.gif" alt="image-20200521140754935"></p><p>以下是RequestDownder的代码</p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"RequestDownder.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;MobileCoreServices/MobileCoreServices.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RequestDownder</span>()&lt;<span class="hljs-title">NSURLSessionDataDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RequestDownder</span></span><span class="hljs-comment">/// 开始下载</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>+ (<span class="hljs-keyword">instancetype</span>)startDownLoadWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    RequestDownder *downer = [[RequestDownder alloc]initWithLoadingRequest:loadingRequest];    <span class="hljs-keyword">return</span> downer;&#125;- (<span class="hljs-keyword">instancetype</span>)initWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest = loadingRequest;        [<span class="hljs-keyword">self</span> setup];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;- (<span class="hljs-keyword">void</span>)cancle &#123;    [<span class="hljs-keyword">self</span>.session invalidateAndCancel];&#125;<span class="hljs-comment">/// 发起请求</span>- (<span class="hljs-keyword">void</span>)setup  &#123;    <span class="hljs-comment">// 获取请求范围</span>    <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest = <span class="hljs-keyword">self</span>.loadingRequest.dataRequest;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = dataRequest.requestedOffset;    <span class="hljs-built_in">NSInteger</span> length = dataRequest.requestedLength;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        offset = dataRequest.currentOffset;    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = offset + length - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 获取请求连接URL</span>    <span class="hljs-built_in">NSString</span> *urlStr = <span class="hljs-keyword">self</span>.loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([urlStr hasPrefix:<span class="hljs-string">@"scheme"</span>]) &#123;       urlStr = [urlStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"scheme"</span> withString:<span class="hljs-string">@""</span>];    &#125;        <span class="hljs-comment">// 发起请求</span>    <span class="hljs-built_in">NSMutableURLRequest</span> *request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:urlStr] cachePolicy:<span class="hljs-built_in">NSURLRequestReloadIgnoringCacheData</span> timeoutInterval:<span class="hljs-number">20.0</span>];    <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"bytes=%lld-%lld"</span>,offset,endOffset];    [request setValue:range forHTTPHeaderField:<span class="hljs-string">@"Range"</span>];        <span class="hljs-comment">// 开始下载</span>    <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];    [<span class="hljs-keyword">self</span>.task resume];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDataDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = response.expectedContentLength;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];    &#125;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = response.MIMEType;    <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:data];&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d -- %d"</span>,<span class="hljs-keyword">self</span>.loadingRequest.isCancelled,<span class="hljs-keyword">self</span>.loadingRequest.isFinished);    [<span class="hljs-keyword">self</span>.loadingRequest finishLoading];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(requestDowner:didComplete:)]) &#123;        [<span class="hljs-keyword">self</span>.delegate requestDowner:<span class="hljs-keyword">self</span> didComplete:error];    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>突然心情开朗，终于知道第二种方式问题的关键点(测试代码下载地址：链接:<a href="https://pan.baidu.com/s/16hFRJaDgFJzj2IQadaW87w" target="_blank" rel="noopener">https://pan.baidu.com/s/16hFRJaDgFJzj2IQadaW87w</a>  密码:z0cw）</p><p>前面说的resourceLoader触发下载，会先发起一个range为0~2的request，来获取视频资源的详情，比如文件长度，接着就是将获取的文件详情填充至<code>contentInformationRequest</code>，到这为止是没有错的，但是，<code>contentInformationRequest</code>是相对于整个视频资源文件的，这非常关键，也就是说设置的文件格式、文件长度都是指整个文件，而并不是指每一个发起的<code>AVAssetResourceLoadingRequest</code>的长度。</p><p>所以在第二种方式中，由于每一个<code>AVAssetResourceLoadingRequest</code>单独发起一个request请求，并且设置request请求数据范围range值，所以获取到的文件长度是对应于当前请求范围range，并不是指整个文件的长度。因此才会在发起第一个<code>AVAssetResourceLoadingRequest</code>请求range为0~2后，就没有继续发起第二个<code>AVAssetResourceLoadingRequest</code>了，因为resourceLoader会判断整个视频资源已经下载完成了。</p><p>激动<del>~</del>终于知道原因了，可以继续往前走，太不容易了，每一个小细节都可能导致失败</p><p><strong>好了，问题来了，那要怎么分片下载，并且获取整个视频文件的长度？</strong></p><p>貌似很矛盾的一个问题，其实是文件长度的取的字段有问题，通过答应服务器响应的<code>NSURLResponse</code>如下图，使用，代码改为如下就能解决问题了</p><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];        contentLength = [[[httpResponse.allHeaderFields[<span class="hljs-string">@"Content-Range"</span>] componentsSeparatedByString:<span class="hljs-string">@"/"</span>] lastObject] longLongValue];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentLength&gt;<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;</code></pre><p><img src="https://i.loli.net/2020/05/22/jSz4NmBFy3TR8LV.png" srcset="/img/loading.gif" alt="image-20200522120244479"></p><p><strong>修改后完整的代码</strong></p><p>下载地址：链接:<a href="https://pan.baidu.com/s/1voLndB23xy8Jcggrf_fYCQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1voLndB23xy8Jcggrf_fYCQ</a>  密码:2kc2</p><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-meta-string">"RequestDownder.h"</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;MobileCoreServices/MobileCoreServices.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RequestDownder</span>()&lt;<span class="hljs-title">NSURLSessionDataDelegate</span>&gt;</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSession</span> *session;<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionTask</span> *task;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RequestDownder</span></span><span class="hljs-comment">/// 开始下载</span><span class="hljs-comment">/// @param loadingRequest loadingRequest</span>+ (<span class="hljs-keyword">instancetype</span>)startDownLoadWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    RequestDownder *downer = [[RequestDownder alloc]initWithLoadingRequest:loadingRequest];    <span class="hljs-keyword">return</span> downer;&#125;- (<span class="hljs-keyword">instancetype</span>)initWithLoadingRequest:(<span class="hljs-built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest &#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest = loadingRequest;        [<span class="hljs-keyword">self</span> setup];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;- (<span class="hljs-keyword">void</span>)cancle &#123;    [<span class="hljs-keyword">self</span>.session invalidateAndCancel];&#125;<span class="hljs-comment">/// 发起请求</span>- (<span class="hljs-keyword">void</span>)setup  &#123;    <span class="hljs-comment">// 获取请求范围</span>    <span class="hljs-built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest = <span class="hljs-keyword">self</span>.loadingRequest.dataRequest;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> offset = dataRequest.requestedOffset;    <span class="hljs-built_in">NSInteger</span> length = dataRequest.requestedLength;    <span class="hljs-keyword">if</span> (dataRequest.currentOffset != <span class="hljs-number">0</span>) &#123;        offset = dataRequest.currentOffset;    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> endOffset = offset + length - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 获取请求连接URL</span>    <span class="hljs-built_in">NSString</span> *urlStr = <span class="hljs-keyword">self</span>.loadingRequest.request.URL.absoluteString;    <span class="hljs-keyword">if</span> ([urlStr hasPrefix:<span class="hljs-string">@"scheme"</span>]) &#123;       urlStr = [urlStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"scheme"</span> withString:<span class="hljs-string">@""</span>];    &#125;        <span class="hljs-comment">// 发起请求</span>    <span class="hljs-built_in">NSMutableURLRequest</span> *request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:urlStr] cachePolicy:<span class="hljs-built_in">NSURLRequestReloadIgnoringCacheData</span> timeoutInterval:<span class="hljs-number">20.0</span>];    <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"bytes=%lld-%lld"</span>,offset,endOffset];    [request setValue:range forHTTPHeaderField:<span class="hljs-string">@"Range"</span>];        <span class="hljs-comment">// 开始下载</span>    <span class="hljs-keyword">self</span>.task = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];    [<span class="hljs-keyword">self</span>.task resume];&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - NSURLSessionDataDelegate</span>- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response completionHandler:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;    completionHandler(<span class="hljs-built_in">NSURLSessionResponseAllow</span>);    <span class="hljs-built_in">BOOL</span> byteRangeAccessSupported = <span class="hljs-literal">NO</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> ([response isKindOfClass:<span class="hljs-built_in">NSHTTPURLResponse</span>.class]) &#123;        <span class="hljs-built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="hljs-built_in">NSHTTPURLResponse</span> *)response;        <span class="hljs-built_in">NSString</span> *acceptRange = httpResponse.allHeaderFields[<span class="hljs-string">@"Accept-Ranges"</span>];        byteRangeAccessSupported = [acceptRange isEqualToString:<span class="hljs-string">@"bytes"</span>];        contentLength = [[[httpResponse.allHeaderFields[<span class="hljs-string">@"Content-Range"</span>] componentsSeparatedByString:<span class="hljs-string">@"/"</span>] lastObject] longLongValue];    &#125;        <span class="hljs-built_in">NSString</span> *mimeType = [response MIMEType];    <span class="hljs-built_in">CFStringRef</span> contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge <span class="hljs-built_in">CFStringRef</span>)(mimeType), <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (contentType &amp;&amp; contentLength&gt;<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentLength = contentLength;        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.contentType = <span class="hljs-built_in">CFBridgingRelease</span>(contentType);        <span class="hljs-keyword">self</span>.loadingRequest.contentInformationRequest.byteRangeAccessSupported = byteRangeAccessSupported;    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"视频大小：%f M"</span>,response.expectedContentLength/<span class="hljs-number">1024.0</span>f/<span class="hljs-number">1024.0</span>f);&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;    [<span class="hljs-keyword">self</span>.loadingRequest.dataRequest respondWithData:data];&#125;- (<span class="hljs-keyword">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error &#123;    [<span class="hljs-keyword">self</span>.loadingRequest finishLoading];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(requestDowner:didComplete:)]) &#123;        [<span class="hljs-keyword">self</span>.delegate requestDowner:<span class="hljs-keyword">self</span> didComplete:error];    &#125;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载完成"</span>);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - Getter</span>- (<span class="hljs-built_in">NSURLSession</span> *)session &#123;    <span class="hljs-keyword">if</span> (!_session) &#123;        <span class="hljs-built_in">NSURLSessionConfiguration</span> *configuration = [<span class="hljs-built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];        _session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="hljs-keyword">self</span> delegateQueue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]];    &#125;    <span class="hljs-keyword">return</span> _session;&#125;<span class="hljs-keyword">@end</span></code></pre><p>到这为止，已经能完成一个通过自己自定义的下载，再将下载数据填充给AVPlayer播放器播放的例子，距离封装一个自己的播放器的路很有很远，继续前行…为自己加油</p><h1 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h1><p>1、 <a href="https://juejin.im/post/5cb69acbf265da03b4460955" target="_blank" rel="noopener">AVPlayer详解系列（一）参数设置</a></p><p>2、 <a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA?#%23" target="_blank" rel="noopener">可能是目前最好的 AVPlayer 音视频缓存方案</a></p><p>3、 <a href="https://zltunes.github.io/2019/04/23/avplayer-best-practice/" target="_blank" rel="noopener">AVPlayer 边下边播与最佳实践</a></p><p>4、  <a href="http://chuquan.me/2019/12/03/ios-avplayer-support-cache/" target="_blank" rel="noopener">iOS AVPlayer 视频缓存的设计与实现</a></p><p>5、  <a href="http://xferris.cn/avplayer_cache/" target="_blank" rel="noopener">AVPlayer初体验之边下边播与视频缓存</a></p><p>6、  <a href="https://juejin.im/post/5a1e94b7f265da4326529995" target="_blank" rel="noopener">唱吧 iOS 音视频缓存处理框架</a></p><p>7、  <a href="https://chenzhengying.com/html/iOS/ZYPlayer/ZYPlayer.html" target="_blank" rel="noopener">基于AVPlayer封装的播放器细节</a></p><p>8、  <a href="https://msching.github.io/blog/2016/05/24/audio-in-ios-9/" target="_blank" rel="noopener">iOS音频播放 (九)：边播边缓存</a></p><p>9、<a href="https://www.jianshu.com/p/c157476474f1" target="_blank" rel="noopener">基于AVPlayer实现边缓存边播放</a></p><p>PPT下载地址</p><p>链接:<a href="https://pan.baidu.com/s/1Jx88y25EmNu7SMpkVyTr4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1Jx88y25EmNu7SMpkVyTr4Q</a>  密码:8rt3</p><center class="half"> <div>感谢你的“一分”支持</div>  <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Media</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基本使用和封装教程看我的就可以了</title>
    <link href="/2020/05/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>赶在2019年春节放假前一天，发一最后一波文章，虽然有点凌乱，但绝对使用<br>大力我上一家公司是做即时聊天应用的，聊天功能不是走第三方的平台,如环信、网易云等，毕竟是应用的核心功能，所以还是掌握在自己手上比较靠谱(结果各种坑)，当然还没到自定义协议那一高层次，我们使用的WebSocket，所以比如socket发消息的保证、socket重连、UI搭建等等都是需要自己从零开始做起，其中少不了重要的一环：聊天记录和用户数据的保存。<br>铺垫这么久了，是时候回归我们今天要讨论的话题：数据库</p><p>项目数据库管理是使用常用的第三方框架：FMDB，今天只讲一些常用的sql语法和功能，具体的代码说明已经在代码注释写了…请看代码</p><pre><code class="hljs objective-c">@interface ViewController ()@property (nonatomic, copy, readwrite) NSString *fileName;@property (nonatomic, strong, readwrite) FMDatabase *db;@property (nonatomic, strong, readwrite) FMDatabaseQueue *queue;@end@implementation ViewController- (void)viewDidLoad &#123;    [super viewDidLoad];        &#x2F;&#x2F; 数据库路径    NSString *doc &#x3D; [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];    NSString *fileName &#x3D; [doc stringByAppendingPathComponent:@&quot;student.db&quot;];    self.fileName &#x3D; fileName;    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;%@&quot;,fileName);&#125;#pragma mark - touch- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;&#x2F;&#x2F;    [self insert];&#x2F;&#x2F;    [self update];&#x2F;&#x2F;    [self delete];&#x2F;&#x2F;    [self query];    [self dataBaseQueueAction];&#125;@end</code></pre><h1 id="1、数据库基本使用：增删改查"><a href="#1、数据库基本使用：增删改查" class="headerlink" title="1、数据库基本使用：增删改查"></a>1、数据库基本使用：增删改查</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - FMDB 增删改查</span>- (<span class="hljs-keyword">void</span>)baseUseDemo &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     三大类</span><span class="hljs-comment">     (1)FMDatabase</span><span class="hljs-comment">     一个FMDatabase对象就代表一个单独的SQLite数据库</span><span class="hljs-comment">     用来执行SQL语句</span><span class="hljs-comment">     (2)FMResultSet</span><span class="hljs-comment">     使用FMDatabase执行查询后的结果集</span><span class="hljs-comment">     (3)FMDatabaseQueue</span><span class="hljs-comment">     用于在多线程中执行多个查询或更新，它是线程安全的</span><span class="hljs-comment">     */</span>            <span class="hljs-comment">// 获得数据库</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">     有三种情况</span><span class="hljs-comment">     （1）具体文件路径</span><span class="hljs-comment">     　　如果不存在会自动创建</span><span class="hljs-comment">     （2）空字符串@""</span><span class="hljs-comment">     　　会在临时目录创建一个空的数据库</span><span class="hljs-comment">     　　当FMDatabase连接关闭时，数据库文件也被删除</span><span class="hljs-comment">     （3）nil</span><span class="hljs-comment">     　　会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</span><span class="hljs-comment">     */</span>    FMDatabase *db = [FMDatabase databaseWithPath:<span class="hljs-keyword">self</span>.fileName];        <span class="hljs-comment">// 打开数据库</span>    <span class="hljs-keyword">if</span> ([db open]) &#123;        <span class="hljs-built_in">NSString</span> *sqlString = <span class="hljs-string">@"CREATE TABLE IF NOT EXISTS t_student(id integer PRIMARY KEY AUTOINCREMENT,name text NOT NULL , age integer NOT NULL);"</span>;        <span class="hljs-built_in">BOOL</span> result = [db executeUpdate:sqlString];        <span class="hljs-keyword">if</span> (result) &#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"创表成功"</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"创表失败"</span>);        &#125;    &#125;        <span class="hljs-keyword">self</span>.db = db;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 数据库sql语句</span><span class="hljs-comment">// w3school sql 语句学习：http://www.w3school.com.cn/sql/sql_distinct.asp</span><span class="hljs-comment">/**</span><span class="hljs-comment"> 插入数据</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)insert &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-built_in">NSString</span> *name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"liven-%d"</span>,arc4random_uniform(<span class="hljs-number">100</span>)];        [<span class="hljs-keyword">self</span>.db executeUpdate:<span class="hljs-string">@"INSERT INTO t_student (name,age) VALUES (?,?)"</span>,name,@(arc4random_uniform(<span class="hljs-number">40</span>))];    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> 删除</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)delete &#123;    <span class="hljs-comment">// 清空数据库表的数据(这只是删除所有行的数据，并不会对表的结构、属性和索性有影响)</span>    <span class="hljs-comment">//（即使数据库没有这张表，删除也不会崩溃，只会报错）</span>    [<span class="hljs-keyword">self</span>.db executeUpdate:<span class="hljs-string">@"DELETE FROM t_student"</span>];        <span class="hljs-comment">// 删除某一行：DELETE FROM 表名称 WHERE 列名称 = 值</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> 更新</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)update &#123;    <span class="hljs-comment">// 公式：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</span>  [<span class="hljs-keyword">self</span>.db executeUpdate:<span class="hljs-string">@"UPDATE t_student SET age=? WHERE name='大力'"</span>,@(<span class="hljs-number">18</span>)];&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> 查询</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)query &#123;    FMResultSet *resultSet = [<span class="hljs-keyword">self</span>.db executeQuery:<span class="hljs-string">@"SELECT * FROM t_student"</span>];    <span class="hljs-keyword">while</span> ([resultSet next]) &#123;        <span class="hljs-keyword">int</span> ID = [resultSet intForColumn:<span class="hljs-string">@"id"</span>];        <span class="hljs-built_in">NSString</span> *name = [resultSet stringForColumn:<span class="hljs-string">@"name"</span>];        <span class="hljs-keyword">int</span> age = [resultSet intForColumn:<span class="hljs-string">@"age"</span>];        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d %@ %d"</span>,ID,name,age);    &#125;&#125;</code></pre><h1 id="2、批处理"><a href="#2、批处理" class="headerlink" title="2、批处理"></a>2、批处理</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 批处理</span>- (<span class="hljs-keyword">void</span>)lotOperation &#123;    <span class="hljs-built_in">NSString</span> *creatSqlString = <span class="hljs-string">@"CREATE TABLE IF NOT EXISTS t_person (id integer PRINARY KEY AUTOINCREMENT,name text NOT NULL, age integer NOT NULL, age integer NOT NULL);"</span>    <span class="hljs-string">@"CREATE TABLE IF NOT EXISTS t_student (id integer PRINARY KEY AUTOINCREMENT,name text NOT NULL, age integer NOT NULL, age integer NOT NULL);"</span>;    [<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        [db executeStatements:creatSqlString];    &#125;];&#125;</code></pre><h1 id="3、线程安全databaseQueue"><a href="#3、线程安全databaseQueue" class="headerlink" title="3、线程安全databaseQueue"></a>3、线程安全databaseQueue</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - dataBaseQueue线程安全</span>- (<span class="hljs-keyword">void</span>)dataBaseQueueAction &#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">      备注：</span><span class="hljs-comment">        1、FMDatabaseQueue初始化时已将数据库打开和关闭封装好了，所以操作时不需要单独调用FMDatabase的open和close方法</span><span class="hljs-comment">        2、FMDatabaseQueue是基于同步串行队列保证数据库访问的安全性，所以不能叠加使用，避免死锁</span><span class="hljs-comment">     */</span>        <span class="hljs-comment">// 获取数据库队列</span>    FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:<span class="hljs-keyword">self</span>.fileName];    [queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        <span class="hljs-built_in">BOOL</span> resutl = [db executeUpdate:<span class="hljs-string">@"CREATE TABLE IF NOT EXISTS t_person (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL);"</span>];        <span class="hljs-keyword">if</span> (resutl) &#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"创表成功"</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"创表失败"</span>);        &#125;    &#125;];    <span class="hljs-keyword">self</span>.queue = queue;        <span class="hljs-comment">// 插入数据</span>    [<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"wendingding"</span>,@(<span class="hljs-number">22</span>)];    &#125;];        <span class="hljs-comment">// 查询</span>    [<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        FMResultSet *resultSet = [db executeQuery:<span class="hljs-string">@"SELECT * FROM t_person"</span>];        <span class="hljs-keyword">while</span> ([resultSet next]) &#123;            <span class="hljs-keyword">int</span> ID = [resultSet intForColumn:<span class="hljs-string">@"id"</span>];            <span class="hljs-built_in">NSString</span> *name = [resultSet stringForColumn:<span class="hljs-string">@"name"</span>];            <span class="hljs-keyword">int</span> age = [resultSet intForColumn:<span class="hljs-string">@"age"</span>];            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d %@ %d"</span>,ID,name,age);        &#125;    &#125;];        <span class="hljs-comment">/*</span><span class="hljs-comment">     备注：</span><span class="hljs-comment">     https://stackoverflow.com/questions/15720272/when-to-close-sqlite-database-using-fmdb</span><span class="hljs-comment">     数据库不需频繁的切换open和close两种状态，否则会造成不小的性能损耗(如cpu使用率)，FMDB的作者也提到</span><span class="hljs-comment">     只有在需要更改数据库模式的时候才需要切换状态，即使是退到后台线程也是不需要关闭的，维持数据打开的状态就可以</span><span class="hljs-comment">     */</span>    &#125;</code></pre><h1 id="4、事务"><a href="#4、事务" class="headerlink" title="4、事务"></a>4、事务</h1><pre><code class="hljs objc"><span class="hljs-comment">// 事务:所有任务执行完成后才再将结果一次性提交到数据库</span><span class="hljs-comment">// 特点:要么全部成功，要么全部失败(如果中途出现问题，则会回滚)</span><span class="hljs-comment">// 注意：开启事务比不开事务的耗时更少</span>[<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;    <span class="hljs-comment">// 开启事务</span>    [db beginTransaction];    <span class="hljs-built_in">BOOL</span> first = [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"lucky"</span>,@(<span class="hljs-number">22</span>)];    <span class="hljs-built_in">BOOL</span> second = [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"james"</span>,@(<span class="hljs-number">22</span>)];    <span class="hljs-comment">// 如果其中一个失败，则结束，数据回滚</span>    <span class="hljs-keyword">if</span> (!first || !second) &#123;        [db rollback];        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-comment">// 提交事务</span>    [db commit];&#125;];<span class="hljs-comment">// 另外一种实现方式</span>[<span class="hljs-keyword">self</span>.queue inTransaction:^(FMDatabase * _Nonnull db, <span class="hljs-built_in">BOOL</span> * _Nonnull rollback) &#123;    <span class="hljs-built_in">BOOL</span> first = [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"wendi"</span>,@(<span class="hljs-number">22</span>)];    <span class="hljs-built_in">BOOL</span> second = [db executeUpdate:<span class="hljs-string">@"INSERT INTO t_person (name,age) VALUES (?,?);"</span>,<span class="hljs-string">@"davi"</span>,@(<span class="hljs-number">22</span>)];    <span class="hljs-keyword">if</span> (!first || !second) &#123;        *rollback = <span class="hljs-literal">YES</span>;        <span class="hljs-keyword">return</span> ;    &#125;&#125;];</code></pre><h1 id="5、判断某张表是否存在"><a href="#5、判断某张表是否存在" class="headerlink" title="5、判断某张表是否存在"></a>5、判断某张表是否存在</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 判断某张表是否存在</span>- (<span class="hljs-keyword">void</span>)chectDatabaseTableExists &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     备注：</span><span class="hljs-comment">        sqlite中有一个内k建表sqlite_master,这个表中存储这个所有自建表的表名称等信息</span><span class="hljs-comment">        可以通过：select * from sqlite_master 查看这个内建表的所有记录</span><span class="hljs-comment">     </span><span class="hljs-comment">     </span><span class="hljs-comment">        引申：判断指定的表是否存在，可以用如下语句</span><span class="hljs-comment">        select count(*) from sqlite_master wheretype='table' and name='要查询的表名'</span><span class="hljs-comment">        如果查询结果大于0，表示该表存在于数据库中，否则不存在</span><span class="hljs-comment">     </span><span class="hljs-comment">        详情：</span><span class="hljs-comment">        https://blog.csdn.net/aflyeaglenku/article/details/50884837</span><span class="hljs-comment">     */</span>&#125;</code></pre><h1 id="6、检测字段是否存在-并且添加字段"><a href="#6、检测字段是否存在-并且添加字段" class="headerlink" title="6、检测字段是否存在(并且添加字段)"></a>6、检测字段是否存在(并且添加字段)</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 检测字段是否存在(并且添加字段)</span>- (<span class="hljs-keyword">void</span>)checkDatabaseColumn &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        sqlite中并没有直接删除列和重命名列名称的sql语句，但是可以使用下面的思路实现同样的效果</span><span class="hljs-comment">        1、新建一个新表(新表的字段除了要删除的字段外，其余的都要)</span><span class="hljs-comment">        2、将旧表的值copy到新表</span><span class="hljs-comment">        3、删除旧表</span><span class="hljs-comment">        4、重命名表表名</span><span class="hljs-comment">     </span><span class="hljs-comment">        详情：</span><span class="hljs-comment">        https://blog.csdn.net/aflyeaglenku/article/details/50884837</span><span class="hljs-comment">     */</span>        [<span class="hljs-keyword">self</span>.queue inDatabase:^(FMDatabase * _Nonnull db) &#123;        <span class="hljs-keyword">if</span> ([db columnExists:<span class="hljs-string">@"phone"</span> inTableWithName:<span class="hljs-string">@"t_person"</span>]) &#123;            <span class="hljs-comment">// 如果t_person表中存在phone这个字段，不需要操作</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">// 如果t_person表中不存在phone这个字段，插入列</span>            [db executeUpdate:<span class="hljs-string">@"ALTER TABLE t_person ADD phone text"</span>];        &#125;    &#125;];&#125;</code></pre><h1 id="7、表迁移"><a href="#7、表迁移" class="headerlink" title="7、表迁移"></a>7、表迁移</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 表迁移</span>- (<span class="hljs-keyword">void</span>)updateToNewTable &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     这功能主要是表设计结构变更的时候需要使用</span><span class="hljs-comment">     思路：</span><span class="hljs-comment">        重新创建一个表</span><span class="hljs-comment">        将旧表数据导入到新的表中</span><span class="hljs-comment">        删除旧表</span><span class="hljs-comment">     */</span>&#125;</code></pre><h1 id="8、多表联查-重点：此处先介绍左连、右连、内连的概念"><a href="#8、多表联查-重点：此处先介绍左连、右连、内连的概念" class="headerlink" title="8、多表联查(重点：此处先介绍左连、右连、内连的概念)"></a>8、多表联查(重点：此处先介绍左连、右连、内连的概念)</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 多表连查 join</span>- (<span class="hljs-keyword">void</span>)mulTable &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     左连接：左边有的，右边没有的为null</span><span class="hljs-comment">     右连接：左边没有的，右边有的为null</span><span class="hljs-comment">     内连接：显示左边右边共有的</span><span class="hljs-comment">     </span><span class="hljs-comment">     详情介绍：</span><span class="hljs-comment">     https://blog.csdn.net/wang0112233/article/details/78418698</span><span class="hljs-comment">     https://blog.csdn.net/plg17/article/details/78758593</span><span class="hljs-comment">     */</span>        <span class="hljs-comment">// 实例：比如有两个表A和B,联查条件A.a字段与B.b字段相同</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"select A.*,B.* from A left join B on(A.a = B.b)"</span>);&#125;</code></pre><h1 id="9、创建索引"><a href="#9、创建索引" class="headerlink" title="9、创建索引"></a>9、创建索引</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 创建索引(有索引后查找速度更快速)</span>- (<span class="hljs-keyword">void</span>)createIndex &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        备注：</span><span class="hljs-comment">        1、在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</span><span class="hljs-comment">        2、更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。</span><span class="hljs-comment">           因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引</span><span class="hljs-comment">     </span><span class="hljs-comment">        公式：CREATE INDEX index_name ON table_name (column_name)</span><span class="hljs-comment">        详情介绍：</span><span class="hljs-comment">        http://www.w3school.com.cn/sql/sql_create_index.asp</span><span class="hljs-comment">     */</span>        <span class="hljs-comment">// 实例：创建一个简单的索引，名为 "PersonIndex"，在 Person 表的 LastName 列：</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"CREATE INDEX PersonIndex ON Person(LastName)"</span>);&#125;</code></pre><h1 id="10、数据库的删除-清空"><a href="#10、数据库的删除-清空" class="headerlink" title="10、数据库的删除(清空)"></a>10、数据库的删除(清空)</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 数据库的删除(清空)</span>- (<span class="hljs-keyword">void</span>)clearTable &#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">        1、删除表(表的结构、属性以及索引也会被删除)</span><span class="hljs-comment">        DROP TABLE表名称</span><span class="hljs-comment">     </span><span class="hljs-comment">        2、删除数据库</span><span class="hljs-comment">        DROP DATABASE数据库名称</span><span class="hljs-comment">     </span><span class="hljs-comment">        3、清空表内的数据，但并不删除表本身</span><span class="hljs-comment">        TRUNCATE TABLE表名称</span><span class="hljs-comment">     </span><span class="hljs-comment">     */</span>&#125;</code></pre><h1 id="11、统计表的数据"><a href="#11、统计表的数据" class="headerlink" title="11、统计表的数据"></a>11、统计表的数据</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 统计表的数据</span>- (<span class="hljs-keyword">void</span>)tableCount &#123;        <span class="hljs-comment">// 统计某表（如Person）的数据量</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"SELECT COUNT(*) FROM Person"</span>);        <span class="hljs-comment">// 统计某表某列的数据量（如：Person中name的数量，备注：NULL不计入）</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"SELECT COUNT(name) FROM Person"</span>);&#125;</code></pre><h1 id="12、分页读取数据"><a href="#12、分页读取数据" class="headerlink" title="12、分页读取数据"></a>12、分页读取数据</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 分页读取数据</span>- (<span class="hljs-keyword">void</span>)pageData &#123;    <span class="hljs-comment">// 实例：分页获取表Person中数据，每页20条</span>    <span class="hljs-comment">// 从第0行开始获取 一次获取20条</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"SELECT * FROM Person LIMIT 0,20"</span>);    <span class="hljs-comment">// 从第21行开始获取 一次获取20条</span>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"SELECT * FROM Person LIMIT 20,20"</span>);    &#125;</code></pre><h1 id="13、数据写入和读出处理-如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理"><a href="#13、数据写入和读出处理-如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理" class="headerlink" title="13、数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)"></a>13、数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)</h1><pre><code class="hljs objc"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> mark - 数据写入和读出处理(如写入的内容包括一些特殊的转义字符，这些直接写入会导致失败，所以需要特殊处理)</span>- (<span class="hljs-built_in">NSString</span> *)inDBReplaceStr:(<span class="hljs-built_in">NSString</span> *)inStr &#123;    <span class="hljs-built_in">NSString</span> *tempStr = inStr;    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/"</span> withString:<span class="hljs-string">@"//"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"'"</span> withString:<span class="hljs-string">@"''"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"["</span> withString:<span class="hljs-string">@"/["</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"]"</span> withString:<span class="hljs-string">@"/]"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"%"</span> withString:<span class="hljs-string">@"/%"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"&amp;"</span> withString:<span class="hljs-string">@"/&amp;"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"_"</span> withString:<span class="hljs-string">@"/_"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"("</span> withString:<span class="hljs-string">@"/("</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@")"</span> withString:<span class="hljs-string">@"/)"</span>];    <span class="hljs-keyword">return</span> tempStr;&#125;- (<span class="hljs-built_in">NSString</span> *)outDBReplaceStr:(<span class="hljs-built_in">NSString</span> *)outStr &#123;    <span class="hljs-built_in">NSString</span> *tempStr = outStr;    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"//"</span> withString:<span class="hljs-string">@"/"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"''"</span> withString:<span class="hljs-string">@"'"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/["</span> withString:<span class="hljs-string">@"["</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/]"</span> withString:<span class="hljs-string">@"]"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/%"</span> withString:<span class="hljs-string">@"%"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/&amp;"</span> withString:<span class="hljs-string">@"&amp;"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/_"</span> withString:<span class="hljs-string">@"_"</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/("</span> withString:<span class="hljs-string">@"("</span>];    tempStr = [tempStr stringByReplacingOccurrencesOfString:<span class="hljs-string">@"/)"</span> withString:<span class="hljs-string">@")"</span>];    <span class="hljs-keyword">return</span> tempStr;&#125;</code></pre><h1 id="数据库的封装"><a href="#数据库的封装" class="headerlink" title="数据库的封装"></a>数据库的封装</h1><p><img src="https://i.loli.net/2020/05/18/MyLpRig83CkEv97.png" srcset="/img/loading.gif" alt="image-20200518155431105"></p><p><a href="https://pan.baidu.com/s/1aXkiPCs3ze4bdsbl6Qn2VA" target="_blank" rel="noopener">完整DEMO</a></p>]]></content>
    
    
    <categories>
      
      <category>Object-C</category>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Base</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS脚本打包一学就会</title>
    <link href="/2020/05/14/iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E4%B8%80%E5%AD%A6%E5%B0%B1%E4%BC%9A/"/>
    <url>/2020/05/14/iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E4%B8%80%E5%AD%A6%E5%B0%B1%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>上篇文章提到的Jenkins打包，因为需要配置参数比较多，并且坑也比较多，要运行起来确实比较不容易，本人虽然是很早就有接触到Jenkins，但由于一直配置不成功，而放弃了。所以在此之前另寻路径，学了其他比较简单的自动化打包方式，比如Python和接下来要讲的shell脚本。</p><p>条条道路通罗马，不管哪种方式，能提高效率和解放双手的都可以。自动打包确实会比手动打包的快，操作简单，一句代码就解决。</p><p>这种方式对于小项目，比如我现在的公司来说，是够用得了，只有一个iOS开发人员，项目配置也比较简单，所以够用了。</p><p><strong>备注</strong>：使用前提==Xcode证书配置使用<code>自动获取</code>（Automatically manager signing）的方式,并且项目运行正常</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h4 id="第一步：下载脚本文件夹"><a href="#第一步：下载脚本文件夹" class="headerlink" title="第一步：下载脚本文件夹"></a>第一步：下载脚本文件夹</h4><p>链接:<a href="https://pan.baidu.com/s/1Sj19uzzzKu7TJdXMJ6smZw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Sj19uzzzKu7TJdXMJ6smZw</a>  密码:9buq</p><p>下载完成后，将文件夹拉到项目根目录中</p><p><img src="https://i.loli.net/2020/05/18/VxHuq5r7ikIE3OF.png" srcset="/img/loading.gif" alt="image-20200518103113243"></p><h4 id="第二步：配置脚本文件"><a href="#第二步：配置脚本文件" class="headerlink" title="第二步：配置脚本文件"></a>第二步：配置脚本文件</h4><p>（1）修改<code>debug_config.plist</code>文件</p><p><img src="https://i.loli.net/2020/05/18/tkrRLco8DHdjOIK.png" srcset="/img/loading.gif" alt="image-20200518101737159"></p><p>（2）修改<code>test.sh</code>文件配置</p><p>只需要修改头部几个变量的值，备注已注明</p><p><img src="https://i.loli.net/2020/05/18/caUnCg9yLwtKufA.png" srcset="/img/loading.gif" alt="image-20200518101916357"></p><h4 id="第三步：运行脚本"><a href="#第三步：运行脚本" class="headerlink" title="第三步：运行脚本"></a>第三步：运行脚本</h4><p>cd 项目目录下的debug文件夹</p><p>终端输入</p><pre><code class="hljs plain">bash -l test.sh</code></pre><h4 id="第四步：安静的等待脚本执行完成即可"><a href="#第四步：安静的等待脚本执行完成即可" class="headerlink" title="第四步：安静的等待脚本执行完成即可"></a>第四步：安静的等待脚本执行完成即可</h4><p><img src="https://i.loli.net/2020/05/18/Z62PQYgifw5HkB7.png" srcset="/img/loading.gif" alt="image-20200518102152874"></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins自动打包--从零开始</title>
    <link href="/2020/05/14/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85-Jenkins/"/>
    <url>/2020/05/14/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85-Jenkins/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Jenkins是基于Java开发的一种持续集成工具，支持自动化、部署、构建。</p><p>简而言之，对于开发者可以避免做重复并且耗时的事情，专注于代码的开发(测试的小姐姐就不用每次跟我要安装包)</p><p>篇幅较长，请耐心看完，本人亲测有效。</p><p>写文不容易，翻阅了多篇博客，构建失败将近50次，总结的文章，除了文字描述，也附上图片说明，方便阅读。</p><p>如果喜欢本文的，请打赏一分支持</p><h1 id="二、Jenkins安装"><a href="#二、Jenkins安装" class="headerlink" title="二、Jenkins安装"></a>二、Jenkins安装</h1><h4 id="2-0-java-SDK-安装"><a href="#2-0-java-SDK-安装" class="headerlink" title="2.0 java SDK 安装"></a>2.0 java SDK 安装</h4><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">下载地址</a>,双击完成安装</p><h4 id="2-1-安装方式："><a href="#2-1-安装方式：" class="headerlink" title="2.1 安装方式："></a>2.1 安装方式：</h4><p>(1)<a href="https://www.jenkins.io/zh/download/" target="_blank" rel="noopener">官网</a>下载最新版的Jenkins安装包pkg（<a href="">其他版本下载地址</a>）</p><p>双击安装包，按指导完成安装</p><p>(2)Homebrew工具下载</p><pre><code class="hljs plain">brew install jenkins</code></pre><h4 id="2-2-安装结束后，终端输入命令："><a href="#2-2-安装结束后，终端输入命令：" class="headerlink" title="2.2 安装结束后，终端输入命令："></a>2.2 安装结束后，终端输入命令：</h4><pre><code class="hljs plain">jenkins</code></pre><p>启动服务完毕后，在浏览器中打开<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><h4 id="2-3-根据提示路径打开initialAdminPassword文件，复制密码登录"><a href="#2-3-根据提示路径打开initialAdminPassword文件，复制密码登录" class="headerlink" title="2.3 根据提示路径打开initialAdminPassword文件，复制密码登录"></a>2.3 根据提示路径打开initialAdminPassword文件，复制密码登录</h4><p><img src="https://i.loli.net/2020/05/14/epd8L24Eho5QTY6.png" srcset="/img/loading.gif" alt="image-20200514175313623"></p><p>（PS：如果因为权限问题打不开initialAdminPassword文件，请先跳转目录第三：修复jenkins文件权限后再操作）</p><h4 id="2-4-安装推荐插件"><a href="#2-4-安装推荐插件" class="headerlink" title="2.4 安装推荐插件"></a>2.4 安装推荐插件</h4><p>备注：插件安装不一定会一次性全都安装成功，如果失败了，可以点击重试，如果重试还是有没安装成功的，则选择跳过，继续执行下一步，完成Jenkins的安装，因为插件可以在后续继续完成</p><p>(备注：如果Jenkins插件多次在线安装失败，可以先下载<a href="https://updates.jenkins-ci.org/download/plugins/" target="_blank" rel="noopener">插件</a>,下载成功后，在插件管理界面选择【高级】上传的方式安装)</p><p><img src="https://i.loli.net/2020/05/14/pW5wqIvCajTPlgR.png" srcset="/img/loading.gif" alt="image-20200514175232751"></p><p><img src="https://i.loli.net/2020/05/14/vtQ2SFZsNeVx1Kj.png" srcset="/img/loading.gif" alt="image-20200514175258436"></p><h4 id="2-5-设置管理账号"><a href="#2-5-设置管理账号" class="headerlink" title="2.5 设置管理账号"></a>2.5 设置管理账号</h4><p><img src="https://i.loli.net/2020/05/14/Y7lsWZN8Ldvkbae.png" srcset="/img/loading.gif" alt="image-20200514184912707"></p><h4 id="2-6-输入管理账号登录"><a href="#2-6-输入管理账号登录" class="headerlink" title="2.6 输入管理账号登录"></a>2.6 输入管理账号登录</h4><p><img src="https://i.loli.net/2020/05/15/eAvEiq63pkdagXu.png" srcset="/img/loading.gif" alt="image-20200515094050171"></p><h1 id="三、修改Jenkins文件访问权限"><a href="#三、修改Jenkins文件访问权限" class="headerlink" title="三、修改Jenkins文件访问权限"></a>三、修改Jenkins文件访问权限</h1><p>这一步很关键，会影响接下来操作出现莫名的失败，比如证书的配置、代码的拉取等</p><p>首先，安装好Jenkins之后，会默认在Mac登录用户系统中添加一个“Jenkins”的登陆用户，而在Jenkins的主目录文件夹及其子文件夹的访问权限都是只有Mac Jenkins登录用户能读写</p><p><img src="https://i.loli.net/2020/05/15/9J6pEIYFazLysc5.png" srcset="/img/loading.gif" alt="image-20200515101951144"></p><p>（1）停止Jenkins</p><pre><code class="hljs plain">sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p>（2）打开Jenkins配置文件</p><pre><code class="hljs plain">sudo vim &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p><img src="https://i.loli.net/2020/05/15/AQOZ19vUD86zcxI.png" srcset="/img/loading.gif" alt="image-20200515162016570"></p><p><img src="https://i.loli.net/2020/05/15/Q7oHyfUvtWAgmuX.png" srcset="/img/loading.gif" alt="image-20200515162124239"></p><p>（3）运行以下命令，使配置修改生效</p><pre><code class="hljs plain">sudo chown -R yyk:daemon &#x2F;Users&#x2F;Shared&#x2F;Jenkins&#x2F;sudo chown -R yyk:daemon &#x2F;var&#x2F;log&#x2F;jenkins&#x2F;</code></pre><p>（4）启动Jenkins，完成权限修改</p><pre><code class="hljs plain">sudo launchctl load &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</code></pre><p><img src="https://i.loli.net/2020/05/15/uLb8qFNJ215wo4g.png" srcset="/img/loading.gif" alt="image-20200515163217384"></p><h1 id="四、插件安装及配置"><a href="#四、插件安装及配置" class="headerlink" title="四、插件安装及配置"></a>四、插件安装及配置</h1><h4 id="4-0-打开管理界面"><a href="#4-0-打开管理界面" class="headerlink" title="4.0 打开管理界面"></a>4.0 打开管理界面</h4><p><img src="https://i.loli.net/2020/05/15/ILy63UZTptOeD5i.png" srcset="/img/loading.gif" alt="image-20200515094540316"></p><h4 id="4-1-打开插件管理"><a href="#4-1-打开插件管理" class="headerlink" title="4.1 打开插件管理"></a>4.1 打开插件管理</h4><p><img src="https://i.loli.net/2020/05/15/ulNab1tfmWABZG4.png" srcset="/img/loading.gif" alt="image-20200515094621266"></p><h4 id="4-2-安装插件"><a href="#4-2-安装插件" class="headerlink" title="4.2 安装插件"></a>4.2 安装插件</h4><p>有三个插件是必须额外安装：</p><p>(1) 代码管理插件Git</p><p>​    本人用的是码云Gitee管理代码，所以需要安装一个gitee插件</p><p>(2) 代码打包使用：XCode 插件</p><p>(3) 钥匙串及证书管理工具： Keychain and Provisioning Profiles Management</p><p><img src="https://i.loli.net/2020/05/15/RpCiXuOqMPJDeTZ.png" srcset="/img/loading.gif" alt="image-20200515095036236"></p><p><img src="https://i.loli.net/2020/05/15/k3xP6uAYOyNDdVS.png" srcset="/img/loading.gif" alt="image-20200515100234175"></p><p><img src="https://i.loli.net/2020/05/15/M7OJhuKa4Rvjtfc.png" srcset="/img/loading.gif" alt="image-20200515103305563"></p><h4 id="4-3-插件配置"><a href="#4-3-插件配置" class="headerlink" title="4.3 插件配置"></a>4.3 插件配置</h4><p><img src="https://i.loli.net/2020/05/15/Rq6mtnB7YTkgiCp.png" srcset="/img/loading.gif" alt="image-20200515112009897"></p><p>(1) 上传keychains 文件</p><p>keychains文件存放路径：<code>~/Library/Keychains</code></p><p><img src="https://i.loli.net/2020/05/15/IJ3LPUnbX9wQv6d.png" srcset="/img/loading.gif" alt="image-20200515112322044"></p><p>（2）Provisioning Profiles Directory Path 路径</p><p><code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code></p><p>（3）上传配置文件：Provisioning Profile</p><p>如果没有了，则登录<a href="https://developer.apple.com" target="_blank" rel="noopener">苹果开发网址</a>重新生成，只需要开发证书和生产证书</p><p>（4）配置完成的界面</p><p>备注：需要校验上传的开发证书和测试证书对应的UUID，在<code>Provisioning Profiles Directory Path</code>文件夹中是否存在，如果不存在也是会出现本文提到的<code>问题二</code></p><p><img src="https://i.loli.net/2020/05/15/Tg1JiLMfS89hHRA.png" srcset="/img/loading.gif" alt="image-20200515113355974"></p><p><strong>PS：如果项目是有用CocoPods，则需要修改系统配置</strong></p><p>终端输入</p><pre><code class="hljs plain">echo $PATH</code></pre><p>复制输出内容</p><p><img src="https://i.loli.net/2020/05/15/T2Eh6g7aGuLlXdv.png" srcset="/img/loading.gif" alt="image-20200515135717113"></p><p><img src="https://i.loli.net/2020/05/15/U5Cg1dVPOonDjy4.png" srcset="/img/loading.gif" alt="image-20200515135849747"></p><h1 id="五、新建任务"><a href="#五、新建任务" class="headerlink" title="五、新建任务"></a>五、新建任务</h1><h4 id="5-0-创建自由风格工程"><a href="#5-0-创建自由风格工程" class="headerlink" title="5.0 创建自由风格工程"></a>5.0 创建自由风格工程</h4><p><img src="https://i.loli.net/2020/05/15/cDEXgAT4PhemkR9.png" srcset="/img/loading.gif" alt="image-20200515114306575"></p><p><img src="https://i.loli.net/2020/05/15/Dh5uYBUHFQG6stV.png" srcset="/img/loading.gif" alt="image-20200515114411371"></p><h4 id="5-1-General-项配置"><a href="#5-1-General-项配置" class="headerlink" title="5.1 General 项配置"></a>5.1 General 项配置</h4><p><img src="https://i.loli.net/2020/05/15/RlpH5QLohaMeDjV.png" srcset="/img/loading.gif" alt="image-20200515114722913"></p><h4 id="5-2-源码管理"><a href="#5-2-源码管理" class="headerlink" title="5.2 源码管理"></a>5.2 源码管理</h4><p><img src="https://i.loli.net/2020/05/15/ayDpQMf4BiqUCAe.png" srcset="/img/loading.gif" alt="image-20200515115320879"></p><p>PS: ssh密钥生成命令</p><pre><code class="hljs plain">$ cat ~&#x2F;.ssh&#x2F;id_rsa</code></pre><p>复制密钥时一定要将<code>-----BEGIN RSA PRIVATE KEY-----</code>和<code>-----END RSA PRIVATE KEY-----</code>一起复制</p><p><img src="https://i.loli.net/2020/05/15/xgoGJylOtUDTFdu.png" srcset="/img/loading.gif" alt="image-20200515120011740"></p><p><img src="https://i.loli.net/2020/05/15/U5WoP1DXARaxdv7.png" srcset="/img/loading.gif" alt="image-20200515120347621"></p><p><img src="https://i.loli.net/2020/05/15/QgiTUVtj3qGExvB.png" srcset="/img/loading.gif" alt="image-20200515115446447"></p><h4 id="5-3-构建配置"><a href="#5-3-构建配置" class="headerlink" title="5.3 构建配置"></a>5.3 构建配置</h4><p>（1）添加<code>Execute shell</code> 和<code>Xcode</code></p><p><img src="https://i.loli.net/2020/05/15/V18cEzLuJkiOx2N.png" srcset="/img/loading.gif" alt="image-20200515120627317"></p><p>（2）添加shell代码</p><pre><code class="hljs plain">export LANG&#x3D;en_US.UTF-8export LANGUAGE&#x3D;en_US.UTF-8export LC_ALL&#x3D;en_US.UTF-8pod install</code></pre><p><img src="https://i.loli.net/2020/05/15/GeUxkSYn5Z8NyaV.png" srcset="/img/loading.gif" alt="image-20200515121053406"></p><p>（3）Xcode 设置</p><p><img src="https://i.loli.net/2020/05/15/FIVhd28qNHkPivS.png" srcset="/img/loading.gif" alt="image-20200515121332662"></p><blockquote><p>teamid 可以在钥匙串中找到对应的证书，其双括号内的字符串就是teamId</p><p><img src="https://i.loli.net/2020/05/15/xPdnr3DSUIobvCZ.png" srcset="/img/loading.gif" alt="image-20200515121248304"></p></blockquote><p><img src="https://i.loli.net/2020/05/15/QuqzBp1A4UgPWro.png" srcset="/img/loading.gif" alt="image-20200515122523325"></p><p><img src="https://i.loli.net/2020/05/15/5C2NReYgkyFoLmA.png" srcset="/img/loading.gif" alt="image-20200515122300749"></p><h4 id="5-4-Code-signing-amp-OS-X-keychain-options-配置"><a href="#5-4-Code-signing-amp-OS-X-keychain-options-配置" class="headerlink" title="5.4 Code signing &amp; OS X keychain options 配置"></a>5.4 Code signing &amp; OS X keychain options 配置</h4><p><img src="https://i.loli.net/2020/05/15/9LlGQPmUWynzZhg.png" srcset="/img/loading.gif" alt="image-20200515122958510"></p><h4 id="5-5-Advanced-Xcode-build-options-配置"><a href="#5-5-Advanced-Xcode-build-options-配置" class="headerlink" title="5.5 Advanced Xcode build options 配置"></a>5.5 Advanced Xcode build options 配置</h4><p><img src="https://i.loli.net/2020/05/15/eT2gsG1YRPNfV5X.png" srcset="/img/loading.gif" alt="image-20200515133436256"></p><h1 id="六、可能会遇到的问题"><a href="#六、可能会遇到的问题" class="headerlink" title="六、可能会遇到的问题"></a>六、可能会遇到的问题</h1><blockquote><p>问题一：FATAL:Failed to copy ….mobileprovision文件</p><p><img src="https://i.loli.net/2020/05/14/SGyoWFXNt48hPa7.png" srcset="/img/loading.gif" alt="image-20200514140913355"></p><p>解决方法</p><p><img src="https://i.loli.net/2020/05/14/AwOIsMch4iPfjoT.png" srcset="/img/loading.gif" alt="image-20200514141426735"></p><p><img src="https://i.loli.net/2020/05/14/OQo4XysuDTCNqWY.png" srcset="/img/loading.gif" alt="image-20200514141708063"></p></blockquote><blockquote><p>问题二：Execute Shell 脚本代码中的 Pod install 执行错误</p><p><img src="https://i.loli.net/2020/05/14/uULrbqH21W9tPB7.png" srcset="/img/loading.gif" alt="image-20200514141832527"></p><p>解决方法：</p><p>终端输入 echo $PATH</p><p>将输入的PATH值复制，然后到Jenkins的系统管理设置</p><p><img src="https://i.loli.net/2020/05/14/xrASPOGgeLVo6w8.png" srcset="/img/loading.gif" alt="image-20200514143727060"></p></blockquote><h1 id="七、待续"><a href="#七、待续" class="headerlink" title="七、待续"></a>七、待续</h1><p>至此我们实现可持续开发的第一步，自动化打包，除此之外还需要配置多个scheme，打出不同环境的安装包</p><p>比如测试妹纸需要一个SIT包，产品经理需要一个SIM包等等，因为我们总不能修改一下代码，提交一下，打一个包，再修改代码再提交再打包，这样的操作依然需要开发人员的配合，增添了不少的成本。</p><p>对此下一篇则会侧重点解决这个问题</p><pre><code class="hljs plain">DEV Development 研发环境SIT System Integrate Test 系统集成测试环境（内测）UAT User Acceptance Test 用户验收测试环境PET Performance Evaluation Test 性能评估测试环境（压测）SIM Simulation 高仿真环境&#x2F;预发布PRD&#x2F;PROD Production 正式&#x2F;生产环境</code></pre><h1 id="八、参考文章"><a href="#八、参考文章" class="headerlink" title="八、参考文章"></a>八、参考文章</h1><p><a href="http://paocai.site/2020/04/27/iOS%20最新Jenkins自动化打包配置完整教程/#&gid=1&pid=13" target="_blank" rel="noopener">iOS 最新Jenkins自动化打包配置完整教程</a></p><p><a href="https://www.jianshu.com/p/70e4335b0bd6" target="_blank" rel="noopener">Jenins自动打包</a></p><p><a href="https://www.jianshu.com/p/04b5fe2e8598" target="_blank" rel="noopener">Mac修改jenkins进程默认账户解决权限问题</a></p><p><a href="https://www.jianshu.com/p/5be50ee32450" target="_blank" rel="noopener">CocoaPods管理的项目配置Jenkins遇到的坑</a></p><p><a href="https://www.jianshu.com/p/8b2fc2da0466" target="_blank" rel="noopener">使用 Jenkins 持续集成 iOS 项目时碰到的一些问题</a></p><p><a href="https://www.jianshu.com/p/13e34671788f" target="_blank" rel="noopener">iOS使用Jenkins+Xcode+fir 搭建持续集成环境</a></p><p><a href="https://www.jietusoft.com/faq/detail/262.html" target="_blank" rel="noopener">苹果证书的介绍和申请教程</a></p><center class="half"> <div>感谢你“一分”支持</div>   <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Github 搭建博客完整版</title>
    <link href="/2020/04/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/04/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Hexo搭建"><a href="#一、Hexo搭建" class="headerlink" title="一、Hexo搭建"></a>一、Hexo搭建</h2><h3 id="1-0-环境准备-具体的参考百度文章"><a href="#1-0-环境准备-具体的参考百度文章" class="headerlink" title="1.0 环境准备(具体的参考百度文章)"></a>1.0 环境准备(具体的参考百度文章)</h3><p>a&gt; npm安装</p><p>b&gt; Git 安装</p><p>c&gt; node.js 安装（建议安装10.0以上版本）</p><h3 id="2-0-Hexo安装"><a href="#2-0-Hexo安装" class="headerlink" title="2.0 Hexo安装"></a>2.0 Hexo安装</h3><pre><code class="hljs plain">$ npm install -g hexo-cli</code></pre><p>可以输入hexo -v ，检查hexo是否安装成功</p><h3 id="3-0-搭建网站"><a href="#3-0-搭建网站" class="headerlink" title="3.0 搭建网站"></a>3.0 搭建网站</h3><h5 id="3-1-创建一个文件夹存放网站文件，比如在桌面中添加一个-Blog-文件夹"><a href="#3-1-创建一个文件夹存放网站文件，比如在桌面中添加一个-Blog-文件夹" class="headerlink" title="3.1 创建一个文件夹存放网站文件，比如在桌面中添加一个 Blog 文件夹"></a>3.1 创建一个文件夹存放网站文件，比如在桌面中添加一个 Blog 文件夹</h5><h5 id="3-2-初始化Blog文件夹（上个厕所再回来…）"><a href="#3-2-初始化Blog文件夹（上个厕所再回来…）" class="headerlink" title="3.2 初始化Blog文件夹（上个厕所再回来…）"></a>3.2 初始化Blog文件夹（上个厕所再回来…）</h5><pre><code class="hljs plain">hexo init</code></pre><p><img src="https://i.loli.net/2020/05/09/ABecuswPyQEt6kT.png" srcset="/img/loading.gif" alt="image-20200509150624387"></p><h5 id="3-3-安装所需要安装的组件"><a href="#3-3-安装所需要安装的组件" class="headerlink" title="3.3 安装所需要安装的组件"></a>3.3 安装所需要安装的组件</h5><pre><code class="hljs plain">npm install</code></pre><h5 id="3-4-生成静态文件"><a href="#3-4-生成静态文件" class="headerlink" title="3.4 生成静态文件"></a>3.4 生成静态文件</h5><pre><code class="hljs plain">hexo g</code></pre><h5 id="3-5-开启服务器，访问本地网址，体验hexo"><a href="#3-5-开启服务器，访问本地网址，体验hexo" class="headerlink" title="3.5 开启服务器，访问本地网址，体验hexo"></a>3.5 开启服务器，访问<a href="http://localhost:4000" target="_blank" rel="noopener">本地网址</a>，体验hexo</h5><pre><code class="hljs plain">hexo s</code></pre><p>这是一个激动人心的时刻，请高举92年的可乐，一起土嗨！！！！</p><p><img src="https://i.loli.net/2020/05/09/81OLJZCFreMfQ7R.png" srcset="/img/loading.gif" alt="image-20200509151727917"></p><p><em>提示：</em>如果界面无法跳转，可能是端口号被占用了，终端输入<code>ctrl + c</code> 停止服务器，接着输入 <code>hexo server -p 端口号</code> 来修改端口号</p><p><em>扩展：</em>Mac查看端口号是否被占用及释放</p><pre><code class="hljs plain">&#x2F;&#x2F; 查看使用端口号进程lsof -i:端口号&#x2F;&#x2F; 释放端口号kill 进程的PID&#x2F;&#x2F; 再次执行，查看无进程占用lsof -i:端口号</code></pre><h5 id="3-6-关联Github"><a href="#3-6-关联Github" class="headerlink" title="3.6 关联Github"></a>3.6 关联Github</h5><p>登录Github,创建库，比如本人的CallLiven.github.io，并复制https地址</p><p>（注意点是github.io的前缀一定要跟github的名称一致，否则登录网址会提示404错误，找不到对应的文件）</p><p><img src="https://i.loli.net/2020/05/09/8ErvzakRN6dsw1l.png" srcset="/img/loading.gif" alt="image-20200509152540582"></p><p>打开之前创建的<code>Blog</code>文件夹，打开<code>_config.yml</code>文件，在文件最底部编写以下内容</p><pre><code class="hljs plain"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy:  type: git  repo:  &lt;仓库地址&gt;  branch: master</code></pre><p>安装插件Git bash 将文章推到仓库</p><pre><code class="hljs plain">npm install hexo-deloper-git --save</code></pre><p>部署到远端服务器Github</p><pre><code class="hljs plain">hexo g (生成静态文件)hexo d （将本地数据部署到远端服务器）</code></pre><p>恭喜，已经成功了</p><p>浏览器直接打开：<a href="https://callliven.github.io" target="_blank" rel="noopener">https://callliven.github.io</a></p><h3 id="4-0-创建博客"><a href="#4-0-创建博客" class="headerlink" title="4.0 创建博客"></a>4.0 创建博客</h3><pre><code class="hljs plain">hexo new 文件标题</code></pre><p><img src="https://i.loli.net/2020/05/09/1oapDuFHGPSfRgB.png" srcset="/img/loading.gif" alt="image-20200509155650478"></p><p>根据路径打开md文件，开始编辑文章，比如大海啊大海，海大啊海大</p><h2 id="二、编辑博客推荐工具：Typora-下载地址"><a href="#二、编辑博客推荐工具：Typora-下载地址" class="headerlink" title="二、编辑博客推荐工具：Typora 下载地址"></a>二、编辑博客推荐工具：Typora <a href="https://www.typora.io" target="_blank" rel="noopener">下载地址</a></h2><p>PS：一定要安装最新版本的，因为最新版本的支持图床设置，也就是将拖拽的图片自动上传到设置好的服务上</p><p>(1) 上传工具：PicGo 下载地址</p><p>(2) 图床选择：SM.MS （特点：永久存储免费，图片链接支持https，可以删除上传的图片，但图片上传有限制：每张图片最大5M，每次最多上传10张）</p><h3 id="1-SM-MS注册"><a href="#1-SM-MS注册" class="headerlink" title="1.SM.MS注册"></a>1.SM.MS注册</h3><p><a href="https://sm.ms/login" target="_blank" rel="noopener">https://sm.ms/login</a></p><h3 id="2-生成token"><a href="#2-生成token" class="headerlink" title="2.生成token"></a>2.生成token</h3><p><a href="https://sm.ms/home/apitoken" target="_blank" rel="noopener">https://sm.ms/home/apitoken</a></p><h3 id="3-配置PicGo的SM-MS图床服务"><a href="#3-配置PicGo的SM-MS图床服务" class="headerlink" title="3.配置PicGo的SM.MS图床服务"></a>3.配置PicGo的SM.MS图床服务</h3><p>文件路径：~/.picgo/config.json</p><pre><code class="hljs plain">&#123;  &quot;picBed&quot;: &#123;    &quot;uploader&quot;: &quot;smms&quot;, &#x2F;&#x2F; 代表当前的默认上传图床为 SM.MS,    &quot;smms&quot;: &#123;      &quot;token&quot;: &quot;&quot; &#x2F;&#x2F; 从https:&#x2F;&#x2F;sm.ms&#x2F;home&#x2F;apitoken获取的token    &#125;  &#125;,  &quot;picgoPlugins&quot;: &#123;&#125; &#x2F;&#x2F; 为插件预留&#125;</code></pre><h3 id="4-修改Typora配置"><a href="#4-修改Typora配置" class="headerlink" title="4.修改Typora配置"></a>4.修改Typora配置</h3><p>偏好设置–&gt;图像</p><p><img src="https://i.loli.net/2020/05/08/9nfTSi5F47jcVoE.png" srcset="/img/loading.gif" alt="image-20200508175202269"></p><h3 id="5-编辑文章"><a href="#5-编辑文章" class="headerlink" title="5.编辑文章"></a>5.编辑文章</h3><p>完成以上操作就可以开始编辑文章，方式跟简书等博客是一样的</p><h2 id="三、更换主题"><a href="#三、更换主题" class="headerlink" title="三、更换主题"></a>三、更换主题</h2><p>我当前使用的主题是<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid</a>,安装方法请参考界面所介绍的。(<a href="https://hexo.io/themes/" target="_blank" rel="noopener">更多主题选择</a>)</p><p>Fluid主题预览（风格简易大气，并且支持文章搜索、标签、分类、评论等等）</p><ol><li><p>下载主题包</p></li><li><p>将主题解压，并重命名为“fluid”</p></li><li><p>将主题包拖动“Blog”文件夹中的“themes”</p></li></ol><p><img src="https://i.loli.net/2020/05/09/zEn3GPj4gxXVWRw.png" srcset="/img/loading.gif" alt="image-20200509161029217"></p><ol start="4"><li>最后一步，修改hexo主题配置</li></ol><p><img src="https://i.loli.net/2020/05/09/vY6ZAIPQiGqMag7.png" srcset="/img/loading.gif" alt="image-20200509161241944"></p><h2 id="四、个性化功能-非必须的"><a href="#四、个性化功能-非必须的" class="headerlink" title="四、个性化功能(非必须的)"></a>四、个性化功能(非必须的)</h2><p>该主题支持的个性化功能，具体的都在<code>_config.yml</code>文件中都有教程，操作非常简单，此处只介绍添加评论和音乐的方法</p><h3 id="1-添加评论"><a href="#1-添加评论" class="headerlink" title="1. 添加评论"></a>1. 添加评论</h3><p>Fluid主题支持多种评论插件，此处选择<code>Valine</code>，因为我刚好有<a href="https://leancloud.cn" target="_blank" rel="noopener">Leancloud</a>账号，并且Valine不需要提供多种资料，比较简单</p><p><img src="https://i.loli.net/2020/05/11/PsGnZXDcqeTL2Ni.png" srcset="/img/loading.gif" alt="image-20200511151845391"></p><p><img src="https://i.loli.net/2020/05/11/1Zoes23wUP9gupr.png" srcset="/img/loading.gif" alt="image-20200511151734203"></p><h3 id="2-播放音乐"><a href="#2-播放音乐" class="headerlink" title="2. 播放音乐"></a>2. 播放音乐</h3><p>安装音乐播放器插件: <a href="https://aplayer.js.org" target="_blank" rel="noopener">音乐播放插件APlayer</a></p><pre><code class="hljs plain">cd 博客文件夹npm install aplayer --save</code></pre><p>修改配置文件 <code>_config.yml</code> (需要将mp3文件拉到博客文件夹中)</p><p><img src="https://i.loli.net/2020/05/11/QVRrAqEi8FyOkJw.png" srcset="/img/loading.gif" alt="image-20200511151228772"></p><h3 id="3-统计百度统计"><a href="#3-统计百度统计" class="headerlink" title="3.统计百度统计"></a>3.统计百度统计</h3><p>注册百度统计账号:<a href="https://tongji.baidu.com/sc-web/10000203072/home/site/index?from=3" target="_blank" rel="noopener">网址</a></p><p><img src="https://i.loli.net/2020/05/11/dEcX2NUipmMIlJz.png" srcset="/img/loading.gif" alt="image-20200511200825592"></p><p><img src="https://i.loli.net/2020/05/11/noBJX8NObVx12GU.png" srcset="/img/loading.gif" alt="image-20200511200840983"></p><p><img src="https://i.loli.net/2020/05/11/dBKwlPy2Le36DY5.png" srcset="/img/loading.gif" alt="image-20200511201033923"></p><p><img src="https://i.loli.net/2020/05/11/WEZuYoTLrkmgMSn.png" srcset="/img/loading.gif" alt="image-20200511201111996"></p><p>编辑根目录Blog下的<code>_config.yml</code>文件</p><p><img src="https://i.loli.net/2020/05/11/6kvT37Ne1ayjDSQ.png" srcset="/img/loading.gif" alt="image-20200511201330541"></p><p>重新生成静态文件及部署到github上，就可以了（每次修改内容，都需要重新生成静态文件，再部署git上）</p><pre><code class="hljs plain">hexo ghexo d</code></pre><p><img src="https://i.loli.net/2020/05/11/9fjyTMAwRBiuUZ6.png" srcset="/img/loading.gif" alt="image-20200511201511851"></p><h2 id="五、Typora-常用快捷键"><a href="#五、Typora-常用快捷键" class="headerlink" title="五、Typora 常用快捷键"></a>五、Typora 常用快捷键</h2><pre><code class="hljs plain">无序列表：输入-之后输入空格有序列表：输入数字+“.”之后输入空格任务列表：-[空格]空格 文字标题：ctrl+数字表格：ctrl+t生成目录：[TOC]按回车选中一整行：ctrl+l选中单词：ctrl+d选中相同格式的文字：ctrl+e跳转到文章开头：ctrl+home跳转到文章结尾：ctrl+end搜索：ctrl+f替换：ctrl+h引用：输入&gt;之后输入空格代码块：ctrl+alt+f加粗：ctrl+b倾斜：ctrl+i下划线：ctrl+u删除线：alt+shift+5插入图片：直接拖动到指定位置即可或者ctrl+shift+i插入链接：ctrl+k</code></pre><h2 id="六、参考文章："><a href="#六、参考文章：" class="headerlink" title="六、参考文章："></a>六、参考文章：</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><p><a href="https://doc.sm.ms/" target="_blank" rel="noopener">SM.MS API 文档</a></p><p><a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#默认配置文件" target="_blank" rel="noopener">PinGo-Core官方文档</a></p><p><a href="https://www.jianshu.com/p/7b8faf77d1af" target="_blank" rel="noopener">Hexo常用指令</a></p><p><a href="https://aplayer.js.org" target="_blank" rel="noopener">音乐播放插件APlayer</a></p><p><a href="https://leancloud.cn" target="_blank" rel="noopener">Leancloud第三方服务器</a></p><center class="half"> <div>感谢你“一分”支持</div>   <img src="https://i.loli.net/2020/05/11/OJmWIEMseCDVjzx.jpg" srcset="/img/loading.gif" width="300"/><img src="https://i.loli.net/2020/05/11/qSd9hCbynVMkGv5.jpg" srcset="/img/loading.gif" width="300"/> </center>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
