<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>架构与设计模式随笔 - Liven技术博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/xcode.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>CALL ME LIVEN</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              分类</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/page/page_cover.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-07-30 11:48">
                    2020年7月30日 中午
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    4.9k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    52
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="重要结论"><a href="#重要结论" class="headerlink" title="重要结论"></a>重要结论</h1><h3 id="【继承】"><a href="#【继承】" class="headerlink" title="【继承】"></a>【继承】</h3><p><strong>Case</strong><a href="https://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="noopener">跳出面向对象思想(一) 继承</a>文中提到继承是代码复用的一种方案，但是继承同时也是紧耦合的一种模式，体现在其一发动全身，尽量避免使用继承，可以使用组合设计模式代替，除非继承成为一种需求，那么就可以使用继承。</p>
<p><strong>使用继承的三大要点：</strong></p>
<ul>
<li>父类只给子类提供服务，并不涉及子类的业务逻辑</li>
<li>层级关系明显，功能划分清晰，父类和子类各做各的</li>
<li>父类的所有变化，都需要在子类中体现，也就是说此时耦合已成为需求</li>
</ul>
<h1 id="六大基本设计原则"><a href="#六大基本设计原则" class="headerlink" title="六大基本设计原则"></a>六大基本设计原则</h1><h3 id="（1）单一职责（Single-Responsibility-Principle）–-SRP"><a href="#（1）单一职责（Single-Responsibility-Principle）–-SRP" class="headerlink" title="（1）单一职责（Single Responsibility Principle）– SRP"></a>（1）单一职责（Single Responsibility Principle）– SRP</h3><blockquote>
<p>就一个类而言，应该仅有一个引起它变化的原因。</p>
<p>也就是一个类值负责一个职责的工作</p>
</blockquote>
<p><strong>A：</strong>一个类（或者大到模块，小到方法）承担的<code>职责越多</code>，它<code>被复用的可能性越小</code>，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运行；</p>
<p><strong>B：</strong>类的职责主要包括两个方面：<code>数据职责</code>和<code>行为职责</code>，数据职责通过其属性来提现，而行为职责通过其方法来体现；</p>
<p><strong>C：</strong>单一职责原则是实现<code>高内聚</code>、<code>低耦合</code>的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验；</p>
<p><strong>解决问题类型：</strong></p>
<p>类A负责两个职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类A时，有可能会导致原本运行正常的职责P2功能发生故障。</p>
<p><strong>解决方案：</strong></p>
<p>遵循SRP，分别建立两个类A1、A2，使A1完成职责P1，A2完成职责P2。这样，当修改类A1时，不会影响职责A2；同理，当修改A2时，也不会影响到职责P1</p>
<p><strong>e.g.</strong></p>
<p><strong>（1）</strong>最好的反例：MassiveViewController。比如写一个简单的应用程序，一般都会生成一个viewcontroller类，于是我们将各种各样的代码，算法、网络、数据库访问等等都放在这个类里面，这就意味着，无论任何需求变化，都需要修改ViewController这个类，这个其实是很糟糕的，维护麻烦，复用不可能、缺乏灵活性等。网上有很多解决的方法：<a href="https://toutiao.io/posts/xxr604/preview" target="_blank" rel="noopener"> 八种模式帮你告别 Massive View Controller</a>，但无论什么方法，都是在提倡优化职责划分，也是SRP的思想。</p>
<p><strong>（2）</strong>在使用tableView列表时，我们都很自然的将Model传给Cell，然后让Cell解析Model去渲染视图，并且感觉没有什么不妥的，美其曰：Cell的封装。代码如下</p>
<pre><code class="hljs objc">TestCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="hljs-string">@"TestCell"</span>];
<span class="hljs-keyword">if</span> (!cell) &#123;
    cell = (TestCell *)[[[<span class="hljs-built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="hljs-string">@"TestCell"</span> owner:<span class="hljs-keyword">self</span> options:<span class="hljs-literal">nil</span>] lastObject];
&#125;
TestModel *model = <span class="hljs-keyword">self</span>.dataList[indexPath.row];
[cell configWithModel:model];</code></pre>

<p>殊不知这已经违背SRP，<code>Cell的职责是描述与渲染自身，解析Model这个职责不属于Cell</code>，并且Cell中引入Model会增加不必要的依赖，Cell需要根据Model的改变而做出相应的修改，不利于Cell的复用。做过Android开发的同学都知道，其实如何让Model的数据呈现在Cell上是<a href="http://blog.csdn.net/fznpcy/article/details/8658155/" target="_blank" rel="noopener">Adapter</a>需要做的事情。</p>
<p>关于TableView与适配器如何使用======》》》》》》 请查看本文的<strong>适配器设计模式</strong></p>
<h3 id="（2）里氏替换原则（Liskov-Substitution-Principle）–-LSP"><a href="#（2）里氏替换原则（Liskov-Substitution-Principle）–-LSP" class="headerlink" title="（2）里氏替换原则（Liskov Substitution Principle）– LSP"></a>（2）里氏替换原则（Liskov Substitution Principle）– LSP</h3><blockquote>
<p>所有引用父类的地方都必须能够透明地使用其子类对象。</p>
<p>通俗说法：子类可以扩展父类的功能，但不能改变父类原有的功能，包括以下两点</p>
<p>a、子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</p>
<p>b、子类可以增加自己的特有方法</p>
</blockquote>
<p>面向对象编程中<code>继承</code>和<code>多态</code>，要遵守里氏替换原则.</p>
<p>继承在程序设计中带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来入侵，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类继承，则当这个类需要修改时，必须考虑到所有子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障</p>
<h3 id="（3）迪米特法则（Least-Knowledge-Principle）–LKP"><a href="#（3）迪米特法则（Least-Knowledge-Principle）–LKP" class="headerlink" title="（3）迪米特法则（Least Knowledge Principle）–LKP"></a>（3）迪米特法则（Least Knowledge Principle）–LKP</h3><blockquote>
<p>最少知识原则：如果两个类不必彼此直接通信，那么这个两个类就不应当发生直接的相互作用；如果其中一个类需要调用另外一个类的某个方法的话，可以通过第三者转发这个调用。</p>
</blockquote>
<p>Only talk to your immediate friends（<code>只和离你最近的朋友进行交互</code>）</p>
<p>什么是最近的朋友？</p>
<p>每个对象都会与其他对象之间有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。</p>
<p>耦合的方式有很多，如依赖、关联、组合、聚合等，其中，我们称出现在成员变量、方法参数、方法返回值中的类为最近的朋友，而出现在局部变量中的类则不是最近的朋友。</p>
<h3 id="（4）依赖倒置（Dependence-Inversion-Principle）–-DIP"><a href="#（4）依赖倒置（Dependence-Inversion-Principle）–-DIP" class="headerlink" title="（4）依赖倒置（Dependence Inversion Principle）– DIP"></a>（4）依赖倒置（Dependence Inversion Principle）– DIP</h3><blockquote>
<p>高层模块不应该依赖底层模块，二者都应该依赖于抽象 ；</p>
<p>抽象不应该依赖细节，细节应该依赖抽象；</p>
</blockquote>
<p><code>高层是指业务，底层的是指机制</code>；</p>
<p>比如：文件系统就是一层抽象，上层的文件操作逻辑不依赖具体的文件类型，而只负责数据读写，文件系统负责处理具体不同文件类型的操作；上层的业务细节依赖文件系统的抽象层。</p>
<p>依赖倒置的核心思想就是<code>面向接口编程</code>。平时说的“针对接口编程”，不要针对实现编程就是依赖倒置的最好提现，接口就是一种抽象，只要不修改接口声明，就可以大单调用，至少接口的内部实现无需关心，可以随便重构。</p>
<p>这里，<code>接口就是抽象</code>，而<code>接口的是实现就是细节</code>。</p>
<p><strong>解决问题类型：</strong></p>
<p>类A直接依赖类B，假如要将类B改为类C，则必须通过修改类A的代码来达成。类A一般是高层模块，负责复杂的业务逻辑。类B和类C是底层模块，负责基本的原子操作。修改类A，会给程序带来不必要的风险。</p>
<p><strong>解决方案：</strong></p>
<p>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<p><strong>解释：</strong></p>
<p>所谓<code>细节</code>就是较为<code>具体</code>的东西，比如具体的类，就如上面的类B与类C，有具体的实现。</p>
<p>所有<code>抽象</code>就是具有<code>契约性、共同性、规范性</code>的表达，比如上面的接口I。它表达了一种契约：你需要是实现funcA和funcB才能被当成I来对待。</p>
<p><code>相对于细节的多变性，抽象的东西要稳定的多</code>。</p>
<p>以上的类ABC作为例子，B，C类都属于细节，如果A直接依赖B或者C，那么B或者C的改动有可能就会影响到A的稳定性。同样的，A对B或C的操作也有可能影响到B或C的稳定性。这些互相影响，其实来源于直接的依赖，导致B或者C的细节暴露过多，而面对抽象的接口I，A只能操作funcA 和 funcB，从而<code>避免了不必要的暴露和风险</code></p>
<p><strong><code>以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多</code></strong>。稳定性表现在规范性、契约性、易修改性、扩展性、可维护性等</p>
<p>注意点：</p>
<ul>
<li><p><strong>分清细节与抽象</strong></p>
<p>虽然依赖倒置原则有很大的好处，但也不是所有的类都需要有抽象一个接口去对应，要视情况而定</p>
</li>
<li><p><strong>变量的声明类型尽量是抽象类或接口</strong></p>
<p>注意是尽量，而不是全部</p>
</li>
<li><p><strong>尽量不要覆写基类的方法</strong></p>
<p>如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响</p>
</li>
<li><p><strong>继承要遵循里氏替换原则</strong></p>
</li>
</ul>
<h3 id="（5）接口隔离（Interface-Segregation-Principle）–-ISP"><a href="#（5）接口隔离（Interface-Segregation-Principle）–-ISP" class="headerlink" title="（5）接口隔离（Interface Segregation Principle）– ISP"></a>（5）接口隔离（Interface Segregation Principle）– ISP</h3><blockquote>
<p>客户端不应该依赖它不需要的接口；</p>
<p>一个类对另一个类的依赖应该建立在最小的接口上。</p>
</blockquote>
<p>接口隔离原则有点像单一职责原则，但是也有区别，在单一职责中，一个接口可能有多个方法，提供给多种不同的调用者所调用，但是它们始终完成同一种功能，因此它们符号单一职责原则，却不符合接口隔离原则，因为这个接口存在着多种角色，因此可以拆分成更多的子接口，以供不同的调用者所调用。</p>
<p>比如：项目中我们通常有一个web服务管理的类，接口定义中，我们可能会将所有模块的数据调用方法都在接口中进行定义，因为它们都完成的是同一种功能吗：和服务器进行数据交互；但是对于具体的业务功能模块来说，其他模块的数据调用方法从来不会使用，因此不符合接口隔离原则。</p>
<p><strong>作用：</strong></p>
<p>设计一个<code>短而小</code>的接口和类，符合高内聚低耦合的设计思想，从而使得类具有良好的可读性、可扩展性和可维护性</p>
<p><strong>解决问题类型：</strong></p>
<p>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去是实现他们不需要的方法。</p>
<p><strong>解决方案：</strong></p>
<p>将臃肿的接口I拆为独立的几个接口，类A和类C分别于他们需要的接口建立依赖关系。</p>
<img src="https://i.loli.net/2020/08/03/wX8JPQlDL1jI2zx.png" srcset="/img/loading.gif" alt="image-20200803100228689" style="zoom:50%;" />

<p><strong>优点：</strong></p>
<p>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有依赖它的类去调用。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口要灵活。接口是设计时对外部设定的契约，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<ul>
<li><p><strong>接口隔离ISP 跟 之前的单一职责原则类似？</strong></p>
<p>其实不然。单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。<br>其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中实现的细节。而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建</p>
</li>
<li><p><strong>是否可用协议的可选实现（@optional）来解决接口隔离的问题？</strong></p>
<p>其实不然。@optional关注的是可有可无，但这种可有可无不是完全没有作用的。而ISP关注的是完全不需要实现的方法，对于实现类来说完全没有作用的。</p>
</li>
</ul>
<p><strong>注意点：</strong></p>
<p><code>接口尽量小，但是要有限度</code>。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所有一定要适度。<br>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。<br><code>只专注地为一个模块提供定制服务</code>，才能建立最小的依赖关系。提高内聚，减少对外交互。使接口用最小的方法去完成最多的事情。运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确的实践这一原则</p>
<h3 id="（6）开闭原则-Open-Closed-Principle-–-OCP"><a href="#（6）开闭原则-Open-Closed-Principle-–-OCP" class="headerlink" title="（6）开闭原则(Open-Closed Principle) – OCP"></a>（6）开闭原则(Open-Closed Principle) – OCP</h3><blockquote>
<p>Software entities should be open for extension,but closed for modification</p>
<p>对扩展开发，对修改关闭</p>
<p>(也就是说对模块的设计，应该满足将来在不可修改源代码的情况下对模块的职能扩展，或者改变模块的行为)</p>
</blockquote>
<p>开发-封闭原则的思想就是设计的时候，尽量让设计的类做好后就不再修改，如果有新的需求，通过新加类的方式来满足，而不去修改现有的类（代码）。</p>
<p>那么在实际的项目开发中，是否能做到绝对的对修改关闭呢？答案一般都是否定的，既然这样，那么就要求我们再开发前，去找出变化点，然后针对变化点构造抽象，隔离出这些变化。由此可见，<code>实现开闭原则关键是抽象</code></p>
<p><strong>e.g.</strong></p>
<img src="https://i.loli.net/2020/08/05/ob7gLO2FAc8SiN3.png" srcset="/img/loading.gif" alt="image-20200805155514425" style="zoom:50%;" />

<p>MusicPlayer根据不同的音乐类型来进行播放，MusicPlayer的实现</p>
<pre><code class="hljs objc"><span class="hljs-keyword">class</span> func playMusic(musicType:MusicType) -&gt; () &#123;
     
        <span class="hljs-keyword">switch</span> musicType &#123;
        <span class="hljs-keyword">case</span> .Classical:
            ClassicalMusic.init().playMusic()
        <span class="hljs-keyword">case</span> .Popular:
            PopularMusic.init().playMusic()
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>
        &#125;
    &#125;</code></pre>

<p>如果后期扩展需要支援摇滚音乐的播放的话，就需要修改MusicPlayer的内部实现。为了满足开闭原则，我们需要进行<code>抽象化设计</code>，可以新增音乐抽象类，具体的音乐作为其子类。播放器这对抽象音乐进行编程，播放哪种类型由客户端来决定。</p>
<img src="https://i.loli.net/2020/08/05/OoWfLeNmSYdgb6w.png" srcset="/img/loading.gif" alt="image-20200805155837041" style="zoom:50%;" />







<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="（1）适配器设计模式"><a href="#（1）适配器设计模式" class="headerlink" title="（1）适配器设计模式"></a>（1）适配器设计模式</h3><blockquote>
<p>将一个类的接口适配成用户所期待的，一个适配允许通常因为接口不兼容而不能一起工作的类在一起，做法是将类自己的接口包裹在一个已存在的类中。</p>
</blockquote>
<p><strong>e.g.</strong></p>
<p>推荐此<a href="https://www.jianshu.com/p/21595eba795b" target="_blank" rel="noopener">文章实例</a></p>
<p>文章实例是将原来的AVPlayer播放器替换成ijkPlayer，通过适配器PlayerAdapter实现旧AVPayer对象的接口，并将传入新ijkPlayer对象，对旧接口实现。</p>
<h3 id="（2）策略设计模式"><a href="#（2）策略设计模式" class="headerlink" title="（2）策略设计模式"></a>（2）策略设计模式</h3><blockquote>
<p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
</blockquote>
<p>策略模式的使用可以粗暴的分为3个角色</p>
<ul>
<li>策略类，或者定义为策略接口、策略协议，它为所有支持或相关的算法声明了一个共同的接口。</li>
<li>策略对象：它会实现策略协议，策略对象通常存在多个，分别封装实现具体的算法。</li>
<li>场景(context)类对象：配置有一个具体策略对象的示例，场景对象使用策略接口调用由具体策略类定义的算法。</li>
</ul>
<img src="https://i.loli.net/2020/08/05/CjEKeWT5sH8uzqS.png" srcset="/img/loading.gif" alt="image-20200805170338386" style="zoom:50%;" />



<p><strong>使用场景：</strong></p>
<p>在以下情形，考虑使用策略模式</p>
<ul>
<li>一个类在其操作中使用多个条件语句来定义许多行为，我们可以把相关的条件分支移动到它们自己的策略类中。</li>
<li>需要算法的各种变体。</li>
<li>需要避免把复杂的、与算法相关的数据结构暴露给客户端。</li>
</ul>
<h3 id="（3）装饰设计模式"><a href="#（3）装饰设计模式" class="headerlink" title="（3）装饰设计模式"></a>（3）装饰设计模式</h3><blockquote>
<p>装饰者模式可以动态的给指定的类添加一些行为和职责，而不用对原代码进行任何修改。就扩展功能来说，装饰设计模式相比于生成子类更为灵活。常见的实现方式：Category（类别）和 Delegation（委派）</p>
</blockquote>
<img src="https://i.loli.net/2020/08/06/7Fx62n4zSBWp9Ee.png" srcset="/img/loading.gif" alt="image-20200806100610345" style="zoom:50%;" />

<p><strong>e.g.</strong></p>
<p><a href="https://www.jianshu.com/p/f3408f3b548f" target="_blank" rel="noopener">原文</a> 有一个封面，后台返回的字段<code>&quot;pic&quot;: &quot;/image/20160826/d51285bb636281dce6974313eaf6f15d.png&quot;</code>只是一个路径，前面的域名<code>https://xxxxxx-aliyun.firstleap.cn</code>需要我们这边统一拼接，同事我们使用的阿里云存储服务，有对图片处理（包括图片压缩、减少图片分辨率），且iPhone和iPad的处理还不一样。</p>
<p>我们对String添加一个扩展（OC中为category），File/New/File…，选择Swift File，命名为<code>String + Aliyun</code>，添加以下代码：</p>
<pre><code class="hljs swift"><span class="hljs-comment">// 判断型号</span>
<span class="hljs-keyword">let</span> isPad = ( <span class="hljs-type">UI_USER_INTERFACE_IDIOM</span>() == .pad)
<span class="hljs-keyword">let</span> fileHost = <span class="hljs-string">"https://xxxxxx-aliyun.firstleap.cn"</span>

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">String</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aliyunThumb</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">if</span> isPad &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-string">"\(fileHost)\(self)"</span> + <span class="hljs-string">"!iPadThumb"</span>
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-string">"\(fileHost)\(self)"</span> + <span class="hljs-string">"!thumb"</span>
    &#125;
  &#125;
&#125;</code></pre>

<p>使用Delegation委托的方式（苹果UIKit中有很多都是代理委托模式，比如UITableView、UIcollectionView、UITextView等等）</p>
<pre><code class="hljs objc"><span class="hljs-comment">//Mydelegate.h</span>
<span class="hljs-comment">//可以单独放在一个.h文件,也可以直接放入A.h中</span>
<span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">Mydelegate</span>//协议的声明 中</span>
-(<span class="hljs-keyword">void</span>)Fun;
<span class="hljs-keyword">@end</span>

<span class="hljs-comment">//A.h</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"Mydelegate.h"</span></span>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">A</span>:<span class="hljs-title">NSObject</span> </span>&#123;
   <span class="hljs-keyword">id</span>&lt;Mydelegate&gt; delegate;<span class="hljs-comment">//声明一个委托对象，我们要把事情委托给实现Mydelegate协议的类</span>
&#125;
<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">assign</span>,<span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">id</span>&lt;Mydelegate&gt; delegate;
<span class="hljs-keyword">@end</span>

<span class="hljs-comment">//A.m</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"A.h"</span></span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span></span>
-(<span class="hljs-keyword">void</span>)FunToOther &#123;
    [delegate Fun];<span class="hljs-comment">//将消息发送给委托去处理</span>
&#125;
<span class="hljs-keyword">@end</span>

<span class="hljs-comment">//B.h</span>
<span class="hljs-meta">#import<span class="hljs-meta-string">"A.h"</span></span>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">B</span>:<span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">MyDelegate</span>&gt;</span>
<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">strong</span>,<span class="hljs-keyword">nonatomic</span>) A *a;
<span class="hljs-keyword">@end</span>

<span class="hljs-comment">//B.m</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"B.h"</span></span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span></span>
-(<span class="hljs-keyword">void</span>)init &#123;
  _a = [[A alloc] init];
  _a.delegate = <span class="hljs-keyword">self</span>;
&#125;

<span class="hljs-meta">#prage mark - MyDelegate</span>
-(<span class="hljs-keyword">void</span>)fun &#123;
    <span class="hljs-comment">//实现Mydelegate中制定的方法</span>
&#125;
<span class="hljs-keyword">@end</span></code></pre>



<h3 id="（4）外观模式"><a href="#（4）外观模式" class="headerlink" title="（4）外观模式"></a>（4）外观模式</h3><blockquote>
<p>外观设计模式为复杂的子系统提供单一的接口，只公开一个简单统一的API，而不是将一组类及其API暴露给用户。</p>
</blockquote>
<img src="https://i.loli.net/2020/08/06/65Qu1f9lkGYev4O.png" srcset="/img/loading.gif" alt="image-20200806104229560" style="zoom:50%;" />

<p>API的用户完全不知道下面的复杂性。这种模式在使用大量类时非常理想，特别是当它们复杂使用或难以理解时。</p>
<h3 id="面向接口编程-Interface-Oriented-Programming-–-IOP"><a href="#面向接口编程-Interface-Oriented-Programming-–-IOP" class="headerlink" title="面向接口编程(Interface Oriented Programming) – IOP"></a>面向接口编程(Interface Oriented Programming) – IOP</h3><h3 id="面向切片编程（Aspect-Oriented-Programming）AOP"><a href="#面向切片编程（Aspect-Oriented-Programming）AOP" class="headerlink" title="面向切片编程（Aspect Oriented Programming）AOP"></a>面向切片编程（Aspect Oriented Programming）AOP</h3><blockquote>
<p>程序要完成一件事情，一定会有一些步骤，1，2，3，4这样。这里分解出来的每一个步骤我们可以认为是一个切片。</p>
<p>面对切片编程就是针对每一个切片的间隙，塞一些代码进去，在程序正常运行1，2，3，4步的间隙可以跑到你塞进去的代码，那么你写的代码就是面向切片编程</p>
</blockquote>
<p>AOP一般都是需要有一个<code>拦截器</code>，然后在每一个切片运行之前和运行之后（或者任何你希望的地方），通过调用拦截器的方法来把这个jointpoint扔到外面，在外面获取这个jointpoint的时候，执行相应的代码。</p>
<p>可以使用</p>
<ul>
<li><p><strong>Method Swizzling</strong>（如第三方的<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a>）</p>
</li>
<li><p><strong>protocol</strong></p>
</li>
</ul>
<h3 id="依赖注入-Dependency-Injection-–-DI"><a href="#依赖注入-Dependency-Injection-–-DI" class="headerlink" title="依赖注入(Dependency Injection) – DI"></a>依赖注入(Dependency Injection) – DI</h3><p>参考文献：</p>
<p><a href="https://toutiao.io/posts/342302/app_preview" target="_blank" rel="noopener">谈谈依赖注入与面向接口编程思想</a></p>
<p><a href="https://www.jianshu.com/p/1f56168fe5b5" target="_blank" rel="noopener">iOS设计模式的六大设计原则</a></p>
<p><a href="https://catchzeng.com/2017/02/19/聊聊设计模式原则-一-单一职责原则/" target="_blank" rel="noopener">聊聊设计模式原则-一-单一职责原则</a></p>
<p><a href="https://catchzeng.com/2018/06/01/聊聊设计模式原则-三-依赖倒置原则/" target="_blank" rel="noopener">聊聊设计模式原则-三-依赖倒置原则</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Collect-%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Collect,架构及设计模式</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/08/04/MVVM%E6%8E%A2%E8%AE%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MVVM探讨</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/27/Flutter-%E6%A8%A1%E5%9D%97-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/">
                        <span class="hidden-mobile">Flutter_模块_网络请求封装</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script defer src="https://cdn.staticfile.org/valine/1.4.4/Valine.min.js" ></script>

  <script type="text/javascript">
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();

      new Valine({
        el: "#vcomments",
        app_id: "yXom8ixvXSnnf5ow9iuwTppi-gzGzoHsz",
        app_key: "Tb7YxoXCUDQsdcJI8M95cAWU",
        placeholder: "说点什么",
        path: window.location.pathname,
        avatar: "retro",
        meta: ["昵称"],
        pageSize: "20",
        lang: "zh-CN",
        highlight: false,
        recordIP: false,
        serverURLs: "",
      });
    };
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'true' === 'true',
      loop: 'all',
      order: 'random',
      theme: '#4169E1',
      preload: 'none',
      audio: [{"name":"Try","artist":"Marlisa","url":"/mp3/Try.mp3","cover":"/img/musicCover/Marlisa.jpeg"},{"name":"Love The Way You Lie + I need a doctor","artist":"Rihanna、Eminem","url":"/mp3/Love.mp3","cover":"/img/musicCover/Eminem.jpeg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 6,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->


  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?26e6317c907495b6a9e0a92188348969";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "架构与设计模式随笔&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 100,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
